#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
SV 1v1 (L100) PERFECT-BUILD OPTIMIZER — CPU-ONLY, SINGLE FILE
Version: 3.0.1 (Gen9-lite mechanics with optimal-play & stochastic branching, Py3.9+)
Author: ChatGPT (single-file, no web, no external deps)

WHAT'S NEW (3.0.1 over 3.0.0)
-----------------------------
- FIX: Grounded check now uses current defensive typing (post-Tera) so Electric Terrain
  boosts apply correctly when Flying is lost (or gained) via Terastallization.
- FIX: Tera Blast category now switches to Physical/Special ONLY when Terastallized,
  using the higher of Atk vs SpA; otherwise it remains Normal/Special.
- Minor internal cleanups; mechanics & scoring unchanged.

WHAT'S NEW (3.0.0 over 2.2.1)
-----------------------------
- CORE: True stochastic rules. We branch on hit/miss (and always-crit where relevant) instead of
  multiplying by accuracy. All thresholded effects (Focus Sash, Sturdy, Sitrus, Weakness Policy,
  recoil, Multiscale) now fire on actual hits only.
- ENDING: Official 1v1 sudden-death: after EXACTLY 3 full turns (or earlier KOs), higher %HP wins;
  equal is a tie. No heuristic horizon eval.
- FIELDS: Sun and Electric Terrain now boost move power properly (Sun: Fire×1.5, Water×0.5;
  Electric Terrain: grounded Electric×1.3). “Grounded” approximated by current defensive typing.
- TERA: Tera timing is applied before acting; STAB rules consistent for non–Tera Blast moves.
- CHOICE LOCK: Runtime enforcement—once locked, only that move remains (no status/counter/coat).
- SCORING: Mean P(win) vs each threat’s variant mix (equal weights by default) instead of worst-case.
  Trio metric uses best-of-three vs a threat’s variant mixture.
- SEARCH: SEARCH_TURNS is now 3 by default (full 1v1 window). EV refine runs on top candidates.

USAGE
-----
$ python sv1v1_optimizer.py
- Tune speed/quality: EV_STEPS, SEARCH_TURNS (keep 3 for faithful 1v1), THREAT_LIST.
- No dependencies. Deterministic given the code (stochastic is computed exactly by branching).

LICENSE
-------
Public domain (as-is). No warranty.
"""

import copy
import itertools
import math
import os
import time
from collections import defaultdict
from concurrent.futures import ProcessPoolExecutor, as_completed
from dataclasses import dataclass, field
from functools import lru_cache
from typing import Callable, Dict, List, Optional, Tuple, Union

from math import floor

# Canonical Gen 3+ damage roll distribution: uniform over 16 integers (85..100)
ROLL_TABLE: tuple[float, ...] = tuple(r / 100.0 for r in range(85, 101))  # 0.85..1.00
ROLL_PROB: float = 1.0 / 16.0


def _packed_state_signature(build: "SetBuild", st: "BattleState") -> tuple:
    """Compact signature used to merge equivalent branches after damage roll expansion."""

    return (
        st.hp,
        st.max_hp,
        st.stages["Atk"],
        st.stages["Def"],
        st.stages["SpA"],
        st.stages["SpD"],
        st.stages["Spe"],
        st.sash_intact,
        st.sturdy_intact,
        st.tera_used,
        st.tera_type,
        bool(st.ability_active.get("Protect", False)),
        st.locked_move,
        st.multiscale_on,
        tuple(sorted(k for k, v in st.consumed_item.items() if v)),
    )


def _merge_branch_states(
    branches: list[tuple[float, "BattleState", "BattleState"]]
) -> list[tuple[float, "BattleState", "BattleState"]]:
    """Merge branches that are state-equivalent to control branching growth."""

    merged: dict[tuple, tuple[float, "BattleState", "BattleState"]] = {}
    for p, A, B in branches:
        sig = (_packed_state_signature(None, A), _packed_state_signature(None, B))
        if sig in merged:
            oldp, oldA, oldB = merged[sig]
            merged[sig] = (oldp + p, A, B)
        else:
            merged[sig] = (p, A, B)
    return list(merged.values())

# ===== EV SEARCH — FULL GRID + MATCHUP-AWARE SPEED TIERS + PARETO + LOCAL REFINEMENT =============

EV_STEPS = list(range(0, 253, 4))  # 0..252 in legal 4-EV increments
EV_TOTAL_MAX = 510                 # keep in sync with the rest of your code


def _nature_mult(nat: str, stat: str) -> float:
    up, down = NATURES.get(nat, (None, None))
    if up == stat:
        return 1.1
    if down == stat:
        return 0.9
    return 1.0


def _spe_after_mod(base_stats: dict, nature: str, ev: int, iv: int, item: str, stages: int, pq_speed_mult: float) -> float:
    raw = floor(((2 * base_stats["Spe"] + iv + ev // 4) * 100) / 100) + 5
    raw = floor(raw * _nature_mult(nature, "Spe"))
    scarf = 1.5 if item == "Choice Scarf" else 1.0
    s = max(-6, min(6, stages))
    stage_m = (2 + s) / 2 if s >= 0 else 2 / (2 - s)
    return raw * scarf * stage_m * pq_speed_mult


def _speed_targets_for(attacker_species: str, attacker_item: str, attacker_nature: str, opp_builds: list["SetBuild"]) -> list[int]:
    """Derive realistic Speed targets to prune Spe EVs to meaningful breakpoints."""
    iv31 = 31
    ability = SPECIES_DATA[attacker_species].ability_hint
    pq_candidates = (1.0, 1.3) if ability in ("Protosynthesis", "Quark Drive") else (1.0,)
    plus_one_possible = (ability == "Speed Boost") or (attacker_species == "Quaquaval")  # Aqua Step

    # rough upper-bound opponent speeds (fast nature 252 & neutral 252)
    targets = set()
    for ob in (opp_builds or []):
        ob_spec = SPECIES_DATA[ob.species]
        ob_fast = _spe_after_mod(ob_spec.base, "Jolly", 252, iv31, "", 0, 1.0)
        ob_neut = _spe_after_mod(ob_spec.base, "Adamant", 252, iv31, "", 0, 1.0)
        for b in (ob_fast, ob_neut):
            for margin in (0, 1, 2):
                targets.add(int(b) + margin)

    if plus_one_possible:
        targets |= {t + 1 for t in list(targets)}

    for pqm in pq_candidates:
        for t in list(targets):
            targets.add(int(t * pqm))

    if not targets:
        return EV_STEPS.copy()

    cand = {0, 252}
    for pqm in pq_candidates:
        for stg in ((0, 1) if plus_one_possible else (0,)):
            for tgt in sorted(targets):
                chosen = None
                for ev in EV_STEPS:
                    eff = _spe_after_mod(SPECIES_DATA[attacker_species].base, attacker_nature, ev, iv31, attacker_item, stg, pqm)
                    if eff >= tgt:
                        chosen = ev
                        break
                if chosen is not None:
                    cand.add(chosen)
                    if chosen >= 4:
                        cand.add(chosen - 4)
    return sorted(cand)


def _proxy_tuple(spec: "Species", nature: str, evs: dict[str, int]) -> tuple[int, int, int, int, int]:
    """Cheap dominance proxy over atk-like, spa-like, bulk (HP*Def, HP*SpD), and Speed."""
    ivs = {"HP": 31, "Atk": 31, "Def": 31, "SpA": 31, "SpD": 31, "Spe": 31}
    st = calc_stats(spec, nature, evs, ivs)
    return (st["Atk"], st["SpA"], st["HP"] * st["Def"], st["HP"] * st["SpD"], st["Spe"])


def iterate_evs_axes_matchup_aware(
    axes: tuple[str, ...],
    species: str,
    nature: str,
    item: str,
    opp_builds: list["SetBuild"],
) -> list[dict[str, int]]:
    """Enumerate legal EVs with matchup-aware Spe pruning and Pareto filtering."""
    spec = SPECIES_DATA[species]
    spe_values = _speed_targets_for(species, item, nature, opp_builds) if "Spe" in axes else []
    grid_per_axis = [spe_values if (a == "Spe" and spe_values) else EV_STEPS for a in axes]

    def _valid(e: dict[str, int]) -> bool:
        return sum(e.values()) <= EV_TOTAL_MAX and all((v % 4) == 0 and v <= 252 for v in e.values())

    pareto: list[tuple[tuple[int, int, int, int, int], int, dict[str, int]]] = []
    for vals in itertools.product(*grid_per_axis):
        e = {ax: vals[i] for i, ax in enumerate(axes)}
        for k in ("HP","Atk","Def","SpA","SpD","Spe"):
            e.setdefault(k, 0)
        if not _valid(e):
            continue
        key = _proxy_tuple(spec, nature, e)

        dominated = False
        to_remove: list[int] = []
        for idx, (ok, _, _) in enumerate(pareto):
            ge_all = all(k >= o for k, o in zip(key, ok))
            gt_any = any(k > o for k, o in zip(key, ok))
            le_all = all(k <= o for k, o in zip(key, ok))
            lt_any = any(k < o for k, o in zip(key, ok))
            if ge_all and gt_any:
                to_remove.append(idx)  # new dominates old
            elif le_all and lt_any:
                dominated = True       # old dominates new
                break
        if dominated:
            continue
        for j in reversed(to_remove):
            pareto.pop(j)
        pareto.append((key, sum(e.values()), e))
    return [e for _, _, e in pareto]


def refine_evs_local(
    base: "SetBuild",
    eval_fn: Callable[["SetBuild"], float],
    axes: tuple[str, ...],
    passes: int = 128,
) -> "SetBuild":
    """Exact hill-climb over 4-EV swaps among the chosen axes scored by the true simulator."""
    best = copy.deepcopy(base)
    best_score = eval_fn(best)
    tabu: set[tuple[int, int, int, int, int, int]] = set()

    def pack(ev: dict[str, int]) -> tuple[int, int, int, int, int, int]:
        return (ev["HP"], ev["Atk"], ev["Def"], ev["SpA"], ev["SpD"], ev["Spe"])

    step = 4
    for _ in range(passes):
        improved = False
        cur = best.evs
        tabu.add(pack(cur))
        for i in range(len(axes)):
            for j in range(len(axes)):
                if i == j: continue
                a, b = axes[i], axes[j]
                if cur[b] < step or cur[a] > 248:  # bounds
                    continue
                cand_evs = dict(cur)
                cand_evs[a] += step
                cand_evs[b] -= step
                if sum(cand_evs.values()) > EV_TOTAL_MAX:
                    continue
                key = pack(cand_evs)
                if key in tabu:
                    continue
                cand = copy.deepcopy(best)
                cand.evs = cand_evs
                score = eval_fn(cand)
                if score > best_score + 1e-12:
                    best, best_score, improved = cand, score, True
                    break
            if improved: break
        if not improved:
            break
    return best


def enumerate_candidates_for_species(species: str) -> list["SetBuild"]:
    """Items/tera/natures/moves × (matchup-aware EV Pareto)."""
    spec = SPECIES_DATA[species]
    items = ITEM_CANDIDATES[species]
    teras = TERA_POOLS[species]
    pool = LEGAL_MOVES[species]
    ms_all = movesets_from_pool(pool, FOUR_PHYSICAL_ONLY[species], species)

    ev_axes = ("HP","Atk","Def","Spe") if spec.base["Atk"] >= spec.base["SpA"] else ("HP","SpA","SpD","Spe")
    ivs31 = {k: 31 for k in ["HP","Atk","Def","SpA","SpD","Spe"]}

    # compact representative opp builds (first variant per threat)
    rep_opp: list["SetBuild"] = []
    seen = set()
    for t in THREAT_LIST:
        r = resolve_species_name(t) or t
        if r in seen: continue
        seen.add(r)
        av = adversary_variants(r)
        if av:
            builds, _w = av
            if builds:
                rep_opp.append(builds[0])
        if len(rep_opp) >= 12:
            break

    cands: list["SetBuild"] = []
    for item in items:
        for tera in teras:
            if species == "Swampert":
                natures = ["Adamant", "Careful", "Impish"]
            elif species == "Blaziken":
                natures = ["Jolly", "Adamant"]
            else:
                natures = ["Jolly", "Adamant"]
            for nature in natures:
                ev_pareto = iterate_evs_axes_matchup_aware(ev_axes, species, nature, item, rep_opp)
                for evs in ev_pareto:
                    if not valid_evs(evs):
                        continue
                    for mv in ms_all:
                        if not filter_moveset_by_item(item, mv):
                            continue
                        assert_legal_moves(species, mv)
                        cands.append(
                            SetBuild(
                                species=species,
                                item=item,
                                ability=spec.ability_hint,
                                tera_type=tera,
                                nature=nature,
                                evs=evs,
                                ivs=ivs31,
                                moves=mv,
                            )
                        )
    return cands

# ===== MOVE REGISTRY HELPERS (add missing moves with sensible defaults; no duplicates) ============

def _add_if_missing(
    name: str,
    mtype: str,
    category: str,         # "Physical" | "Special" | "Status"
    power: int = 0,
    accuracy: float = 1.0,
    *,
    contact: bool = False,
    priority: int = 0,
    is_punch: bool = False,
    is_slicing: bool = False,
    multi_hits: int = 1,
    always_crit: bool = False,
):
    if name in MOVE_DB:
        return
    MOVE_DB[name] = Move(
        name=name,
        mtype=mtype,
        category=category,
        power=power,
        accuracy=accuracy,
        contact=contact,
        priority=priority,
        is_punch=is_punch,
        multi_hits=multi_hits,
        always_crit=always_crit,
        is_tera_blast=(name == "Tera Blast"),
    )
    if is_slicing:
        object.__setattr__(MOVE_DB[name], "is_slicing", True)

# Priority / staples / signatures likely encountered in threats or trio movepools
for __mv in [
    ("Extreme Speed","Normal","Physical",80,1.0,True,2,False,False,1,False),
    ("Bullet Punch","Steel","Physical",40,1.0,True,1,False,False,1,False),
    ("Mach Punch","Fighting","Physical",40,1.0,True,1,False,False,1,False),
    ("Aqua Jet","Water","Physical",40,1.0,True,1,False,False,1,False),
    ("Ice Shard","Ice","Physical",40,1.0,False,1,False,False,1,False),
    ("Kowtow Cleave","Dark","Physical",85,1.0,True,0,False,False,1,False),
    ("Make It Rain","Steel","Special",120,0.9,False,0,False,False,1,False),
    ("Salt Cure","Rock","Physical",40,1.0,False,0,False,False,1,False),
    ("Torch Song","Fire","Special",80,1.0,False,0,False,False,1,False),
    ("Fiery Wrath","Dark","Special",90,1.0,False,0,False,False,1,False),
    ("Ivy Cudgel","Grass","Physical",100,1.0,True,0,False,False,1,False),
    ("Hydro Steam","Water","Special",80,1.0,False,0,False,False,1,False),
    ("Wicked Blow","Dark","Physical",80,1.0,True,0,False,False,1,True),
    ("Surging Strikes","Water","Physical",25,1.0,True,0,False,False,3,True),
    ("Flower Trick","Grass","Physical",70,1.0,True,0,False,False,1,True),
    ("Icicle Crash","Ice","Physical",85,0.9,True,0,False,False,1,False),
    ("Sacred Sword","Fighting","Physical",90,1.0,True,0,False,False,1,False),
    ("Spirit Break","Fairy","Physical",75,1.0,True,0,False,False,1,False),
    ("Blood Moon","Normal","Special",140,0.9,False,0,False,False,1,False),
    ("Steam Eruption","Water","Special",110,0.95,False,0,False,False,1,False),
    ("Tachyon Cutter","Steel","Special",50,1.0,False,0,False,False,1,False),
    ("Draining Kiss","Fairy","Special",50,1.0,False,0,False,False,1,False),
    ("Hyper Voice","Normal","Special",90,1.0,False,0,False,False,1,False),
    ("Mystical Fire","Fire","Special",75,1.0,False,0,False,False,1,False),
    ("Freeze-Dry","Ice","Special",70,1.0,False,0,False,False,1,False),
    ("Flip Turn","Water","Physical",60,1.0,True,0,False,False,1,False),
]:
    _add_if_missing(*__mv)

RECOIL_RATIO.update({"Flare Blitz": 1/3, "Brave Bird": 1/3, "Wild Charge": 1/4, "Wave Crash": 1/3})

# ===== TRIO MOVEPOOLS (SV-legal; level/TM/egg/move tutor remembered in SV) =======================

SV_MOVES_SWAMPERT = sorted(set([
    # Water
    "Aqua Jet","Aqua Tail","Chilling Water","Hydro Pump","Hydro Cannon","Liquidation","Rain Dance","Surf","Waterfall",
    # Ground / Rock
    "Bulldoze","Dig","Earthquake","High Horsepower","Mud Shot","Rock Slide","Rock Tomb","Sandstorm","Stealth Rock","Stone Edge","Stomping Tantrum",
    # Ice
    "Avalanche","Ice Beam","Ice Fang","Ice Punch","Ice Spinner","Icy Wind",
    # Steel / Normal
    "Flash Cannon","Facade","Double-Edge","Giga Impact","Hyper Beam","Endeavor",
    # Utility / Status
    "Protect","Detect","Substitute","Yawn","Curse","Rest","Sleep Talk",
    # Coverage / Misc
    "Brick Break","Body Press","Counter","Low Kick","Low Sweep","Power-Up Punch",
    "Trailblaze","Energy Ball",  # Grass coverage via TM
    "Rock Blast","Iron Head","Knock Off","Thief","Shadow Claw","Zen Headbutt","Psychic","Psyshock",
    # Electric (limited punches/TM)
    "Thunder Punch","Wild Charge",
    # Flying / Bug (rare TMs)
    "Aerial Ace","U-turn",
    # Tera
    "Tera Blast",
]))

SV_MOVES_BLAZIKEN = sorted(set([
    # Fire
    "Blaze Kick","Fire Punch","Flame Charge","Flamethrower","Fire Blast","Overheat","Heat Wave","Flare Blitz","Sunny Day","Fire Spin",
    # Fighting
    "Close Combat","Low Kick","Low Sweep","Reversal","Brick Break","Drain Punch","Bulk Up","Counter","Body Press","Vacuum Wave",
    # Flying
    "Brave Bird","Aerial Ace","Bounce","Acrobatics",
    # Dark / Ghost
    "Knock Off","Night Slash","Thief","Sucker Punch","Shadow Claw",
    # Ground / Rock
    "Bulldoze","Dig","Earthquake","Rock Slide","Rock Tomb","Stone Edge","Stomping Tantrum",
    # Electric / Psychic / Poison
    "Thunder Punch","Zen Headbutt","Poison Jab",
    # Normal / Utility
    "Quick Attack","Giga Impact","Hyper Beam","Facade","Endure","Protect","Detect","Substitute","Focus Energy","Agility","Taunt","Encore","Sunny Day","Rest","Sleep Talk","Work Up","Baton Pass","Roar",
    # Bug / Grass
    "U-turn","Pounce","Trailblaze","Leech Life",
    # Water (niche TM)
    "Rain Dance",
    # Tera
    "Tera Blast",
]))

SV_MOVES_QUAQUAVAL = sorted(set([
    # Signature / Water
    "Aqua Step","Aqua Cutter","Aqua Jet","Liquidation","Waterfall","Flip Turn","Surf","Hydro Pump","Hydro Cannon","Chilling Water","Rain Dance",
    # Fighting
    "Close Combat","Drain Punch","Brick Break","Low Kick","Low Sweep","Reversal","Bulk Up","Body Press","Counter",
    # Flying
    "Brave Bird","Acrobatics","Aerial Ace","Air Slash","Hurricane",
    # Ice
    "Ice Spinner","Avalanche","Icy Wind","Ice Beam",
    # Dark / Bug / Grass
    "Knock Off","U-turn","Pounce","Trailblaze",
    # Utility / Normal
    "Protect","Detect","Encore","Taunt","Substitute","Rest","Sleep Talk","Giga Impact","Hyper Beam","Facade","Endure","Helping Hand",
    # Ground / Rock (TMs)
    "Bulldoze","Rock Slide","Rock Tomb","Stone Edge",
    # Electric / Psychic (limited TMs)
    "Thunder Punch","Zen Headbutt",
    # Tera
    "Tera Blast",
]))

# Ensure every referenced move exists in MOVE_DB
# (Actual definitions are seeded later; we no longer create placeholder stubs here.)
for _mv in (SV_MOVES_SWAMPERT + SV_MOVES_BLAZIKEN + SV_MOVES_QUAQUAVAL):
    if _mv not in MOVE_DB:
        continue

# Maintain legacy aliases for downstream consumers
LEGAL_MOVES_SWAMPERT = SV_MOVES_SWAMPERT
LEGAL_MOVES_BLAZIKEN = SV_MOVES_BLAZIKEN
LEGAL_MOVES_QUAQUAVAL = SV_MOVES_QUAQUAVAL

# Trio legal move map used by your enumerator
LEGAL_MOVES = {
    "Swampert": SV_MOVES_SWAMPERT,
    "Blaziken": SV_MOVES_BLAZIKEN,
    "Quaquaval": SV_MOVES_QUAQUAVAL,
}

# ===== ABILITY MULTIPLIERS (biggest effect-size; offense & defense) ==============================

def ability_offense_mult(
    self_build: SetBuild,
    self_state: BattleState,
    mv: Move,
    stats_self: Dict[str, int],
    current_stab_mult: float,
) -> Tuple[float, float]:
    """
    Returns (atk_like_multiplier, stab_multiplier_adjustment).
    - atk_like_multiplier multiplies the effective attacking stat AFTER stages/choice/PQ.
    - stab_multiplier_adjustment multiplies the computed STAB (for Adaptability etc).
    """
    name = SPECIES_DATA[self_build.species].ability_hint or ""
    atk_mult = 1.0
    stab_adj = 1.0

    if name == "Huge Power" and mv.category == "Physical":
        atk_mult *= 2.0
    if mv.category != "Status" and base_power(mv) <= 60 and name == "Technician":
        atk_mult *= 1.5
    if name == "Tough Claws" and is_contact_effective(mv, self_build.item):
        atk_mult *= 1.3
    if name == "Iron Fist" and mv.is_punch:
        atk_mult *= 1.2
    if name == "Sharpness" and getattr(mv, "is_slicing", False):
        atk_mult *= 1.5

    low_hp = (self_state.hp * 3) <= self_state.max_hp
    if low_hp:
        if name == "Torrent" and mv.mtype == "Water":   atk_mult *= 1.5
        if name == "Blaze"   and mv.mtype == "Fire":    atk_mult *= 1.5
        if name == "Overgrow"and mv.mtype == "Grass":   atk_mult *= 1.5
        if name == "Swarm"   and mv.mtype == "Bug":     atk_mult *= 1.5

    if name == "Adaptability" and current_stab_mult > 1.0 and mv.category != "Status":
        stab_adj *= (2.0 / 1.5)  # boost STAB from 1.5x to 2.0x

    return atk_mult, stab_adj


def ability_defense_mult(opp_build: SetBuild, mv: Move) -> float:
    """Defender-side reduction (e.g., Thick Fat)."""
    name = SPECIES_DATA[opp_build.species].ability_hint or ""
    if name == "Thick Fat" and mv.mtype in ("Fire","Ice"):
        return 0.5
    return 1.0

# Helpful ability hints for key threats (only used when present)
def _bump_ability_hint(spec_name: str, ability: str):
    if spec_name in SPECIES_DATA:
        sp = SPECIES_DATA[spec_name]
        SPECIES_DATA[spec_name] = Species(sp.name, sp.types, sp.base, ability)

for __pair in [
    ("Iron Bundle","Quark Drive"),
    ("Iron Hands","Quark Drive"),
    ("Azumarill","Huge Power"),
    ("Scizor","Technician"),
    ("Porygon-Z","Adaptability"),
]:
    _bump_ability_hint(*__pair)

# ===== MOVESIDE EFFECTS EXTENSION (Aqua Step speed boost; keep your existing drops) ==============

def apply_stat_side_effects_after(self_state: BattleState, move: Move):
    # Existing stage drops (examples)
    if move.name == "Close Combat":
        self_state.stages["Def"] = max(-6, self_state.stages["Def"] - 1)
        self_state.stages["SpD"] = max(-6, self_state.stages["SpD"] - 1)
    elif move.name == "Draco Meteor":
        self_state.stages["SpA"] = max(-6, self_state.stages["SpA"] - 2)
    elif move.name == "Leaf Storm":
        self_state.stages["SpA"] = max(-6, self_state.stages["SpA"] - 2)
    elif move.name == "Headlong Rush":
        self_state.stages["Def"] = max(-6, self_state.stages["Def"] - 1)
        self_state.stages["SpD"] = max(-6, self_state.stages["SpD"] - 1)
    # New: Aqua Step
    if move.name == "Aqua Step":
        self_state.stages["Spe"] = min(6, self_state.stages["Spe"] + 1)

def is_contact_effective(move: Move, attacker_item: str) -> bool:
    # Punching Glove removes contact on punching moves
    if attacker_item == "Punching Glove" and move.is_punch:
        return False
    return move.contact

# ===== THREAT PRESETS (legality-correct 1v1-style sets). Fallback generator remains available. ===

def _evs(hp, atk, deff, spa, spd, spe): return {"HP": hp, "Atk": atk, "Def": deff, "SpA": spa, "SpD": spd, "Spe": spe}
_IV31 = {"HP":31,"Atk":31,"Def":31,"SpA":31,"SpD":31,"Spe":31}

THREAT_PRESETS: dict[str, list[SetBuild]] = {
    "Dragonite": [
        SetBuild("Dragonite","Choice Band","Multiscale","Normal","Adamant",_evs(0,252,4,0,0,252),_IV31,["Extreme Speed","Outrage","Earthquake","Fire Punch"]),
        SetBuild("Dragonite","Weakness Policy","Multiscale","Normal","Adamant",_evs(252,252,4,0,0,0),_IV31,["Extreme Speed","Earthquake","Fire Punch","Dragon Claw"]),
    ],
    "Kingambit": [
        SetBuild("Kingambit","Black Glasses",None,"Dark","Adamant",_evs(0,252,4,0,0,252),_IV31,["Kowtow Cleave","Sucker Punch","Iron Head","Brick Break"]),
    ],
    "Flutter Mane": [
        SetBuild("Flutter Mane","Choice Specs","Protosynthesis","Fairy","Timid",_evs(0,0,4,252,0,252),_IV31,["Moonblast","Shadow Ball","Mystical Fire","Power Gem"]),
    ],
    "Iron Bundle": [
        SetBuild("Iron Bundle","Booster Energy","Quark Drive","Ice","Timid",_evs(0,0,4,252,0,252),_IV31,["Freeze-Dry","Hydro Pump","Ice Beam","Flip Turn"]),
        SetBuild("Iron Bundle","Focus Sash","Quark Drive","Ice","Timid",_evs(0,0,4,252,0,252),_IV31,["Freeze-Dry","Hydro Pump","Ice Beam","Encore"]),
    ],
    "Urshifu": [
        SetBuild("Urshifu","Choice Band",None,"Dark","Jolly",_evs(0,252,4,0,0,252),_IV31,["Wicked Blow","Close Combat","Sucker Punch","Iron Head"]),
    ],
    "Urshifu-Rapid-Strike": [
        SetBuild("Urshifu-Rapid-Strike","Choice Band",None,"Water","Jolly",_evs(0,252,4,0,0,252),_IV31,["Surging Strikes","Close Combat","Ice Spinner","Aqua Jet"]),
    ],
    "Volcarona": [
        SetBuild("Volcarona","Leftovers",None,"Fairy","Timid",_evs(252,0,4,0,0,252),_IV31,["Flamethrower","Bug Buzz","Giga Drain","Protect"]),
    ],
    "Gholdengo": [
        SetBuild("Gholdengo","Choice Specs",None,"Steel","Modest",_evs(0,0,0,252,4,252),_IV31,["Make It Rain","Shadow Ball","Thunderbolt","Focus Blast"]),
    ],
    "Garganacl": [
        SetBuild("Garganacl","Leftovers",None,"Water","Impish",_evs(252,0,252,0,4,0),_IV31,["Salt Cure","Body Press","Rock Slide","Protect"]),
    ],
    "Great Tusk": [
        SetBuild("Great Tusk","Choice Scarf",None,"Ground","Jolly",_evs(0,252,4,0,0,252),_IV31,["Headlong Rush","Close Combat","Ice Spinner","Rock Slide"]),
    ],
    "Iron Hands": [
        SetBuild("Iron Hands","Assault Vest",None,"Electric","Adamant",_evs(252,252,4,0,0,0),_IV31,["Drain Punch","Thunder Punch","Ice Punch","Earthquake"]),
    ],
    "Roaring Moon": [
        SetBuild("Roaring Moon","Booster Energy","Protosynthesis","Flying","Jolly",_evs(0,252,4,0,0,252),_IV31,["Acrobatics","Crunch","Earthquake","Dragon Claw"]),
    ],
    "Raging Bolt": [
        SetBuild("Raging Bolt","Choice Specs","Protosynthesis","Electric","Modest",_evs(0,0,0,252,4,252),_IV31,["Thunderbolt","Draco Meteor","Dragon Pulse","Flamethrower"]),
    ],
    "Walking Wake": [
        SetBuild("Walking Wake","Choice Specs","Protosynthesis","Water","Timid",_evs(0,0,0,252,4,252),_IV31,["Hydro Steam","Draco Meteor","Flamethrower","Dragon Pulse"]),
    ],
    "Garchomp": [
        SetBuild("Garchomp","Choice Band",None,"Ground","Jolly",_evs(0,252,4,0,0,252),_IV31,["Earthquake","Outrage","Rock Slide","Fire Punch"]),
    ],
    "Haxorus": [
        SetBuild("Haxorus","Choice Band",None,"Dragon","Jolly",_evs(0,252,4,0,0,252),_IV31,["Outrage","Earthquake","Poison Jab","Rock Slide"]),
    ],
    "Primarina": [
        SetBuild("Primarina","Choice Specs",None,"Fairy","Modest",_evs(0,0,0,252,4,252),_IV31,["Moonblast","Hydro Pump","Ice Beam","Psychic"]),
    ],
    "Moltres-Galar": [
        SetBuild("Moltres-Galar","Weakness Policy",None,"Dark","Modest",_evs(0,0,0,252,4,252),_IV31,["Fiery Wrath","Hurricane","Flamethrower","Protect"]),
    ],
    "Scizor": [
        SetBuild("Scizor","Life Orb",None,"Steel","Adamant",_evs(0,252,4,0,0,252),_IV31,["Bullet Punch","Close Combat","U-turn","Knock Off"]),
    ],
    "Skeledirge": [
        SetBuild("Skeledirge","Leftovers","Unaware","Fairy","Bold",_evs(252,0,252,0,4,0),_IV31,["Torch Song","Shadow Ball","Slack Off","Protect"]),
    ],
    "Sneasler": [
        SetBuild("Sneasler","Choice Band",None,"Flying","Jolly",_evs(0,252,4,0,0,252),_IV31,["Close Combat","Gunk Shot","Acrobatics","Ice Punch"]),
    ],
    "Dondozo": [
        SetBuild("Dondozo","Leftovers","Unaware","Water","Impish",_evs(252,252,4,0,0,0),_IV31,["Wave Crash","Body Press","Protect","Rest"]),
    ],
    "Porygon-Z": [
        SetBuild("Porygon-Z","Choice Specs","Adaptability","Normal","Timid",_evs(0,0,0,252,4,252),_IV31,["Hyper Voice","Tri Attack","Dark Pulse","Ice Beam"]),
    ],
    "Kyurem": [
        SetBuild("Kyurem","Choice Specs",None,"Ice","Timid",_evs(0,0,0,252,4,252),_IV31,["Freeze-Dry","Ice Beam","Earth Power","Draco Meteor"]),
    ],
    "Azumarill": [
        SetBuild("Azumarill","Sitrus Berry","Huge Power","Fairy","Adamant",_evs(252,252,4,0,0,0),_IV31,["Play Rough","Aqua Jet","Liquidation","Ice Punch"]),
    ],
    "Goodra-Hisui": [
        SetBuild("Goodra-Hisui","Assault Vest",None,"Steel","Modest",_evs(252,0,0,252,4,0),_IV31,["Draco Meteor","Flash Cannon","Thunderbolt","Flamethrower"]),
    ],
    "Landorus-Therian": [
        SetBuild("Landorus-Therian","Choice Scarf","Intimidate","Ground","Jolly",_evs(0,252,4,0,0,252),_IV31,["Earthquake","Stone Edge","U-turn","Knock Off"]),
    ],
    "Ninetales-Alola": [
        SetBuild("Ninetales-Alola","Light Clay",None,"Water","Timid",_evs(0,0,4,252,0,252),_IV31,["Freeze-Dry","Moonblast","Encore","Protect"]),
    ],
    "Ogerpon-Wellspring": [
        SetBuild("Ogerpon-Wellspring","Life Orb",None,"Water","Jolly",_evs(0,252,4,0,0,252),_IV31,["Ivy Cudgel","Power Whip","Play Rough","Knock Off"]),
    ],
    "Sylveon": [
        SetBuild("Sylveon","Choice Specs",None,"Fairy","Modest",_evs(252,0,0,252,4,0),_IV31,["Hyper Voice","Mystical Fire","Shadow Ball","Psyshock"]),
    ],
    "Volcanion": [
        SetBuild("Volcanion","Choice Specs",None,"Water","Modest",_evs(0,0,0,252,4,252),_IV31,["Steam Eruption","Flamethrower","Earth Power","Sludge Bomb"]),
    ],
    "Manaphy": [
        SetBuild("Manaphy","Leftovers",None,"Water","Timid",_evs(0,0,4,252,0,252),_IV31,["Surf","Ice Beam","Energy Ball","Protect"]),
    ],
    "Cresselia": [
        SetBuild("Cresselia","Leftovers",None,"Fairy","Calm",_evs(252,0,0,0,252,4),_IV31,["Psychic","Moonblast","Moonlight","Protect"]),
    ],
    "Meowscarada": [
        SetBuild("Meowscarada","Choice Band",None,"Grass","Jolly",_evs(0,252,4,0,0,252),_IV31,["Flower Trick","Knock Off","Play Rough","Low Kick"]),
    ],
}

# Keep your original generators, but prefer presets when available
if "_orig_make_default_adversary" not in globals():
    _orig_make_default_adversary = globals().get("make_default_adversary", lambda x: None)
def make_default_adversary(spec_name: str) -> Optional[SetBuild]:
    return _orig_make_default_adversary(spec_name) if _orig_make_default_adversary else None

if "_orig_adversary_variants" not in globals():
    _orig_adversary_variants = globals().get("adversary_variants", lambda x: None)
def adversary_variants(spec_name: str) -> Optional[Tuple[List[SetBuild], List[float]]]:
    key = resolve_species_name(spec_name) or spec_name
    if key in THREAT_PRESETS and THREAT_PRESETS[key]:
        variants = []
        for sb in THREAT_PRESETS[key]:
            # Only include variants whose moves exist in MOVE_DB
            ok = True
            for m in sb.moves:
                if m not in MOVE_DB:
                    ok = False; break
            if ok:
                variants.append(sb)
        if variants:
            w = [1.0/len(variants)]*len(variants)
            return variants, w
    if _orig_adversary_variants:
        return _orig_adversary_variants(spec_name)
    return None

# Optional alias normalization used elsewhere
ALIASES.update({"Galarian Moltres": "Moltres-Galar"})

# ===== USAGE IN SEARCH (example) ================================================================
# Wherever you currently do:
#   ev_candidates = iterate_evs_axes(...)
# replace it with:
#   ev_axes = ("HP","Atk","Def","Spe") if physical else ("HP","SpA","SpD","Spe")
#   ev_candidates = iterate_evs_axes_matchup_aware(ev_axes, species, nature, item, rep_opp_builds)
#
# And after scoring top-N builds:
#   best = refine_evs_local(best, eval_fn, ev_axes, passes=128)
#
# That’s it — the rest of your pipeline (items, tera, natures, movesets, simulator) remains unchanged.
# =================================================================================================

# =========================
#     TYPE CHART (GEN 9)
# =========================
TYPES = [
    "Normal",
    "Fire",
    "Water",
    "Electric",
    "Grass",
    "Ice",
    "Fighting",
    "Poison",
    "Ground",
    "Flying",
    "Psychic",
    "Bug",
    "Rock",
    "Ghost",
    "Dragon",
    "Dark",
    "Steel",
    "Fairy",
]

N = len(TYPES)
type_index: Dict[str, int] = {t: i for i, t in enumerate(TYPES)}
effectiveness: List[List[float]] = [[1.0 for _ in range(N)] for _ in range(N)]


def _se(a: str, b: str, m: float) -> None:
    effectiveness[type_index[a]][type_index[b]] = m


# Normal
_se("Normal", "Rock", 0.5)
_se("Normal", "Ghost", 0.0)
_se("Normal", "Steel", 0.5)
# Fire
for b in ["Grass", "Ice", "Bug", "Steel"]:
    _se("Fire", b, 2.0)
for b in ["Fire", "Water", "Rock", "Dragon"]:
    _se("Fire", b, 0.5)
# Water
for b in ["Fire", "Ground", "Rock"]:
    _se("Water", b, 2.0)
for b in ["Water", "Grass", "Dragon"]:
    _se("Water", b, 0.5)
# Electric
for b in ["Water", "Flying"]:
    _se("Electric", b, 2.0)
for b in ["Electric", "Grass", "Dragon"]:
    _se("Electric", b, 0.5)
_se("Electric", "Ground", 0.0)
# Grass
for b in ["Water", "Ground", "Rock"]:
    _se("Grass", b, 2.0)
for b in ["Fire", "Grass", "Poison", "Flying", "Bug", "Dragon", "Steel"]:
    _se("Grass", b, 0.5)
# Ice
for b in ["Grass", "Ground", "Flying", "Dragon"]:
    _se("Ice", b, 2.0)
for b in ["Fire", "Water", "Ice", "Steel"]:
    _se("Ice", b, 0.5)
# Fighting
for b in ["Normal", "Ice", "Rock", "Dark", "Steel"]:
    _se("Fighting", b, 2.0)
for b in ["Poison", "Flying", "Psychic", "Bug", "Fairy"]:
    _se("Fighting", b, 0.5)
_se("Fighting", "Ghost", 0.0)
# Poison
for b in ["Grass", "Fairy"]:
    _se("Poison", b, 2.0)
for b in ["Poison", "Ground", "Rock", "Ghost"]:
    _se("Poison", b, 0.5)
_se("Poison", "Steel", 0.0)
# Ground
for b in ["Fire", "Electric", "Poison", "Rock", "Steel"]:
    _se("Ground", b, 2.0)
for b in ["Grass", "Bug"]:
    _se("Ground", b, 0.5)
_se("Ground", "Flying", 0.0)
# Flying
for b in ["Grass", "Fighting", "Bug"]:
    _se("Flying", b, 2.0)
for b in ["Electric", "Rock", "Steel"]:
    _se("Flying", b, 0.5)
# Psychic
for b in ["Fighting", "Poison"]:
    _se("Psychic", b, 2.0)
for b in ["Psychic", "Steel"]:
    _se("Psychic", b, 0.5)
_se("Psychic", "Dark", 0.0)
# Bug
for b in ["Grass", "Psychic", "Dark"]:
    _se("Bug", b, 2.0)
for b in ["Fire", "Fighting", "Poison", "Flying", "Ghost", "Steel", "Fairy"]:
    _se("Bug", b, 0.5)
# Rock
for b in ["Fire", "Ice", "Flying", "Bug"]:
    _se("Rock", b, 2.0)
for b in ["Fighting", "Ground", "Steel"]:
    _se("Rock", b, 0.5)
# Ghost
for b in ["Psychic", "Ghost"]:
    _se("Ghost", b, 2.0)
for b in ["Dark"]:
    _se("Ghost", b, 0.5)
_se("Ghost", "Normal", 0.0)
# Dragon
for b in ["Dragon"]:
    _se("Dragon", b, 2.0)
for b in ["Steel"]:
    _se("Dragon", b, 0.5)
_se("Dragon", "Fairy", 0.0)
# Dark
for b in ["Psychic", "Ghost"]:
    _se("Dark", b, 2.0)
for b in ["Fighting", "Dark", "Fairy"]:
    _se("Dark", b, 0.5)
# Steel
for b in ["Ice", "Rock", "Fairy"]:
    _se("Steel", b, 2.0)
for b in ["Fire", "Water", "Electric", "Steel"]:
    _se("Steel", b, 0.5)
# Fairy
for b in ["Fighting", "Dragon", "Dark"]:
    _se("Fairy", b, 2.0)
for b in ["Fire", "Poison", "Steel"]:
    _se("Fairy", b, 0.5)

# Cache type multipliers (hot path)
_type_mult_cache: Dict[Tuple[int, int, int], float] = {}


def type_mult(move_type: str, defender_types: List[str]) -> float:
    t1 = type_index[move_type]
    d1 = type_index[defender_types[0]] if defender_types else -1
    d2 = type_index[defender_types[1]] if len(defender_types) > 1 else -1
    key = (t1, d1, d2)
    if key in _type_mult_cache:
        return _type_mult_cache[key]
    m = 1.0
    for dt in defender_types:
        m *= effectiveness[t1][type_index[dt]]
    _type_mult_cache[key] = m
    return m


# =========================
#       NATURES (L100)
# =========================
NATURES: Dict[str, Tuple[Optional[str], Optional[str]]] = {
    "Adamant": ("Atk", "SpA"),
    "Jolly": ("Spe", "SpA"),
    "Modest": ("SpA", "Atk"),
    "Timid": ("Spe", "Atk"),
    "Careful": ("SpD", "SpA"),
    "Calm": ("SpD", "Atk"),
    "Impish": ("Def", "SpA"),
    "Bold": ("Def", "Atk"),
    "Hasty": ("Spe", "Def"),
    "Naive": ("Spe", "SpD"),
    "Naughty": ("Atk", "SpD"),
    "Rash": ("SpA", "SpD"),
    "Mild": ("SpA", "Def"),
    "Lonely": ("Atk", "Def"),
    "Bashful": (None, None),
    "Docile": (None, None),
    "Serious": (None, None),
    "Hardy": (None, None),
    "Quirky": (None, None),
    "Gentle": ("SpD", "Def"),
}


def nature_mult(nature: str, stat: str) -> float:
    up, down = NATURES.get(nature, (None, None))
    if up == stat:
        return 1.1
    if down == stat:
        return 0.9
    return 1.0


# =========================
#         MOVES
# =========================
@dataclass(frozen=True)
class Move:
    name: str
    mtype: str
    category: str  # "Physical" or "Special" or "Status"
    power: int = 0
    accuracy: float = 1.0
    contact: bool = False
    is_punch: bool = False
    multi_hits: int = 1
    always_crit: bool = False
    priority: int = 0
    is_counter: bool = False
    is_mirror_coat: bool = False
    is_protect: bool = False
    is_swords_dance: bool = False
    is_tera_blast: bool = False
    # optional simple flags for common Gen 9 moves we included
    first_turn_only: bool = False  # e.g., First Impression


MOVE_DB: Dict[str, Move] = {
    # Utility
    "Protect": Move("Protect", "Normal", "Status", 0, 1.0, priority=4, is_protect=True),
    "Detect": Move(
        "Detect", "Normal", "Status", 0, 1.0, priority=4, is_protect=True
    ),  # alias
    "Swords Dance": Move(
        "Swords Dance", "Normal", "Status", 0, 1.0, is_swords_dance=True
    ),
    "Counter": Move(
        "Counter", "Fighting", "Physical", 0, 1.0, priority=-5, is_counter=True
    ),
    "Mirror Coat": Move(
        "Mirror Coat", "Psychic", "Special", 0, 1.0, priority=-5, is_mirror_coat=True
    ),
    # Tera Blast
    "Tera Blast": Move("Tera Blast", "Normal", "Special", 80, 1.0, is_tera_blast=True),
    # Physical staples
    "Earthquake": Move("Earthquake", "Ground", "Physical", 100, 1.0),
    "Liquidation": Move("Liquidation", "Water", "Physical", 85, 1.0, contact=True),
    "Ice Punch": Move(
        "Ice Punch", "Ice", "Physical", 75, 1.0, contact=True, is_punch=True
    ),
    "Rock Slide": Move("Rock Slide", "Rock", "Physical", 75, 0.9),
    "Flare Blitz": Move("Flare Blitz", "Fire", "Physical", 120, 1.0, contact=True),
    "Close Combat": Move(
        "Close Combat", "Fighting", "Physical", 120, 1.0, contact=True
    ),
    "Aqua Step": Move("Aqua Step", "Water", "Physical", 80, 1.0, contact=True),
    "Ice Spinner": Move("Ice Spinner", "Ice", "Physical", 80, 1.0, contact=True),
    "Brave Bird": Move("Brave Bird", "Flying", "Physical", 120, 1.0, contact=True),
    "Outrage": Move("Outrage", "Dragon", "Physical", 120, 1.0, contact=True),
    "Extreme Speed": Move(
        "Extreme Speed", "Normal", "Physical", 80, 1.0, priority=2, contact=True
    ),
    "Sucker Punch": Move(
        "Sucker Punch", "Dark", "Physical", 70, 1.0, priority=1, contact=True
    ),
    "Iron Head": Move("Iron Head", "Steel", "Physical", 80, 1.0, contact=True),
    "Knock Off": Move("Knock Off", "Dark", "Physical", 65, 1.0, contact=True),
    "Stone Edge": Move("Stone Edge", "Rock", "Physical", 100, 0.8),
    "Gunk Shot": Move("Gunk Shot", "Poison", "Physical", 120, 0.8, contact=True),
    "Surging Strikes": Move(
        "Surging Strikes",
        "Water",
        "Physical",
        25,
        1.0,
        contact=True,
        multi_hits=3,
        always_crit=True,
    ),
    "Wild Charge": Move("Wild Charge", "Electric", "Physical", 90, 1.0, contact=True),
    "Zen Headbutt": Move("Zen Headbutt", "Psychic", "Physical", 80, 0.9, contact=True),
    "Play Rough": Move("Play Rough", "Fairy", "Physical", 90, 0.9, contact=True),
    "Shadow Claw": Move("Shadow Claw", "Ghost", "Physical", 70, 1.0, contact=True),
    "Leech Life": Move("Leech Life", "Bug", "Physical", 80, 1.0, contact=True),
    "Power Whip": Move("Power Whip", "Grass", "Physical", 120, 0.85, contact=True),
    "Leaf Blade": Move("Leaf Blade", "Grass", "Physical", 90, 1.0, contact=True),
    # a few common Gen 9 additions that are easy to model
    "Headlong Rush": Move(
        "Headlong Rush", "Ground", "Physical", 120, 1.0, contact=True
    ),
    "First Impression": Move(
        "First Impression",
        "Bug",
        "Physical",
        90,
        1.0,
        contact=True,
        priority=2,
        first_turn_only=True,
    ),
    "Shadow Sneak": Move(
        "Shadow Sneak", "Ghost", "Physical", 40, 1.0, contact=True, priority=1
    ),
    # Special staples
    "Moonblast": Move("Moonblast", "Fairy", "Special", 95, 1.0),
    "Shadow Ball": Move("Shadow Ball", "Ghost", "Special", 80, 1.0),
    "Draco Meteor": Move("Draco Meteor", "Dragon", "Special", 130, 0.9),
    "Thunderbolt": Move("Thunderbolt", "Electric", "Special", 90, 1.0),
    "Ice Beam": Move("Ice Beam", "Ice", "Special", 90, 1.0),
    "Flamethrower": Move("Flamethrower", "Fire", "Special", 90, 1.0),
    "Hydro Pump": Move("Hydro Pump", "Water", "Special", 110, 0.8),
    "Psychic": Move("Psychic", "Psychic", "Special", 90, 1.0),
    "Psyshock": Move("Psyshock", "Psychic", "Special", 80, 1.0),  # SpA vs Def
    "Hurricane": Move("Hurricane", "Flying", "Special", 110, 0.7),
    "Flash Cannon": Move("Flash Cannon", "Steel", "Special", 80, 1.0),
    "Dark Pulse": Move("Dark Pulse", "Dark", "Special", 80, 1.0),
    "Hyper Beam": Move("Hyper Beam", "Normal", "Special", 150, 0.9),
    "Leaf Storm": Move("Leaf Storm", "Grass", "Special", 130, 0.9),
}

# recoil ratios (simplified)
RECOIL_RATIO: Dict[str, float] = {
    "Flare Blitz": 1 / 3,
    "Brave Bird": 1 / 3,
    "Wild Charge": 1 / 4,
}

# =========================
#         ITEMS
# =========================
ITEMS = [
    "Focus Sash",
    "Assault Vest",
    "Choice Band",
    "Choice Specs",
    "Choice Scarf",
    "Life Orb",
    "Leftovers",
    "Booster Energy",
    "Covert Cloak",
    "Black Glasses",
    "Sitrus Berry",
    "Weakness Policy",
    "Punching Glove",
    "Rocky Helmet",
]


# =========================
#       SPECIES DATA
# =========================
@dataclass(frozen=True)
class Species:
    name: str
    types: Tuple[str, Optional[str]]  # second may be None
    base: Dict[str, int]  # HP,Atk,Def,SpA,SpD,Spe
    ability_hint: Optional[str] = None


SPECIES_DATA: Dict[str, Species] = {
    # Our trio
    "Swampert": (
        "Swampert",
        ("Water", "Ground"),
        {"HP": 100, "Atk": 110, "Def": 90, "SpA": 85, "SpD": 90, "Spe": 60},
        "Torrent",
    ),
    "Blaziken": (
        "Blaziken",
        ("Fire", "Fighting"),
        {"HP": 80, "Atk": 120, "Def": 70, "SpA": 110, "SpD": 70, "Spe": 80},
        "Speed Boost",
    ),
    "Quaquaval": (
        "Quaquaval",
        ("Water", "Fighting"),
        {"HP": 85, "Atk": 120, "Def": 80, "SpA": 85, "SpD": 75, "Spe": 85},
        "Torrent",
    ),
    # Core threats (expandable)
    "Calyrex-Shadow": (
        "Calyrex-Shadow",
        ("Psychic", "Ghost"),
        {"HP": 100, "Atk": 85, "Def": 80, "SpA": 165, "SpD": 100, "Spe": 150},
        None,
    ),
    "Koraidon": (
        "Koraidon",
        ("Fighting", "Dragon"),
        {"HP": 100, "Atk": 135, "Def": 115, "SpA": 85, "SpD": 100, "Spe": 135},
        "Orichalcum Pulse",
    ),
    "Miraidon": (
        "Miraidon",
        ("Electric", "Dragon"),
        {"HP": 100, "Atk": 85, "Def": 100, "SpA": 135, "SpD": 115, "Spe": 135},
        "Hadron Engine",
    ),
    "Dragonite": (
        "Dragonite",
        ("Dragon", "Flying"),
        {"HP": 91, "Atk": 134, "Def": 95, "SpA": 100, "SpD": 100, "Spe": 80},
        "Multiscale",
    ),
    "Flutter Mane": (
        "Flutter Mane",
        ("Ghost", "Fairy"),
        {"HP": 55, "Atk": 55, "Def": 55, "SpA": 135, "SpD": 135, "Spe": 135},
        "Protosynthesis",
    ),
    "Kingambit": (
        "Kingambit",
        ("Dark", "Steel"),
        {"HP": 100, "Atk": 135, "Def": 120, "SpA": 60, "SpD": 85, "Spe": 50},
        None,
    ),
    "Urshifu-Rapid-Strike": (
        "Urshifu-Rapid-Strike",
        ("Fighting", "Water"),
        {"HP": 100, "Atk": 130, "Def": 100, "SpA": 63, "SpD": 60, "Spe": 97},
        None,
    ),
    "Urshifu": (
        "Urshifu",
        ("Fighting", "Dark"),
        {"HP": 100, "Atk": 130, "Def": 100, "SpA": 63, "SpD": 60, "Spe": 97},
        None,
    ),
    "Volcarona": (
        "Volcarona",
        ("Bug", "Fire"),
        {"HP": 85, "Atk": 60, "Def": 65, "SpA": 135, "SpD": 105, "Spe": 100},
        None,
    ),
    "Iron Bundle": (
        "Iron Bundle",
        ("Ice", "Water"),
        {"HP": 56, "Atk": 80, "Def": 114, "SpA": 124, "SpD": 60, "Spe": 136},
        None,
    ),
    "Roaring Moon": (
        "Roaring Moon",
        ("Dragon", "Dark"),
        {"HP": 105, "Atk": 139, "Def": 71, "SpA": 55, "SpD": 101, "Spe": 119},
        "Protosynthesis",
    ),
    "Raging Bolt": (
        "Raging Bolt",
        ("Electric", "Dragon"),
        {"HP": 125, "Atk": 73, "Def": 91, "SpA": 137, "SpD": 89, "Spe": 75},
        "Protosynthesis",
    ),
    "Walking Wake": (
        "Walking Wake",
        ("Water", "Dragon"),
        {"HP": 99, "Atk": 83, "Def": 91, "SpA": 125, "SpD": 83, "Spe": 109},
        "Protosynthesis",
    ),
    "Garchomp": (
        "Garchomp",
        ("Dragon", "Ground"),
        {"HP": 108, "Atk": 130, "Def": 95, "SpA": 80, "SpD": 85, "Spe": 102},
        None,
    ),
    "Haxorus": (
        "Haxorus",
        ("Dragon", None),
        {"HP": 76, "Atk": 147, "Def": 90, "SpA": 60, "SpD": 70, "Spe": 97},
        None,
    ),
    "Great Tusk": (
        "Great Tusk",
        ("Ground", "Fighting"),
        {"HP": 115, "Atk": 131, "Def": 131, "SpA": 53, "SpD": 53, "Spe": 87},
        None,
    ),
    "Iron Hands": (
        "Iron Hands",
        ("Fighting", "Electric"),
        {"HP": 154, "Atk": 140, "Def": 108, "SpA": 50, "SpD": 68, "Spe": 50},
        None,
    ),
    "Zapdos": (
        "Zapdos",
        ("Electric", "Flying"),
        {"HP": 90, "Atk": 90, "Def": 85, "SpA": 125, "SpD": 90, "Spe": 100},
        None,
    ),
    "Primarina": (
        "Primarina",
        ("Water", "Fairy"),
        {"HP": 80, "Atk": 74, "Def": 74, "SpA": 126, "SpD": 116, "Spe": 60},
        None,
    ),
    "Pecharunt": (
        "Pecharunt",
        ("Poison", "Ghost"),
        {"HP": 88, "Atk": 88, "Def": 160, "SpA": 88, "SpD": 88, "Spe": 88},
        None,
    ),
    "Spectrier": (
        "Spectrier",
        ("Ghost", None),
        {"HP": 100, "Atk": 65, "Def": 60, "SpA": 145, "SpD": 80, "Spe": 130},
        None,
    ),
    "Ursaluna": (
        "Ursaluna",
        ("Normal", "Ground"),
        {"HP": 130, "Atk": 140, "Def": 105, "SpA": 45, "SpD": 80, "Spe": 50},
        None,
    ),
    "Ursaluna-Bloodmoon": (
        "Ursaluna-Bloodmoon",
        ("Normal", "Ground"),
        {"HP": 113, "Atk": 70, "Def": 120, "SpA": 135, "SpD": 80, "Spe": 52},
        None,
    ),
    "Corviknight": (
        "Corviknight",
        ("Flying", "Steel"),
        {"HP": 98, "Atk": 87, "Def": 105, "SpA": 53, "SpD": 85, "Spe": 67},
        None,
    ),
    "Dragapult": (
        "Dragapult",
        ("Dragon", "Ghost"),
        {"HP": 88, "Atk": 120, "Def": 75, "SpA": 100, "SpD": 75, "Spe": 142},
        None,
    ),
    "Goodra-Hisui": (
        "Goodra-Hisui",
        ("Steel", "Dragon"),
        {"HP": 80, "Atk": 100, "Def": 100, "SpA": 110, "SpD": 150, "Spe": 60},
        None,
    ),
    "Landorus-Therian": (
        "Landorus-Therian",
        ("Ground", "Flying"),
        {"HP": 89, "Atk": 145, "Def": 90, "SpA": 105, "SpD": 80, "Spe": 91},
        "Intimidate",
    ),
    "Ninetales-Alola": (
        "Ninetales-Alola",
        ("Ice", "Fairy"),
        {"HP": 73, "Atk": 67, "Def": 75, "SpA": 81, "SpD": 100, "Spe": 109},
        None,
    ),
    "Ogerpon-Wellspring": (
        "Ogerpon-Wellspring",
        ("Water", "Grass"),
        {"HP": 80, "Atk": 120, "Def": 84, "SpA": 60, "SpD": 96, "Spe": 110},
        None,
    ),
    "Sylveon": (
        "Sylveon",
        ("Fairy", None),
        {"HP": 95, "Atk": 65, "Def": 65, "SpA": 110, "SpD": 130, "Spe": 60},
        None,
    ),
    "Volcanion": (
        "Volcanion",
        ("Fire", "Water"),
        {"HP": 80, "Atk": 110, "Def": 120, "SpA": 130, "SpD": 90, "Spe": 70},
        None,
    ),
    "Manaphy": (
        "Manaphy",
        ("Water", None),
        {"HP": 100, "Atk": 100, "Def": 100, "SpA": 100, "SpD": 100, "Spe": 100},
        None,
    ),
    "Moltres-Galar": (
        "Moltres-Galar",
        ("Dark", "Flying"),
        {"HP": 90, "Atk": 85, "Def": 90, "SpA": 100, "SpD": 125, "Spe": 90},
        None,
    ),
    "Scizor": (
        "Scizor",
        ("Bug", "Steel"),
        {"HP": 70, "Atk": 130, "Def": 100, "SpA": 55, "SpD": 80, "Spe": 65},
        None,
    ),
    "Skeledirge": (
        "Skeledirge",
        ("Fire", "Ghost"),
        {"HP": 104, "Atk": 75, "Def": 100, "SpA": 110, "SpD": 75, "Spe": 66},
        "Unaware",
    ),
    "Sneasler": (
        "Sneasler",
        ("Fighting", "Poison"),
        {"HP": 80, "Atk": 130, "Def": 60, "SpA": 40, "SpD": 80, "Spe": 120},
        None,
    ),
    "Dondozo": (
        "Dondozo",
        ("Water", None),
        {"HP": 150, "Atk": 100, "Def": 115, "SpA": 65, "SpD": 65, "Spe": 35},
        "Unaware",
    ),
    "Porygon-Z": (
        "Porygon-Z",
        ("Normal", None),
        {"HP": 85, "Atk": 80, "Def": 70, "SpA": 135, "SpD": 75, "Spe": 90},
        None,
    ),
    "Kyurem": (
        "Kyurem",
        ("Dragon", "Ice"),
        {"HP": 125, "Atk": 130, "Def": 90, "SpA": 130, "SpD": 90, "Spe": 95},
        None,
    ),
    "Azumarill": (
        "Azumarill",
        ("Water", "Fairy"),
        {"HP": 100, "Atk": 50, "Def": 80, "SpA": 60, "SpD": 80, "Spe": 50},
        None,
    ),
    "Garganacl": (
        "Garganacl",
        ("Rock", None),
        {"HP": 100, "Atk": 100, "Def": 130, "SpA": 45, "SpD": 90, "Spe": 35},
        None,
    ),
    "Gholdengo": (
        "Gholdengo",
        ("Steel", "Ghost"),
        {"HP": 87, "Atk": 60, "Def": 95, "SpA": 133, "SpD": 91, "Spe": 84},
        None,
    ),
    "Iron Crown": (
        "Iron Crown",
        ("Steel", "Psychic"),
        {"HP": 90, "Atk": 72, "Def": 100, "SpA": 122, "SpD": 108, "Spe": 98},
        "Quark Drive",
    ),
    "Iron Valiant": (
        "Iron Valiant",
        ("Fairy", "Fighting"),
        {"HP": 74, "Atk": 130, "Def": 90, "SpA": 120, "SpD": 60, "Spe": 116},
        "Quark Drive",
    ),
    "Annihilape": (
        "Annihilape",
        ("Fighting", "Ghost"),
        {"HP": 110, "Atk": 115, "Def": 80, "SpA": 50, "SpD": 90, "Spe": 90},
        None,
    ),
    "Chien-Pao": (
        "Chien-Pao",
        ("Dark", "Ice"),
        {"HP": 80, "Atk": 120, "Def": 80, "SpA": 90, "SpD": 65, "Spe": 135},
        None,
    ),
    "Cresselia": (
        "Cresselia",
        ("Psychic", None),
        {"HP": 120, "Atk": 70, "Def": 120, "SpA": 75, "SpD": 130, "Spe": 85},
        None,
    ),
    "Meowscarada": (
        "Meowscarada",
        ("Grass", "Dark"),
        {"HP": 76, "Atk": 110, "Def": 70, "SpA": 81, "SpD": 70, "Spe": 123},
        None,
    ),
}
SPECIES_DATA = {k: Species(*v) for k, v in SPECIES_DATA.items()}

# Optional aliases
ALIASES: Dict[str, str] = {
    "Hisuian Goodra": "Goodra-Hisui",
    "Galarian Moltres": "Moltres-Galar",
    "Bloodmoon Ursaluna": "Ursaluna-Bloodmoon",
    "Walking-Wake": "Walking Wake",
    "Great-Tusk": "Great Tusk",
    "Landorus-T": "Landorus-Therian",
    "Ninetales-A": "Ninetales-Alola",
    "Ogerpon (Wellspring)": "Ogerpon-Wellspring",
    "PorygonZ": "Porygon-Z",
}

THREAT_LIST: List[str] = [
    "Roaring Moon",
    "Sylveon",
    "Volcanion",
    "Walking Wake",
    "Zapdos",
    "Annihilape",
    "Chien-Pao",
    "Cresselia",
    "Great Tusk",
    "Manaphy",
    "Moltres-Galar",
    "Scizor",
    "Skeledirge",
    "Sneasler",
    "Dondozo",
    "Porygon-Z",
    "Garchomp",
    "Haxorus",
    "Iron Hands",
    "Meowscarada",
    "Raging Bolt",
    "Urshifu",
    "Urshifu-Rapid-Strike",
    "Volcarona",
    "Dragonite",
    "Kingambit",
    "Flutter Mane",
    "Miraidon",
    "Koraidon",
    "Calyrex-Shadow",
    "Gholdengo",
    "Garganacl",
    "Iron Bundle",
    "Kyurem",
    "Ursaluna-Bloodmoon",
    "Azumarill",
    "Goodra-Hisui",
    "Landorus-Therian",
    "Ninetales-Alola",
    "Ogerpon-Wellspring",
    "Primarina",
    "Spectrier",
    "Ursaluna",
    "Iron Crown",
    "Iron Valiant",
    "Corviknight",
    "Dragapult",
    "Raging Bolt",  # (dup present here; dedup at runtime)
]

# Default per-threat variant weights (equal if unknown usage)
DEFAULT_VARIANT_WEIGHTS = []  # empty => equal weights


# =========================
#     BUILD / SET MODEL
# =========================
@dataclass
class SetBuild:
    species: str
    item: str
    ability: Optional[str]
    tera_type: Optional[str]
    nature: str
    evs: Dict[str, int]  # HP,Atk,Def,SpA,SpD,Spe
    ivs: Dict[str, int]  # default all 31
    moves: List[str]


@dataclass
class BattleState:
    hp: int
    max_hp: int
    stages: Dict[str, int]
    sash_intact: bool = True
    sturdy_intact: bool = True
    consumed_item: Dict[str, bool] = field(default_factory=dict)
    tera_used: bool = False
    tera_type: Optional[str] = None
    ability_active: Dict[str, Union[bool, dict]] = field(default_factory=dict)
    multiscale_on: bool = False
    locked_move: Optional[str] = None  # Choice lock
    turns_elapsed: int = 0  # full turns completed


def _print_version_banner_v5_wrap():
    print("== SV 1v1 Optimizer — CPU only ==")
    print("Version:", "5.0 (threat presets on)")
    print(
        "Note: Using curated 1v1-style threat sets where available; falling back otherwise."
    )




# =========================
#  MINI 1V1 SIMULATOR CORE
# =========================
def initial_state(build: SetBuild) -> BattleState:
    spec = SPECIES_DATA[build.species]
    st = calc_stats(spec, build.nature, build.evs, build.ivs)
    bs = BattleState(
        hp=st["HP"],
        max_hp=st["HP"],
        stages={"Atk": 0, "Def": 0, "SpA": 0, "SpD": 0, "Spe": 0},
    )
    bs.multiscale_on = spec.ability_hint == "Multiscale"
    bs.sturdy_intact = spec.ability_hint == "Sturdy"
    return bs


def apply_speed_boost_if_any(build: SetBuild, state: BattleState):
    if SPECIES_DATA[build.species].ability_hint == "Speed Boost":
        state.stages["Spe"] = min(6, state.stages["Spe"] + 1)


def pq_activation(
    build: SetBuild,
    weather: Dict[str, Optional[str]],
    terrain: Dict[str, Optional[str]],
    state: BattleState,
    stats: Dict[str, int],
    dry_run: bool = False,
) -> Dict[str, float]:
    """
    Activate Protosynthesis / Quark Drive if Sun/Electric Terrain or Booster Energy (one-time).
    Returns multipliers dict {"Atk":1.0|1.5, "SpA":..., "Spe":1.0|1.3}
    dry_run=True => do NOT consume Booster Energy; used for speed checks/orders.
    """
    ability = SPECIES_DATA[build.species].ability_hint
    if ability not in ["Protosynthesis", "Quark Drive"]:
        return {"Atk": 1.0, "SpA": 1.0, "Spe": 1.0}

    sun_ok = weather.get("state") == "Harsh Sunlight"
    et_ok = terrain.get("state") == "Electric Terrain"
    trigger = (ability == "Protosynthesis" and sun_ok) or (
        ability == "Quark Drive" and et_ok
    )

    # Booster Energy can trigger if not already used
    if (
        not trigger
        and build.item == "Booster Energy"
        and not state.consumed_item.get("Booster Energy", False)
    ):
        trigger = True
        if not dry_run:
            state.consumed_item["Booster Energy"] = True

    if not trigger:
        return {"Atk": 1.0, "SpA": 1.0, "Spe": 1.0}

    cand = {"Atk": stats["Atk"], "SpA": stats["SpA"], "Spe": stats["Spe"]}
    best = max(cand, key=cand.get)
    if best == "Spe":
        return {"Atk": 1.0, "SpA": 1.0, "Spe": 1.3}
    else:
        return {
            "Atk": 1.5 if best == "Atk" else 1.0,
            "SpA": 1.5 if best == "SpA" else 1.0,
            "Spe": 1.0,
        }


def compute_spe_for_order(
    build: SetBuild, state: BattleState, stats: Dict[str, int], weather, terrain
) -> float:
    a_mult = 1.0
    s_mult = 1.0
    spe_mult = 1.0
    a_mult, s_mult, spe_mult, _, _, _ = apply_choice(
        build.item, a_mult, s_mult, spe_mult
    )
    pq = pq_activation(build, weather, terrain, state, stats, dry_run=True)
    return stats["Spe"] * stage_mult(state.stages["Spe"], True) * spe_mult * pq["Spe"]


def try_sitrus(state: BattleState, build: SetBuild):
    if (
        build.item == "Sitrus Berry"
        and not state.consumed_item.get("Sitrus Berry", False)
        and state.hp > 0
        and state.hp * 2 <= state.max_hp
    ):
        heal = int(math.ceil(0.25 * state.max_hp))
        state.hp = min(state.max_hp, state.hp + heal)
        state.consumed_item["Sitrus Berry"] = True


def try_leftovers(state: BattleState, build: SetBuild):
    if build.item == "Leftovers" and state.hp > 0:
        heal = max(1, state.max_hp // 16)
        state.hp = min(state.max_hp, state.hp + heal)


def apply_recoil_move(attacker_state: BattleState, move: Move, damage_dealt: int):
    r = RECOIL_RATIO.get(move.name)
    if not r or damage_dealt <= 0:
        return
    recoil = max(1, int(math.floor(damage_dealt * r)))
    attacker_state.hp = max(0, attacker_state.hp - recoil)


def apply_recoil_life_orb(
    attacker_state: BattleState, build: SetBuild, damage_dealt: int
):
    if damage_dealt <= 0:
        return
    if build.item == "Life Orb" and attacker_state.hp > 0:
        recoil = max(1, attacker_state.max_hp // 10)
        attacker_state.hp = max(0, attacker_state.hp - recoil)


# ---- Core: apply a damaging move that HITS (no accuracy randomness here) ----
def perform_damage_hit_distribution(
    self_build: "SetBuild",
    opp_build: "SetBuild",
    self_state: "BattleState",
    opp_state: "BattleState",
    mv: "Move",
    tera: bool,
    ttype: str | None,
    weather,
    terrain,
    stats_self: dict[str, int],
    stats_opp: dict[str, int],
    opp_selected_move: "Move | None" = None,
) -> list[tuple[float, "BattleState", "BattleState"]]:
    """Returns a list of (prob, new_self_state, new_opp_state) conditioned on the move CONNECTING.
    Expands over the exact damage-roll distribution (and multi-hit if applicable).
    """

    # Sucker Punch failure against Status/Counter/MirrorCoat
    if mv.name == "Sucker Punch" and opp_selected_move is not None:
        if (
            opp_selected_move.category == "Status"
            or opp_selected_move.is_counter
            or opp_selected_move.is_mirror_coat
        ):
            sA = copy.deepcopy(self_state)
            sD = copy.deepcopy(opp_state)
            sD.ability_active["last_received"] = {"category": mv.category, "damage": 0}
            return [(1.0, sA, sD)]

    # Choice lock after first used damaging move
    if (
        self_build.item in ("Choice Band", "Choice Specs", "Choice Scarf")
        and self_state.locked_move is None
    ):
        self_state.locked_move = mv.name

    # Apply Tera BEFORE damage for both offense and defense this turn
    sA0 = copy.deepcopy(self_state)
    sD0 = copy.deepcopy(opp_state)
    if tera and ttype:
        sA0.tera_used = True
        sA0.tera_type = ttype

    # Determine used type and live category (Tera Blast handling)
    orig_types = effective_types_offense(self_build)
    used_type = mv.mtype
    if mv.is_tera_blast and (sA0.tera_used) and ttype:
        used_type = ttype
        used_cat = "Physical" if stats_self["Atk"] >= stats_self["SpA"] else "Special"
    else:
        used_cat = mv.category

    atk_stat, def_stat = category_stat_names(used_cat)
    if mv.name == "Psyshock":
        def_stat = "Def"

    # Choice multipliers
    a_mult, s_mult, spe_mult, _, _, _ = apply_choice(self_build.item, 1.0, 1.0, 1.0)

    # Engine passives
    if SPECIES_DATA[self_build.species].ability_hint == "Hadron Engine":
        s_mult *= 1.3
    if SPECIES_DATA[self_build.species].ability_hint == "Orichalcum Pulse":
        a_mult *= 1.3
    pq = pq_activation(self_build, weather, terrain, sA0, stats_self, dry_run=False)

    # Crit stage behavior (your existing rule: only always-crit moves are crits)
    crit = is_crit(mv)
    a_stage = sA0.stages[atk_stat]
    d_stage = sD0.stages[def_stat]
    if crit:
        a_stage = max(0, a_stage)
        d_stage = min(0, d_stage)

    # Unaware handling
    if SPECIES_DATA[opp_build.species].ability_hint == "Unaware" and a_stage > 0:
        a_stage = 0
    if SPECIES_DATA[self_build.species].ability_hint == "Unaware" and d_stage > 0:
        d_stage = 0

    # Attacking and defending stats
    if atk_stat == "Atk":
        atk_val = int(stats_self["Atk"] * stage_mult(a_stage) * a_mult * pq["Atk"])
    else:
        atk_val = int(stats_self["SpA"] * stage_mult(a_stage) * s_mult * pq["SpA"])

    def_base = stats_opp[def_stat] * stage_mult(d_stage)
    if def_stat == "SpD" and opp_build.item == "Assault Vest":
        def_base *= 1.5
    def_val = int(def_base)

    # STAB and field
    offensive_stab = tera_stab_mult(
        used_type, orig_types, sA0.tera_type if sA0.tera_used else None
    )
    item_m = move_item_mult(self_build.item, mv, atk_stat)
    field_m = field_power_mult(used_type, self_build, sA0, weather, terrain)
    atk_ability_mult, stab_adj = ability_offense_mult(self_build, sA0, mv, stats_self, offensive_stab)
    offensive_stab *= stab_adj
    def_ability_mult = ability_defense_mult(opp_build, mv)
    opp_types_now = effective_types_defense(opp_build, sD0)

    # Multi-hit handling via independent roll branching
    total_branches: list[tuple[float, "BattleState", "BattleState"]] = [(1.0, sA0, sD0)]

    hits = mv.multi_hits if mv.multi_hits > 1 else 1
    for _h in range(hits):
        step_out: list[tuple[float, "BattleState", "BattleState"]] = []
        for prob_so_far, SA_in, SD_in in total_branches:
            if SD_in.hp <= 0 or SA_in.hp <= 0:
                step_out.append((prob_so_far, SA_in, SD_in))
                continue

            # Multiscale applies on the *first* hit that connects in a turn for Dragonite
            ms_flag = SD_in.multiscale_on

            # Per-roll expansion
            tmult = type_mult(used_type, opp_types_now) * def_ability_mult
            for roll_mult in ROLL_TABLE:
                d = damage(
                    100,
                    base_power(mv),
                    max(1, int(atk_val * atk_ability_mult)),
                    def_val,
                    offensive_stab,
                    tmult,
                    item_m,
                    False,
                    ms_flag,
                    field_m,
                    crit,
                    roll_mult,
                )

                SA = copy.deepcopy(SA_in)
                SD = copy.deepcopy(SD_in)

                # Focus Sash / Sturdy timing *per hit*
                if (
                    opp_build.item == "Focus Sash"
                    and SD.sash_intact
                    and SD.hp == SD.max_hp
                    and d >= SD.hp
                ):
                    SD.hp = 1
                    SD.sash_intact = False
                    dealt = 1
                elif (
                    SPECIES_DATA[opp_build.species].ability_hint == "Sturdy"
                    and SD.sturdy_intact
                    and SD.hp == SD.max_hp
                    and d >= SD.hp
                ):
                    SD.hp = 1
                    SD.sturdy_intact = False
                    dealt = 1
                else:
                    SD.hp = max(0, SD.hp - d)
                    dealt = d

                # After first successful connection, Multiscale turns off
                ms_flag = False
                SD.multiscale_on = False

                # Sitrus timing for defender
                try_sitrus(SD, opp_build)

                # Early stop if defender fainted
                if SD.hp <= 0:
                    # Recoil (Wave Crash/Flare Blitz/etc.) & LO after final damage
                    apply_recoil_move(SA, mv, dealt)
                    if (
                        dealt > 0
                        and is_contact_effective(mv, self_build.item)
                        and opp_build.item == "Rocky Helmet"
                        and SA.hp > 0
                    ):
                        rh = max(1, SA.max_hp // 6)
                        SA.hp = max(0, SA.hp - rh)
                    apply_recoil_life_orb(SA, self_build, dealt)
                    try_sitrus(SA, self_build)

                    SA.ability_active["last_received"] = SA.ability_active.get("last_received", None)
                    SD.ability_active["last_received"] = {"category": used_cat, "damage": dealt}
                    step_out.append((prob_so_far * ROLL_PROB, SA, SD))
                    continue

                # Weakness Policy (triggered if first SE hit dealt damage this turn)
                tm_first = type_mult(used_type, effective_types_defense(opp_build, SD))
                if (
                    dealt > 0
                    and tm_first > 1.0
                    and opp_build.item == "Weakness Policy"
                    and not SD.consumed_item.get("Weakness Policy", False)
                ):
                    SD.consumed_item["Weakness Policy"] = True
                    SD.stages["Atk"] = min(6, SD.stages["Atk"] + 2)
                    SD.stages["SpA"] = min(6, SD.stages["SpA"] + 2)

                # Record last received for Counter/Mirror Coat
                SD.ability_active["last_received"] = {"category": used_cat, "damage": dealt}

                # Recoil & chip on attacker
                apply_recoil_move(SA, mv, dealt)
                if (
                    dealt > 0
                    and is_contact_effective(mv, self_build.item)
                    and opp_build.item == "Rocky Helmet"
                    and SA.hp > 0
                ):
                    rh = max(1, SA.max_hp // 6)
                    SA.hp = max(0, SA.hp - rh)
                apply_recoil_life_orb(SA, self_build, dealt)
                try_sitrus(SA, self_build)

                # User-side stage drops after connection
                if dealt > 0:
                    apply_stat_side_effects_after(SA, mv)

                step_out.append((prob_so_far * ROLL_PROB, SA, SD))
        # Merge equivalent states after this hit
        total_branches = _merge_branch_states(step_out)

        # If all branches already KO'd the defender, no need to continue remaining hits
        if all(SD.hp <= 0 for _, _, SD in total_branches):
            break

    return total_branches


def do_status_action(mv: Move, self_state: BattleState):
    if mv.is_protect:
        self_state.ability_active["Protect"] = True
        return
    if mv.is_swords_dance:
        self_state.stages["Atk"] = min(6, self_state.stages["Atk"] + 2)
        return


def apply_counter_like(
    mv: Move, self_state: BattleState, opp_state: BattleState, opp_build: SetBuild
):
    # Blocked by Protect
    if opp_state.ability_active.get("Protect", False):
        return
    last = self_state.ability_active.get("last_received", None)
    if last and isinstance(last, dict):
        if mv.is_counter and last.get("category") == "Physical":
            dmg = int(last.get("damage", 0)) * 2
        elif mv.is_mirror_coat and last.get("category") == "Special":
            dmg = int(last.get("damage", 0)) * 2
        else:
            return
        # Sash timing
        if (
            opp_build.item == "Focus Sash"
            and opp_state.sash_intact
            and opp_state.hp == opp_state.max_hp
            and dmg >= opp_state.hp
        ):
            opp_state.hp = 1
            opp_state.sash_intact = False
        else:
            opp_state.hp = max(0, opp_state.hp - dmg)
        opp_state.multiscale_on = False
        try_sitrus(opp_state, opp_build)


def action_list_for(build: SetBuild, state: BattleState) -> List[Tuple[str, bool]]:
    # Respect Choice lock: only that move remains
    moves = build.moves if state.locked_move is None else [state.locked_move]
    acts = []
    can_tera = (not state.tera_used) and bool(build.tera_type)
    for name in moves:
        # Disallow status/counter/coat after Choice lock (locked move must be the damaging move)
        if state.locked_move is not None:
            mv = MOVE_DB[state.locked_move]
            if mv.category == "Status" or mv.is_counter or mv.is_mirror_coat:
                continue
        # First-turn-only check is handled later (we still list; enforce at selection)
        acts.append((name, False))
        if can_tera:
            acts.append((name, True))
    return acts


def speed_order(tupleA, tupleB, weather, terrain):
    buildA, stateA, statsA = tupleA
    buildB, stateB, statsB = tupleB
    speA = compute_spe_for_order(buildA, stateA, statsA, weather, terrain)
    speB = compute_spe_for_order(buildB, stateB, statsB, weather, terrain)
    if speA > speB:
        return ("A", "B")
    if speB > speA:
        return ("B", "A")
    return ("TIE", "TIE")  # resolve by branching both orders


def apply_start_of_battle_hooks(
    buildA: SetBuild, A: BattleState, buildB: SetBuild, B: BattleState
):
    # Intimidate
    if SPECIES_DATA[buildA.species].ability_hint == "Intimidate":
        B.stages["Atk"] = max(-6, B.stages["Atk"] - 1)
    if SPECIES_DATA[buildB.species].ability_hint == "Intimidate":
        A.stages["Atk"] = max(-6, A.stages["Atk"] - 1)


# ------- CHANCE BRANCH HELPERS -------
# Return list of (prob, outcome_val_or_None, newA, newB)
ChanceBranch = Tuple[float, Optional[float], BattleState, BattleState]


def branch_on_move(
    build_att: "SetBuild",
    state_att: "BattleState",
    stats_att: dict[str, int],
    build_def: "SetBuild",
    state_def: "BattleState",
    stats_def: dict[str, int],
    weather,
    terrain,
    mv: "Move",
    tera: bool,
    ttype: str | None,
    opp_selected_move: "Move | None",
) -> list[tuple[float, "BattleState", "BattleState"]]:
    """
    Return list of (probability, new_att_state, new_def_state) after ATTACKER acts.
    Now expands: hit/miss accuracy and per-roll damage distributions.
    """
    out: list[tuple[float, "BattleState", "BattleState"]] = []

    # First-turn-only moves (e.g., First Impression)
    if mv.first_turn_only and (state_att.turns_elapsed > 0):
        sA = copy.deepcopy(state_att)
        sD = copy.deepcopy(state_def)
        if tera and ttype:
            sA.tera_used = True
            sA.tera_type = ttype
        sD.ability_active["last_received"] = {"category": mv.category, "damage": 0}
        out.append((1.0, sA, sD))
        return out

    # Status moves (no damage RNG)
    if mv.category == "Status":
        sA = copy.deepcopy(state_att)
        sD = copy.deepcopy(state_def)
        if tera and ttype:
            sA.tera_used = True
            sA.tera_type = ttype
        do_status_action(mv, sA)
        out.append((1.0, sA, sD))
        return out

    # Counter / Mirror Coat (no damage RNG; uses stored damage)
    if mv.is_counter or mv.is_mirror_coat:
        sA = copy.deepcopy(state_att)
        sD = copy.deepcopy(state_def)
        if tera and ttype:
            sA.tera_used = True
            sA.tera_type = ttype
        apply_counter_like(mv, sA, sD, build_def)
        out.append((1.0, sA, sD))
        return out

    # Protect blocks damage entirely
    if state_def.ability_active.get("Protect", False):
        sA = copy.deepcopy(state_att)
        sD = copy.deepcopy(state_def)
        if tera and ttype:
            sA.tera_used = True
            sA.tera_type = ttype
        sD.ability_active["last_received"] = {"category": mv.category, "damage": 0}
        out.append((1.0, sA, sD))
        return out

    # Accuracy RNG split
    acc = max(0.0, min(1.0, mv.accuracy))
    miss_p = 1.0 - acc
    if miss_p > 0:
        sA_m = copy.deepcopy(state_att)
        sD_m = copy.deepcopy(state_def)
        if tera and ttype:
            sA_m.tera_used = True
            sA_m.tera_type = ttype
        sD_m.ability_active["last_received"] = {"category": mv.category, "damage": 0}
        if mv.name == "High Jump Kick":
            crash = max(1, sA_m.max_hp // 2)
            sA_m.hp = max(0, sA_m.hp - crash)
            try_sitrus(sA_m, build_att)
        out.append((miss_p, sA_m, sD_m))

    if acc > 0:
        hit_branches = perform_damage_hit_distribution(
            build_att,
            build_def,
            state_att,
            state_def,
            mv,
            tera,
            ttype,
            weather,
            terrain,
            stats_att,
            stats_def,
            opp_selected_move,
        )
        for p2, SA2, SD2 in hit_branches:
            out.append((acc * p2, SA2, SD2))

    return _merge_branch_states(out)


def step_resolution(
    buildA: SetBuild,
    stateA: BattleState,
    statsA: Dict[str, int],
    buildB: SetBuild,
    stateB: BattleState,
    statsB: Dict[str, int],
    weather,
    terrain,
    actA: Tuple[str, bool],
    actB: Tuple[str, bool],
) -> List[ChanceBranch]:
    """
    Execute both chosen actions for one turn (order by priority then speed).
    Return list of stochastic branches: (prob, terminal_value_or_None, newA, newB).
    """
    mvA = MOVE_DB[actA[0]]
    teraA = actA[1]
    ttA = buildA.tera_type if teraA else None
    mvB = MOVE_DB[actB[0]]
    teraB = actB[1]
    ttB = buildB.tera_type if teraB else None

    def clear_turn_flags(S: BattleState):
        S.ability_active.pop("Protect", None)
        S.ability_active["last_received"] = None

    def ordered(first: str) -> List[ChanceBranch]:
        A = copy.deepcopy(stateA)
        B = copy.deepcopy(stateB)
        clear_turn_flags(A)
        clear_turn_flags(B)

        # FIRST acts
        if first == "A":
            branches_first = branch_on_move(
                buildA,
                A,
                statsA,
                buildB,
                B,
                statsB,
                weather,
                terrain,
                mvA,
                teraA,
                ttA,
                mvB,
            )
        else:
            branches_first = branch_on_move(
                buildB,
                B,
                statsB,
                buildA,
                A,
                statsA,
                weather,
                terrain,
                mvB,
                teraB,
                ttB,
                mvA,
            )

        out_branches: List[ChanceBranch] = []
        for p1, SA1, SB1 in branches_first:
            # Terminal after first action?
            if SA1.hp <= 0 and SB1.hp <= 0:
                out_branches.append((p1, 0.5, SA1, SB1))
                continue
            if SB1.hp <= 0:
                out_branches.append((p1, 1.0 if first == "A" else 0.0, SA1, SB1))
                continue
            if SA1.hp <= 0:
                out_branches.append((p1, 0.0 if first == "A" else 1.0, SA1, SB1))
                continue

            # SECOND acts if alive
            if first == "A":
                branches_second = branch_on_move(
                    buildB,
                    SB1,
                    statsB,
                    buildA,
                    SA1,
                    statsA,
                    weather,
                    terrain,
                    mvB,
                    teraB,
                    ttB,
                    mvA,
                )
                for p2, SB2, SA2 in branches_second:
                    apply_speed_boost_if_any(buildA, SA2)
                    apply_speed_boost_if_any(buildB, SB2)
                    try_sitrus(SA2, buildA)
                    try_sitrus(SB2, buildB)
                    try_leftovers(SA2, buildA)
                    try_leftovers(SB2, buildB)
                    out_branches.append((p1 * p2, None, SA2, SB2))
            else:
                branches_second = branch_on_move(
                    buildA,
                    SA1,
                    statsA,
                    buildB,
                    SB1,
                    statsB,
                    weather,
                    terrain,
                    mvA,
                    teraA,
                    ttA,
                    mvB,
                )
                for p2, SA2, SB2 in branches_second:
                    apply_speed_boost_if_any(buildA, SA2)
                    apply_speed_boost_if_any(buildB, SB2)
                    try_sitrus(SA2, buildA)
                    try_sitrus(SB2, buildB)
                    try_leftovers(SA2, buildA)
                    try_leftovers(SB2, buildB)
                    out_branches.append((p1 * p2, None, SA2, SB2))
        return out_branches

    if mvA.priority > mvB.priority:
        return ordered("A")
    elif mvB.priority > mvA.priority:
        return ordered("B")
    else:
        o = speed_order(
            (buildA, stateA, statsA), (buildB, stateB, statsB), weather, terrain
        )
        if o[0] == "TIE":
            a = ordered("A")
            b = ordered("B")
            return [(0.5 * p, val, sA, sB) for (p, val, sA, sB) in a] + [
                (0.5 * p, val, sA, sB) for (p, val, sA, sB) in b
            ]
        else:
            return ordered(o[0])


# ---------- Minimax (simultaneous choices + chance nodes) ----------
def state_key(
    buildA: SetBuild, A: BattleState, buildB: SetBuild, B: BattleState, depth: int
) -> Tuple:
    def cflags(st: BattleState) -> Tuple:
        return (
            st.hp,
            st.max_hp,
            st.stages["Atk"],
            st.stages["Def"],
            st.stages["SpA"],
            st.stages["SpD"],
            st.stages["Spe"],
            st.sash_intact,
            st.sturdy_intact,
            st.multiscale_on,
            st.tera_used,
            st.tera_type or "",
            st.locked_move or "",
            st.consumed_item.get("Booster Energy", False),
            st.consumed_item.get("Sitrus Berry", False),
            st.consumed_item.get("Weakness Policy", False),
            st.turns_elapsed,
        )

    def ev_tuple(ev: Dict[str, int]) -> Tuple[int, int, int, int, int, int]:
        return (ev["HP"], ev["Atk"], ev["Def"], ev["SpA"], ev["SpD"], ev["Spe"])

    def iv_tuple(iv: Dict[str, int]) -> Tuple[int, int, int, int, int, int]:
        return (iv["HP"], iv["Atk"], iv["Def"], iv["SpA"], iv["SpD"], iv["Spe"])

    return (
        buildA.species,
        buildA.item,
        buildA.tera_type or "",
        buildA.nature,
        ev_tuple(buildA.evs),
        iv_tuple(buildA.ivs),
        cflags(A),
        buildB.species,
        buildB.item,
        buildB.tera_type or "",
        buildB.nature,
        ev_tuple(buildB.evs),
        iv_tuple(buildB.ivs),
        cflags(B),
        depth,
    )


_minimax_cache: Dict[Tuple, float] = {}


def sudden_death_value(A: BattleState, B: BattleState) -> float:
    a = 0.0 if A.max_hp <= 0 else A.hp / A.max_hp
    b = 0.0 if B.max_hp <= 0 else B.hp / B.max_hp
    if abs(a - b) < 1e-9:
        return 0.5
    return 1.0 if a > b else 0.0


def minimax(
    buildA: SetBuild,
    A: BattleState,
    statsA: Dict[str, int],
    buildB: SetBuild,
    B: BattleState,
    statsB: Dict[str, int],
    weather,
    terrain,
    depth: int,
    alpha: float,
    beta: float,
) -> float:
    # Terminal KOs
    if A.hp <= 0 and B.hp <= 0:
        return 0.5
    if B.hp <= 0:
        return 1.0
    if A.hp <= 0:
        return 0.0

    # Depth==0 => sudden death by %HP
    if depth == 0:
        return sudden_death_value(A, B)

    key = state_key(buildA, A, buildB, B, depth)
    if key in _minimax_cache:
        return _minimax_cache[key]

    actsA = action_list_for(buildA, A)
    actsB = action_list_for(buildB, B)

    best_val = -1e9
    for actA in actsA:
        worst_val = 1e9
        local_beta = beta
        for actB in actsB:
            branches = step_resolution(
                buildA, A, statsA, buildB, B, statsB, weather, terrain, actA, actB
            )
            ev = 0.0
            for p, val, nA, nB in branches:
                nA2 = copy.deepcopy(nA)
                nB2 = copy.deepcopy(nB)
                nA2.turns_elapsed = A.turns_elapsed + 1
                nB2.turns_elapsed = B.turns_elapsed + 1

                if val is None:
                    ev += p * minimax(
                        buildA,
                        nA2,
                        statsA,
                        buildB,
                        nB2,
                        statsB,
                        weather,
                        terrain,
                        depth - 1,
                        alpha,
                        local_beta,
                    )
                else:
                    ev += p * val
            if ev < worst_val:
                worst_val = ev
            if worst_val <= alpha:
                break  # prune B
            if worst_val < local_beta:
                local_beta = worst_val
        if worst_val > best_val:
            best_val = worst_val
        if best_val >= beta:
            break  # prune A
        if best_val > alpha:
            alpha = best_val

    _minimax_cache[key] = best_val
    return best_val


def simulate(buildA: SetBuild, buildB: SetBuild, verbose: bool = False) -> float:
    """
    Optimal-play simulator (minimax + chance nodes), SEARCH_TURNS horizon (3).
    Returns P(win) in [0,1].
    """
    # Precompute stats
    specA = SPECIES_DATA[buildA.species]
    specB = SPECIES_DATA[buildB.species]
    statsA = calc_stats(specA, buildA.nature, buildA.evs, buildA.ivs)
    statsB = calc_stats(specB, buildB.nature, buildB.evs, buildB.ivs)

    # Initial states
    A0 = initial_state(buildA)
    B0 = initial_state(buildB)

    # Environment and ability context
    weather = {"state": None}
    terrain = {"state": None}
    atk_mult = {"A": 1.0, "B": 1.0}
    spa_mult = {"A": 1.0, "B": 1.0}
    ability_context(specA.ability_hint or "", "A", weather, terrain, atk_mult, spa_mult)
    ability_context(specB.ability_hint or "", "B", weather, terrain, atk_mult, spa_mult)

    # Start-of-battle hooks (e.g., Intimidate)
    apply_start_of_battle_hooks(buildA, A0, buildB, B0)

    # Reset cache per match
    _minimax_cache.clear()

    pwin = minimax(
        buildA,
        A0,
        statsA,
        buildB,
        B0,
        statsB,
        weather,
        terrain,
        SEARCH_TURNS,
        ALPHA_INIT,
        BETA_INIT,
    )
    return max(0.0, min(1.0, pwin))


# =========================
#     OBJECTIVE / SEARCH
# =========================
def valid_evs(ev: Dict[str, int]) -> bool:
    if any(v % 4 != 0 for v in ev.values()):
        return False
    if any(v > 252 for v in ev.values()):
        return False
    return sum(ev.values()) <= EV_TOTAL_MAX


def _stab_types_for(species: str) -> set[str]:
    t1, t2 = SPECIES_DATA[species].types
    return {t for t in (t1, t2) if t}


def _move_is_status(name: str) -> bool:
    mv = MOVE_DB[name]
    return mv.category == "Status" or mv.is_counter or mv.is_mirror_coat


def _coverage_proxy(species: str, moves: list[str]) -> tuple:
    """Cheap, order-invariant signature for Pareto pruning."""

    stab_types = _stab_types_for(species)
    type_best_bp: defaultdict[str, int] = defaultdict(int)
    has_stab = False
    has_priority = False

    for mname in moves:
        mv = MOVE_DB[mname]
        if mv.category == "Status":
            continue
        bp = base_power(mv)
        type_best_bp[mv.mtype] = max(type_best_bp[mv.mtype], bp)
        if mv.mtype in stab_types:
            has_stab = True
        if mv.priority > 0:
            has_priority = True

    vect = []
    for dtyp in TYPES:
        best = 0.0
        for atyp, bp in type_best_bp.items():
            best = max(
                best,
                bp * effectiveness[type_index[atyp]][type_index[dtyp]],
            )
        vect.append(int(best))
    return (tuple(vect), int(has_stab), int(has_priority))


def _dominates(sig_a: tuple, sig_b: tuple) -> bool:
    ge_all = (
        all(a >= b for a, b in zip(sig_a[0], sig_b[0]))
        and sig_a[1] >= sig_b[1]
        and sig_a[2] >= sig_b[2]
    )
    gt_any = (
        any(a > b for a, b in zip(sig_a[0], sig_b[0]))
        or sig_a[1] > sig_b[1]
        or sig_a[2] > sig_b[2]
    )
    return ge_all and gt_any


def movesets_from_pool(
    pool: List[str], four_physical_only: bool, species: str
) -> List[List[str]]:
    usable: list[str] = []
    for name in pool:
        mv = MOVE_DB[name]
        if four_physical_only and mv.category == "Special":
            continue
        usable.append(name)

    protect_like = {"Protect", "Detect"}
    setup_like = {"Swords Dance", "Bulk Up"}
    status_like = {
        "Protect",
        "Detect",
        "Swords Dance",
        "Bulk Up",
        "Encore",
        "Taunt",
        "Counter",
    }

    stab_types = _stab_types_for(species)
    candidates: list[list[str]] = []
    sigs: list[tuple] = []
    frontier_idx: list[int] = []

    def _sort_key(mname: str) -> tuple[int, int, int]:
        mv = MOVE_DB[mname]
        stab = 1 if (mv.category != "Status" and mv.mtype in stab_types) else 0
        return (stab, base_power(mv), 1 if mv.priority > 0 else 0)

    usable_sorted = sorted(usable, key=_sort_key, reverse=True)

    from itertools import combinations

    for a, b, c, d in combinations(usable_sorted, 4):
        subset = [a, b, c, d]
        if sum(1 for x in subset if x in protect_like) > 1:
            continue
        if sum(1 for x in subset if x in setup_like) > 1:
            continue
        if sum(1 for x in subset if x in status_like) > 1:
            continue
        if not any(
            MOVE_DB[x].category != "Status" and MOVE_DB[x].mtype in stab_types
            for x in subset
        ):
            continue

        sig = _coverage_proxy(species, subset)

        dominated = False
        remove: list[int] = []
        for idx in frontier_idx:
            if _dominates(sigs[idx], sig):
                dominated = True
                break
            if _dominates(sig, sigs[idx]):
                remove.append(idx)
        if dominated:
            continue
        if remove:
            frontier_idx = [idx for idx in frontier_idx if idx not in remove]
        sigs.append(sig)
        frontier_idx.append(len(sigs) - 1)
        candidates.append(subset)

    return candidates


def filter_moveset_by_item(item: str, moves: List[str]) -> bool:
    has_status = any(MOVE_DB[m].category == "Status" for m in moves)
    if item == "Assault Vest" and has_status:
        return False
    if item in ("Choice Band", "Choice Specs", "Choice Scarf") and has_status:
        return False
    if item in ("Choice Band", "Choice Specs", "Choice Scarf") and (
        "Counter" in moves or "Mirror Coat" in moves
    ):
        return False
    return True


# ---------- Local EV hill-climb refine ----------
EV_KEYS_ORDER = ("HP", "Atk", "Def", "SpA", "SpD", "Spe")


def clamp_evs(ev: Dict[str, int]) -> Dict[str, int]:
    ev = {k: max(0, min(252, (ev.get(k, 0) // 4) * 4)) for k in EV_KEYS_ORDER}
    total = sum(ev.values())
    if total > EV_TOTAL_MAX:
        overflow = total - EV_TOTAL_MAX
        for k in ("HP", "Atk", "Def", "SpA", "SpD", "Spe"):
            take = min(overflow, ev[k])
            take = (take // 4) * 4
            ev[k] -= take
            overflow -= take
            if overflow <= 0:
                break
    return ev


# Prebuild threat variants once (with weights)
def prebuild_threat_variants(
    threat_names: List[str],
) -> Dict[str, Tuple[List[SetBuild], List[float]]]:
    out = {}
    missing = []
    for t in threat_names:
        vw = adversary_variants(t)
        if not vw:
            missing.append(t)
        else:
            variants, weights = vw
            resolved = resolve_species_name(t)
            out[SPECIES_DATA[resolved].name] = (variants, weights)
    if missing:
        print("[warn] Missing threats (not in SPECIES_DATA):", sorted(set(missing)))
    return out


def weighted_mean(vals: List[float], weights: List[float]) -> float:
    if not vals:
        return 0.0
    if not weights or len(weights) != len(vals):
        return sum(vals) / len(vals)
    s = sum(weights)
    if s <= 0:
        return sum(vals) / len(vals)
    return sum(v * w for v, w in zip(vals, weights)) / s


def eval_candidate_single(
    candidate: SetBuild,
    threats_order: List[str],
    threats_variants: Dict[str, Tuple[List[SetBuild], List[float]]],
) -> Tuple[float, List[float], SetBuild]:
    wrs = []
    for name in threats_order:
        variants, weights = threats_variants[name]
        results = [simulate(candidate, opp) for opp in variants]
        wrs.append(weighted_mean(results, weights))
    score = sum(wrs) / len(wrs) if wrs else 0.0
    return score, wrs, candidate


def eval_candidate_trio(
    candidate: SetBuild,
    fixed_builds: Dict[str, SetBuild],
    threats_order: List[str],
    threats_variants: Dict[str, Tuple[List[SetBuild], List[float]]],
) -> Tuple[float, List[float], SetBuild]:
    trio = dict(fixed_builds)
    trio[candidate.species] = candidate
    wrs = []
    for name in threats_order:
        variants, weights = threats_variants[name]
        per_variant = []
        for opp in variants:
            ours = max(simulate(b, opp) for _, b in trio.items())
            per_variant.append(ours)
        wrs.append(weighted_mean(per_variant, weights))
    score = sum(wrs) / len(wrs) if wrs else 0.0
    return score, wrs, candidate


def build_search_for_species(
    species: str,
    threats: List[str],
    conditioned_on: Optional[Dict[str, SetBuild]] = None,
):
    threats_variants = prebuild_threat_variants(threats)
    if not threats_variants:
        return None, {}
    candidates = enumerate_candidates_for_species(species)
    if not candidates:
        return None, {}

    best = None
    per_wr = {}
    max_workers = max(1, (os.cpu_count() or 1))

    if conditioned_on is None:
        # Solo objective — shortlist in parallel
        with ProcessPoolExecutor(max_workers=max_workers) as ex:
            futures = [
                ex.submit(eval_candidate_single, c, threats, threats_variants)
                for c in candidates
            ]
            for fut in as_completed(futures):
                score, wrs, cand = fut.result()
                if (best is None) or (score > best[0]):
                    best = (score, wrs, cand)

        # Local refine — solo
        def solo_eval_fn(sb: SetBuild) -> float:
            wrs = []
            for name in threats:
                variants, weights = threats_variants[name]
                results = [simulate(sb, opp) for opp in variants]
                wrs.append(weighted_mean(results, weights))
            return sum(wrs) / len(wrs) if wrs else 0.0

        axes = (
            ("HP", "Atk", "Def", "Spe")
            if pick_offense_category(SPECIES_DATA[species]) == "Physical"
            else ("HP", "SpA", "SpD", "Spe")
        )
        refined = refine_evs_local(
            best[2], solo_eval_fn, axes, passes=LOCAL_REFINE_PASSES
        )
        if refined.evs != best[2].evs:
            wrs = []
            for name in threats:
                variants, weights = threats_variants[name]
                results = [simulate(refined, opp) for opp in variants]
                wrs.append(weighted_mean(results, weights))
            best = (sum(wrs) / len(wrs) if wrs else 0.0, wrs, refined)

    else:
        # Trio-conditioned objective (sequential)
        def trio_eval_fn(sb: SetBuild) -> float:
            trio = dict(conditioned_on)
            trio[species] = sb
            wrs = []
            for name in threats:
                variants, weights = threats_variants[name]
                per_variant = []
                for opp in variants:
                    ours = max(simulate(b, opp) for _, b in trio.items())
                    per_variant.append(ours)
                wrs.append(weighted_mean(per_variant, weights))
            return sum(wrs) / len(wrs) if wrs else 0.0

        for c in candidates:
            score, wrs, cand = eval_candidate_trio(
                c, conditioned_on, threats, threats_variants
            )
            if (best is None) or (score > best[0]):
                best = (score, wrs, cand)

        # Local refine — trio-conditioned
        axes = (
            ("HP", "Atk", "Def", "Spe")
            if pick_offense_category(SPECIES_DATA[species]) == "Physical"
            else ("HP", "SpA", "SpD", "Spe")
        )
        refined = refine_evs_local(
            best[2], trio_eval_fn, axes, passes=LOCAL_REFINE_PASSES
        )
        if refined.evs != best[2].evs:
            wrs = []
            trio_fixed = dict(conditioned_on)
            trio_fixed[species] = refined
            for name in threats:
                variants, weights = threats_variants[name]
                per_variant = []
                for opp in variants:
                    ours = max(simulate(b, opp) for _, b in trio_fixed.items())
                    per_variant.append(ours)
                wrs.append(weighted_mean(per_variant, weights))
            best = (sum(wrs) / len(wrs) if wrs else 0.0, wrs, refined)

    if best is None:
        return None, {}
    per_wr = {threats[i]: best[1][i] for i in range(len(threats))}
    return best[2], per_wr




def coordinate_descent_trio(order: List[str], threats: List[str], rounds: int = 2):
    # Initial independent bests
    bests = {}
    per_wr_all = {}
    resolvable = [t for t in threats if resolve_species_name(t)]
    for sp in order:
        print(f"\nSearching best build for {sp} (solo)...")
        b, wrs = build_search_for_species(sp, resolvable, conditioned_on=None)
        if b is None:
            raise RuntimeError(f"No candidate found for {sp}")
        bests[sp] = b
        per_wr_all[sp] = wrs
        print(
            f"[Best SOLO] {sp}: item={b.item}, tera={b.tera_type}, nature={b.nature}, EVs={b.evs}, moves={b.moves}"
        )

    # Coordinate updates
    for r in range(1, rounds + 1):
        print(f"\n== Coordinate descent round {r} ==")
        for sp in order:
            fixed = {k: v for k, v in bests.items() if k != sp}
            b, wrs = build_search_for_species(sp, resolvable, conditioned_on=fixed)
            if b is not None:
                bests[sp] = b
                per_wr_all[sp] = wrs
                print(
                    f"[Best TEAM] {sp}: item={b.item}, tera={b.tera_type}, nature={b.nature}, EVs={b.evs}, moves={b.moves}"
                )
    return bests, per_wr_all


def trio_objective(builds: Dict[str, SetBuild], threats: List[str]):
    agg = {}
    used = 0
    threats_variants = prebuild_threat_variants(threats)
    for name in threats:
        if name not in threats_variants:
            continue
        used += 1
        variants, weights = threats_variants[name]
        per_variant = []
        for opp in variants:
            ours = max(simulate(b, opp) for _, b in builds.items())
            per_variant.append(ours)
        agg[name] = weighted_mean(per_variant, weights)
    avg = (sum(agg.values()) / used) if used else 0.0
    return avg, agg, used


# =========================
#            MAIN
# =========================
def canonical_name(name: str) -> Optional[str]:
    key = resolve_species_name(name)
    return SPECIES_DATA[key].name if key else None


def main():
    start = time.time()
    if not globals().get("_svi_banner_override", False):
        print("== SV 1v1 Optimizer — CPU only ==")
        print("Version:", "3.0.1")
    print("Threats listed:", len(THREAT_LIST))

    # Dedup threats (avoid overweighting duplicates) and canonicalize names
    unique_threats = sorted(set(THREAT_LIST), key=lambda x: THREAT_LIST.index(x))
    canonical_threats = [cn for cn in (canonical_name(t) for t in unique_threats) if cn]
    missing = [t for t in unique_threats if not resolve_species_name(t)]
    print(f"Threats resolvable: {len(canonical_threats)}; missing: {len(missing)}")
    if missing:
        print("Missing threats will be skipped:", sorted(set(missing)))

    order = ["Swampert", "Blaziken", "Quaquaval"]
    print("\nSearch knobs:")
    print("  EV search: matchup-aware 4-EV lattice with Pareto pruning + local redistribution.")
    _mv_counts = {
        sp: len(movesets_from_pool(LEGAL_MOVES[sp], FOUR_PHYSICAL_ONLY[sp], sp))
        for sp in order
    }
    print(f"  Movesets per species: {_mv_counts}")
    print(f"  SEARCH_TURNS: {SEARCH_TURNS}, LOCAL_REFINE_PASSES: {LOCAL_REFINE_PASSES}")

    # Coordinate descent for trio
    bests, per_wr_all = coordinate_descent_trio(order, canonical_threats, rounds=2)

    avg, agg, used = trio_objective(bests, canonical_threats)

    print("\n================== RESULT (CANDIDATE) ==================")
    for sp in order:
        b = bests[sp]
        print(f"\n!requestSV {sp} @ {b.item}")
        print(f"Ability: {b.ability or SPECIES_DATA[sp].ability_hint or '—'}")
        print(f"Tera Type: {b.tera_type}")
        print("Level: 100")
        print(
            f"EVs: {b.evs['HP']} HP / {b.evs['Atk']} Atk / {b.evs['Def']} Def / {b.evs['SpA']} SpA / {b.evs['SpD']} SpD / {b.evs['Spe']} Spe"
        )
        print(f"{b.nature} Nature")
        for m in b.moves:
            print(f"- {m}")

    print("\n================== TRIO OBJECTIVE ==================")
    print(
        f"Avg best-of-trio P(win) across {used} usable threats (vs variant mixtures): {avg:.3f}"
    )
    losses = [t for t, v in agg.items() if (v < 0.5)]
    print(f"Outright losses (best-of-trio): {len(losses)} -> {sorted(losses)}")

    dur = time.time() - start
    print(f"\nDone in {dur:.1f}s on CPU.")
    print("Tips:")
    print("- For speed: reduce EV_STEPS or THREAT_LIST; sample fewer movesets.")
    print("- For quality: widen movesets or EV grid; increase LOCAL_REFINE_PASSES.")
    print(
        "- SEARCH_TURNS is set to 3 to match official 1v1 sudden-death; keep it at 3 for fidelity."
    )


# === SV 1v1 OPTIMIZER — PATCH 3.1.0 ===
# Purpose: remove physical-only bias, use legality-correct movepools, add missing meta moves,
#          and (CRITICAL) choose EV axes dynamically per *moveset* (not species base stats).
# Sources for movepools (Gen 9 / SV):
#   - Swampert moves (SV): https://pokemondb.net/pokedex/swampert/moves/9
#   - Blaziken moves (SV): https://pokemondb.net/pokedex/blaziken/moves/9
#   - Quaquaval moves (SV): https://pokemondb.net/pokedex/quaquaval/moves/9
# Notes:
#   - We only include moves that actually matter in 1v1 (damaging STAB, key coverages, Protect, SD, Counter where legal).
#   - We keep your no-RNG damage roll approximation and 3-turn sudden-death fidelity.
#   - This patch appends/overrides — paste near the *end* of the file (after all definitions). Later defs win in Python.

# ------------------------------
# 1) Add/ensure missing moves in MOVE_DB (+ recoil table)
# ------------------------------
if "High Jump Kick" not in MOVE_DB:
    MOVE_DB["High Jump Kick"] = Move("High Jump Kick", "Fighting", "Physical", 130, 0.9, contact=True)
if "Aqua Jet" not in MOVE_DB:
    MOVE_DB["Aqua Jet"] = Move("Aqua Jet", "Water", "Physical", 40, 1.0, contact=True, priority=1)
if "Wave Crash" not in MOVE_DB:
    MOVE_DB["Wave Crash"] = Move("Wave Crash", "Water", "Physical", 120, 1.0, contact=True)
if "Hammer Arm" not in MOVE_DB:
    MOVE_DB["Hammer Arm"] = Move("Hammer Arm", "Fighting", "Physical", 100, 0.9, contact=True)
if "Superpower" not in MOVE_DB:
    MOVE_DB["Superpower"] = Move("Superpower", "Fighting", "Physical", 120, 1.0, contact=True)
if "Body Press" not in MOVE_DB:
    MOVE_DB["Body Press"] = Move("Body Press", "Fighting", "Physical", 80, 1.0, contact=True)
if "Earth Power" not in MOVE_DB:
    MOVE_DB["Earth Power"] = Move("Earth Power", "Ground", "Special", 90, 1.0)
if "Surf" not in MOVE_DB:
    MOVE_DB["Surf"] = Move("Surf", "Water", "Special", 90, 1.0)
if "Waterfall" not in MOVE_DB:
    MOVE_DB["Waterfall"] = Move("Waterfall", "Water", "Physical", 80, 1.0, contact=True)
if "Aqua Cutter" not in MOVE_DB:
    MOVE_DB["Aqua Cutter"] = Move("Aqua Cutter", "Water", "Physical", 70, 1.0, contact=True)

# Recoil table updates
RECOIL_RATIO["Wave Crash"] = 1 / 3  # same recoil model as Brave Bird/Flare Blitz class

# ------------------------------
# 2) Critical mechanics patch — High Jump Kick crash on MISS
# ------------------------------
# Override branch_on_move to inject crash damage only for the MISS branch of High Jump Kick

# ------------------------------
# 3) Legality-correct movepools (SV) for the trio
# ------------------------------
LEGAL_MOVES = {
    "Swampert": LEGAL_MOVES_SWAMPERT,
    "Blaziken": LEGAL_MOVES_BLAZIKEN,
    "Quaquaval": LEGAL_MOVES_QUAQUAVAL,
}

MOVE_POOLS = {k: list(LEGAL_MOVES[k]) for k in LEGAL_MOVES}

FOUR_PHYSICAL_ONLY = {k: False for k in LEGAL_MOVES}


def assert_legal_moves(species: str, moves: List[str]) -> None:
    legal = set(LEGAL_MOVES.get(species, []))
    bad = [m for m in moves if m not in legal]
    if bad:
        raise ValueError(f"Illegal moves for {species}: {bad}")


# ------------------------------
# 4) EV axes must depend on the MOVES used (CRITICAL FIX)
# ------------------------------
def _is_damaging(mname: str) -> bool:
    return MOVE_DB[mname].category in ("Physical", "Special")


# ------------------------------
# 6) Bump version label for clarity at runtime
# ------------------------------
def _print_version_banner():
    print("== SV 1v1 Optimizer — CPU only ==")
    print("Version:", "3.1.0")
    print("Note: 3.1.0 enables legality-correct movepools and dynamic EV axes per moveset (phys/spec/mixed).")


_old_main = main


def main():
    start = time.time()
    _print_version_banner()
    globals()["_svi_banner_override"] = True
    try:
        return _old_main()
    finally:
        globals().pop("_svi_banner_override", None)

# ======================================================================================
# PATCH: "No-Stub Moves + Per–Move-Set EV Axes"  —  Make results accurate & complete
# ======================================================================================
# Why this is the single most important fix:
# ------------------------------------------------
# (A) The current file silently "adds missing moves" as Normal/Status stubs when a move
#     isn't in MOVE_DB yet. That *destroys accuracy* (damaging moves become non-damaging,
#     wrong typing/priority/contact, etc.), so the search can never find the true best sets.
# (B) EV axis selection is still species-based in a few places. To pick truly optimal sets,
#     EV axes must be chosen per *moveset* (Phys, Spec, or Mixed), not by base stats.
#
# This patch:
#   1) **Bans stubs**: if a referenced move lacks a real definition, we hard-fail with a
#      clear list of what’s missing — no more auto "Normal/Status" placeholders.
#   2) **Seeds MOVE_DB** with correct definitions for *every* move referenced by the trio
#      pools and threat presets that is commonly missing in the current file (type/category/
#      power/accuracy/priority/contact/multi-hit/always-crit flags). These merge cleanly
#      with your existing entries (we only add when absent).
#   3) **Picks EV axes per moveset** and carries them through both the grid enumeration and
#      the local EV refinement, so the optimizer can properly invest in Atk/SpA for mixed sets.
#
# Notes:
# - Keep this block near the *end* of the file so it overrides earlier helpers.
# - No external deps. No web calls. Everything is self-contained for offline runs.
# - If you later expand movepools or threats, just add their moves into REQUIRED_MOVES.
# ======================================================================================

# ------------------------------
# 0) Helper: safe insert (only if absent)
# ------------------------------
def _ensure_move(name: str, mtype: str, cat: str, power: int, acc: float = 1.0,
                 *, contact: bool = False, priority: int = 0, is_punch: bool = False,
                 is_slicing: bool = False, multi_hits: int = 1, always_crit: bool = False,
                 first_turn_only: bool = False, is_counter: bool = False, is_mirror_coat: bool = False):
    if name in MOVE_DB:
        return
    MOVE_DB[name] = Move(
        name=name, mtype=mtype, category=cat, power=power, accuracy=acc,
        contact=contact, priority=priority, is_punch=is_punch, multi_hits=multi_hits,
        always_crit=always_crit, first_turn_only=first_turn_only,
        is_counter=is_counter, is_mirror_coat=is_mirror_coat
    )
    if is_slicing:
        object.__setattr__(MOVE_DB[name], "is_slicing", True)


# ------------------------------
# 1) Seed every referenced move with correct data (fills only if missing)
#    (These cover all moves used by LEGAL_MOVES_* and THREAT_PRESETS in this file.)
#    If you add new threats or movepool entries later, extend this list.
# ------------------------------
REQUIRED_MOVES: dict[str, dict] = {
    # Priority & staples
    "Extreme Speed":   {"mtype":"Normal","cat":"Physical","power":80,"acc":1.0,"priority":2,"contact":True},
    "Bullet Punch":    {"mtype":"Steel","cat":"Physical","power":40,"acc":1.0,"priority":1,"contact":True},
    "Mach Punch":      {"mtype":"Fighting","cat":"Physical","power":40,"acc":1.0,"priority":1,"contact":True},
    "Aqua Jet":        {"mtype":"Water","cat":"Physical","power":40,"acc":1.0,"priority":1,"contact":True},
    "Ice Shard":       {"mtype":"Ice","cat":"Physical","power":40,"acc":1.0,"priority":1,"contact":False},
    "Sucker Punch":    {"mtype":"Dark","cat":"Physical","power":70,"acc":1.0,"priority":1,"contact":True},

    # Common physicals
    "Liquidation":     {"mtype":"Water","cat":"Physical","power":85,"acc":1.0,"contact":True},
    "Waterfall":       {"mtype":"Water","cat":"Physical","power":80,"acc":1.0,"contact":True},
    "Surf":            {"mtype":"Water","cat":"Special","power":90,"acc":1.0},
    "Hydro Pump":      {"mtype":"Water","cat":"Special","power":110,"acc":0.8},
    "Chilling Water":  {"mtype":"Water","cat":"Special","power":50,"acc":1.0},
    "Flip Turn":       {"mtype":"Water","cat":"Physical","power":60,"acc":1.0,"contact":True},
    "Aqua Tail":       {"mtype":"Water","cat":"Physical","power":90,"acc":0.9,"contact":True},
    "Aqua Cutter":     {"mtype":"Water","cat":"Physical","power":70,"acc":1.0,"contact":True},

    "Earthquake":      {"mtype":"Ground","cat":"Physical","power":100,"acc":1.0},
    "High Horsepower": {"mtype":"Ground","cat":"Physical","power":95,"acc":0.95,"contact":True},
    "Stomping Tantrum":{"mtype":"Ground","cat":"Physical","power":75,"acc":1.0,"contact":True},
    "Bulldoze":        {"mtype":"Ground","cat":"Physical","power":60,"acc":1.0},
    "Mud Shot":        {"mtype":"Ground","cat":"Special","power":55,"acc":0.95},
    "Dig":             {"mtype":"Ground","cat":"Physical","power":80,"acc":1.0,"contact":True},
    "Headlong Rush":   {"mtype":"Ground","cat":"Physical","power":120,"acc":1.0,"contact":True},

    "Ice Punch":       {"mtype":"Ice","cat":"Physical","power":75,"acc":1.0,"contact":True,"is_punch":True},
    "Ice Fang":        {"mtype":"Ice","cat":"Physical","power":65,"acc":0.95,"contact":True},
    "Ice Spinner":     {"mtype":"Ice","cat":"Physical","power":80,"acc":1.0,"contact":True},
    "Avalanche":       {"mtype":"Ice","cat":"Physical","power":60,"acc":1.0,"contact":True},
    "Ice Beam":        {"mtype":"Ice","cat":"Special","power":90,"acc":1.0},
    "Icicle Crash":    {"mtype":"Ice","cat":"Physical","power":85,"acc":0.9,"contact":True},

    "Rock Slide":      {"mtype":"Rock","cat":"Physical","power":75,"acc":0.9},
    "Rock Tomb":       {"mtype":"Rock","cat":"Physical","power":60,"acc":0.95},
    "Stone Edge":      {"mtype":"Rock","cat":"Physical","power":100,"acc":0.8},

    "Close Combat":    {"mtype":"Fighting","cat":"Physical","power":120,"acc":1.0,"contact":True},
    "Drain Punch":     {"mtype":"Fighting","cat":"Physical","power":75,"acc":1.0,"contact":True},
    "Brick Break":     {"mtype":"Fighting","cat":"Physical","power":75,"acc":1.0,"contact":True},
    "Low Kick":        {"mtype":"Fighting","cat":"Physical","power":60,"acc":1.0,"contact":True},  # weight-var not modeled
    "Low Sweep":       {"mtype":"Fighting","cat":"Physical","power":65,"acc":1.0,"contact":True},
    "Body Press":      {"mtype":"Fighting","cat":"Physical","power":80,"acc":1.0,"contact":True},
    "Reversal":        {"mtype":"Fighting","cat":"Physical","power":80,"acc":1.0,"contact":True},  # HP-var not modeled

    "Aqua Step":       {"mtype":"Water","cat":"Physical","power":80,"acc":1.0,"contact":True},
    "Brave Bird":      {"mtype":"Flying","cat":"Physical","power":120,"acc":1.0,"contact":True},
    "Acrobatics":      {"mtype":"Flying","cat":"Physical","power":55,"acc":1.0,"contact":False},

    "Blaze Kick":      {"mtype":"Fire","cat":"Physical","power":85,"acc":0.9,"contact":True},
    "Fire Punch":      {"mtype":"Fire","cat":"Physical","power":75,"acc":1.0,"contact":True,"is_punch":True},
    "Flame Charge":    {"mtype":"Fire","cat":"Physical","power":50,"acc":1.0,"contact":True},
    "Flare Blitz":     {"mtype":"Fire","cat":"Physical","power":120,"acc":1.0,"contact":True},
    "Fire Blast":      {"mtype":"Fire","cat":"Special","power":110,"acc":0.85},
    "Flamethrower":    {"mtype":"Fire","cat":"Special","power":90,"acc":1.0},
    "Overheat":        {"mtype":"Fire","cat":"Special","power":130,"acc":0.9},
    "Heat Wave":       {"mtype":"Fire","cat":"Special","power":95,"acc":0.9},
    "Mystical Fire":   {"mtype":"Fire","cat":"Special","power":75,"acc":1.0},

    "Thunder Punch":   {"mtype":"Electric","cat":"Physical","power":75,"acc":1.0,"contact":True,"is_punch":True},
    "Wild Charge":     {"mtype":"Electric","cat":"Physical","power":90,"acc":1.0,"contact":True},

    "Zen Headbutt":    {"mtype":"Psychic","cat":"Physical","power":80,"acc":0.9,"contact":True},
    "Psychic":         {"mtype":"Psychic","cat":"Special","power":90,"acc":1.0},
    "Psyshock":        {"mtype":"Psychic","cat":"Special","power":80,"acc":1.0},

    "Knock Off":       {"mtype":"Dark","cat":"Physical","power":65,"acc":1.0,"contact":True},
    "Dark Pulse":      {"mtype":"Dark","cat":"Special","power":80,"acc":1.0},
    "Fiery Wrath":     {"mtype":"Dark","cat":"Special","power":90,"acc":1.0},

    "Hyper Voice":     {"mtype":"Normal","cat":"Special","power":90,"acc":1.0},
    "Tri Attack":      {"mtype":"Normal","cat":"Special","power":80,"acc":1.0},
    "Giga Impact":     {"mtype":"Normal","cat":"Physical","power":150,"acc":0.9,"contact":True},
    "Double-Edge":     {"mtype":"Normal","cat":"Physical","power":120,"acc":1.0,"contact":True},
    "Facade":          {"mtype":"Normal","cat":"Physical","power":70,"acc":1.0},
    "Endeavor":        {"mtype":"Normal","cat":"Physical","power":1,"acc":1.0},  # HP-var not modeled
    "Quick Attack":    {"mtype":"Normal","cat":"Physical","power":40,"acc":1.0,"priority":1,"contact":True},
    "Hyper Beam":      {"mtype":"Normal","cat":"Special","power":150,"acc":0.9},
    "Work Up":         {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},

    "Moonblast":       {"mtype":"Fairy","cat":"Special","power":95,"acc":1.0},
    "Draining Kiss":   {"mtype":"Fairy","cat":"Special","power":50,"acc":1.0},
    "Play Rough":      {"mtype":"Fairy","cat":"Physical","power":90,"acc":0.9,"contact":True},

    "Make It Rain":    {"mtype":"Steel","cat":"Special","power":120,"acc":0.9},
    "Iron Head":       {"mtype":"Steel","cat":"Physical","power":80,"acc":1.0,"contact":True},
    "Flash Cannon":    {"mtype":"Steel","cat":"Special","power":80,"acc":1.0},
    "Tachyon Cutter":  {"mtype":"Steel","cat":"Special","power":50,"acc":1.0},  # multi-hit not modeled

    "Ivy Cudgel":      {"mtype":"Grass","cat":"Physical","power":100,"acc":1.0,"contact":True},
    "Power Whip":      {"mtype":"Grass","cat":"Physical","power":120,"acc":0.85,"contact":True},
    "Leaf Blade":      {"mtype":"Grass","cat":"Physical","power":90,"acc":1.0,"contact":True},
    "Leaf Storm":      {"mtype":"Grass","cat":"Special","power":130,"acc":0.9},
    "Energy Ball":     {"mtype":"Grass","cat":"Special","power":90,"acc":1.0},
    "Trailblaze":      {"mtype":"Grass","cat":"Physical","power":50,"acc":1.0,"contact":True},

    "Shadow Ball":     {"mtype":"Ghost","cat":"Special","power":80,"acc":1.0},
    "Shadow Claw":     {"mtype":"Ghost","cat":"Physical","power":70,"acc":1.0,"contact":True},
    "Shadow Sneak":    {"mtype":"Ghost","cat":"Physical","power":40,"acc":1.0,"priority":1,"contact":True},

    "Outrage":         {"mtype":"Dragon","cat":"Physical","power":120,"acc":1.0,"contact":True},
    "Dragon Claw":     {"mtype":"Dragon","cat":"Physical","power":80,"acc":1.0,"contact":True},
    "Draco Meteor":    {"mtype":"Dragon","cat":"Special","power":130,"acc":0.9},
    "Dragon Pulse":    {"mtype":"Dragon","cat":"Special","power":85,"acc":1.0},

    "Hurricane":       {"mtype":"Flying","cat":"Special","power":110,"acc":0.7},
    "Air Slash":       {"mtype":"Flying","cat":"Special","power":75,"acc":0.95},
    "Aerial Ace":      {"mtype":"Flying","cat":"Physical","power":60,"acc":1.0,"contact":True},

    "Earth Power":     {"mtype":"Ground","cat":"Special","power":90,"acc":1.0},
    "Thunderbolt":     {"mtype":"Electric","cat":"Special","power":90,"acc":1.0},
    "Freeze-Dry":      {"mtype":"Ice","cat":"Special","power":70,"acc":1.0},

    "Surging Strikes": {"mtype":"Water","cat":"Physical","power":25,"acc":1.0,"contact":True,"multi_hits":3,"always_crit":True},

    # Utility / status included for item filters & logic already present
    "Protect":         {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},
    "Detect":          {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},
    "Substitute":      {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},
    "Encore":          {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},
    "Taunt":           {"mtype":"Dark","cat":"Status","power":0,"acc":1.0},
    "Bulk Up":         {"mtype":"Fighting","cat":"Status","power":0,"acc":1.0},
    "Swords Dance":    {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},
    "Counter":         {"mtype":"Fighting","cat":"Physical","power":0,"acc":1.0,"is_counter":True,"priority":-5},
    "Mirror Coat":     {"mtype":"Psychic","cat":"Special","power":0,"acc":1.0,"is_mirror_coat":True,"priority":-5},
    "Yawn":            {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},
    "Curse":           {"mtype":"Ghost","cat":"Status","power":0,"acc":1.0},  # split not modeled
    "Rest":            {"mtype":"Psychic","cat":"Status","power":0,"acc":1.0},
    "Sleep Talk":      {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},
    "Endure":          {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},
    "Agility":         {"mtype":"Psychic","cat":"Status","power":0,"acc":1.0},
    "Focus Energy":    {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},
    "Sunny Day":       {"mtype":"Fire","cat":"Status","power":0,"acc":1.0},
    "Rain Dance":      {"mtype":"Water","cat":"Status","power":0,"acc":1.0},
    "Roar":            {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},
    "Baton Pass":      {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},
    "Work Up":         {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},
    "Helping Hand":    {"mtype":"Normal","cat":"Status","power":0,"acc":1.0},

    # Meta threats missing occasionally
    "Wicked Blow":     {"mtype":"Dark","cat":"Physical","power":80,"acc":1.0,"contact":True,"always_crit":True},
    "Hydro Steam":     {"mtype":"Water","cat":"Special","power":80,"acc":1.0},
    "Torch Song":      {"mtype":"Fire","cat":"Special","power":80,"acc":1.0},
    "Salt Cure":       {"mtype":"Rock","cat":"Physical","power":40,"acc":1.0},
    "Kowtow Cleave":   {"mtype":"Dark","cat":"Physical","power":85,"acc":1.0,"contact":True},
    "Gunk Shot":       {"mtype":"Poison","cat":"Physical","power":120,"acc":0.8,"contact":True},
    "U-turn":          {"mtype":"Bug","cat":"Physical","power":70,"acc":1.0,"contact":True},
    "Leech Life":      {"mtype":"Bug","cat":"Physical","power":80,"acc":1.0,"contact":True},
    "Pounce":          {"mtype":"Bug","cat":"Physical","power":50,"acc":1.0,"contact":True},
    "Hyper Beam":      {"mtype":"Normal","cat":"Special","power":150,"acc":0.9},
    "Giga Impact":     {"mtype":"Normal","cat":"Physical","power":150,"acc":0.9,"contact":True},
}

for _mn, _md in REQUIRED_MOVES.items():
    _ensure_move(_mn, **_md)

# Recoil table (merge/ensure)
RECOIL_RATIO.update({
    "Flare Blitz": 1/3,
    "Brave Bird":  1/3,
    "Wild Charge": 1/4,
    "Wave Crash":  1/3,
    "Double-Edge": 1/3,
})

# ------------------------------
# 2) BAN silent stubs: audit all referenced moves and hard-fail if any are undefined or mis-typed
# ------------------------------
def _all_referenced_moves() -> set[str]:
    s: set[str] = set()
    for sp, pool in LEGAL_MOVES.items():
        s.update(pool)
    for _sp, variants in THREAT_PRESETS.items():
        for sb in variants:
            s.update(sb.moves)
    return s


def _is_damage_move_expected(name: str) -> bool:
    # We expect these to be damaging; if your LEGAL_MOVES later includes other status-only moves,
    # add them to the allowlist below so the audit won't complain.
    allow_status = {
        "Protect","Detect","Substitute","Encore","Taunt","Bulk Up","Swords Dance",
        "Yawn","Curse","Rest","Sleep Talk","Endure","Agility","Focus Energy",
        "Sunny Day","Rain Dance","Baton Pass","Roar","Helping Hand","Work Up"
    }
    if name in allow_status:
        return False
    # Counter/Mirror Coat are special-case "damaging resolution" but flagged on the move
    if name in {"Counter","Mirror Coat"}:
        return False
    # Tera Blast can be Special by default; still treated as a damaging move
    return True


def _audit_moves_or_die():
    missing: list[str] = []
    wrong: list[str] = []
    for m in sorted(_all_referenced_moves()):
        if m not in MOVE_DB:
            missing.append(m)
            continue
        mv = MOVE_DB[m]
        if _is_damage_move_expected(m):
            # Must be Physical or Special with power > 0
            if mv.category not in ("Physical","Special") or base_power(mv) <= 0:
                wrong.append(m)
    if missing or wrong:
        raise RuntimeError(
            "[MOVE_DB AUDIT FAILED]\n"
            + (f"- Missing move defs: {missing}\n" if missing else "")
            + (f"- Misdefined damaging moves (need type/category/power): {wrong}\n" if wrong else "")
            + "Fix by adding entries to REQUIRED_MOVES above."
        )


# Run the audit once at import time
_audit_moves_or_die()


# === PATCH: "No-Missing-Moves + Per–Move-Set EV Axes + Key Gen9 Effects" =========================
# Paste this WHOLE block near the END of your file (after all definitions). Later defs override earlier ones.
# This fixes the single biggest source of inaccuracy: missing/incorrect move definitions causing the
# search to ignore or mis-rate legal, meta-relevant moves — and EV axes chosen by species base stats
# instead of the ACTUAL moveset (phys/special/mixed). It also adds the most impactful Gen 9 side-effects.

# -----------------------------------------------------------------------------------------------
# 0) Utilities
# -----------------------------------------------------------------------------------------------
def _ensure_move(name: str, mtype: str, cat: str, power: int, acc: float = 1.0, *,
                 contact: bool = False, priority: int = 0, is_punch: bool = False,
                 is_slicing: bool = False, multi_hits: int = 1, always_crit: bool = False,
                 first_turn_only: bool = False, needs_recharge: bool = False):
    """Idempotently seed a move with correct flags if it's missing."""
    if name in MOVE_DB:
        # allow small flag corrections for common mistakes (e.g., contact flag drift)
        old = MOVE_DB[name]
        if hasattr(old, "contact") and old.contact != contact:
            object.__setattr__(old, "contact", contact)
        if hasattr(old, "priority") and old.priority != priority:
            object.__setattr__(old, "priority", priority)
        if hasattr(old, "multi_hits") and old.multi_hits != multi_hits:
            object.__setattr__(old, "multi_hits", multi_hits)
        if hasattr(old, "always_crit") and old.always_crit != always_crit:
            object.__setattr__(old, "always_crit", always_crit)
        if hasattr(old, "first_turn_only") and old.first_turn_only != first_turn_only:
            object.__setattr__(old, "first_turn_only", first_turn_only)
        # attach a recharge flag if needed
        if needs_recharge and not hasattr(old, "needs_recharge"):
            object.__setattr__(old, "needs_recharge", True)
        return
    mv = Move(
        name=name, mtype=mtype, category=cat, power=power, accuracy=acc,
        contact=contact, priority=priority, is_punch=is_punch, multi_hits=multi_hits,
        always_crit=always_crit, first_turn_only=first_turn_only
    )
    # mark slicing for Sharpness interactions when applicable
    if is_slicing:
        object.__setattr__(mv, "is_slicing", True)
    if needs_recharge:
        object.__setattr__(mv, "needs_recharge", True)
    MOVE_DB[name] = mv


# -----------------------------------------------------------------------------------------------
# 1) Seed/correct ALL moves referenced by trio pools + threat presets (SV legality)
#    (Values cross-checked vs Bulbapedia / Serebii Gen9; no secondary RNG modeled here.)
# -----------------------------------------------------------------------------------------------
# Water
_ensure_move("Aqua Jet",      "Water", "Physical", 40, 1.0, contact=True, priority=1)
_ensure_move("Aqua Tail",     "Water", "Physical", 90, 0.9, contact=True)
_ensure_move("Chilling Water","Water", "Special",  50, 1.0)                 # target -1 Atk (see effects)
_ensure_move("Surf",          "Water", "Special",  90, 1.0)
_ensure_move("Waterfall",     "Water", "Physical", 80, 1.0, contact=True)
_ensure_move("Flip Turn",     "Water", "Physical", 60, 1.0, contact=True)
_ensure_move("Aqua Cutter",   "Water", "Physical", 70, 1.0, contact=False, is_slicing=True)  # NOT contact
_ensure_move("Hydro Pump",    "Water", "Special", 110, 0.8)
_ensure_move("Hydro Cannon",  "Water", "Special", 150, 0.9, needs_recharge=True)
_ensure_move("Liquidation",   "Water", "Physical", 85, 1.0, contact=True)
_ensure_move("Rain Dance",    "Water", "Status",   0,   1.0)
_ensure_move("Hydro Steam",   "Water", "Special",  80, 1.0)

# Ground / Rock
_ensure_move("Bulldoze",          "Ground", "Physical", 60, 1.0, contact=True)
_ensure_move("High Horsepower",   "Ground", "Physical", 95, 0.95, contact=True)
_ensure_move("Mud Shot",          "Ground", "Special",  55, 0.95)
_ensure_move("Rock Slide",        "Rock",   "Physical", 75, 0.9)
_ensure_move("Rock Tomb",         "Rock",   "Physical", 60, 0.95, contact=True)
_ensure_move("Stone Edge",        "Rock",   "Physical", 100, 0.8)
_ensure_move("Stomping Tantrum",  "Ground", "Physical", 75, 1.0, contact=True)
_ensure_move("Earth Power",       "Ground", "Special",  90, 1.0)
_ensure_move("Headlong Rush",     "Ground", "Physical", 120, 1.0, contact=True)

# Ice
_ensure_move("Avalanche",     "Ice",   "Physical", 60, 1.0, contact=True)
_ensure_move("Ice Beam",      "Ice",   "Special",  90, 1.0)
_ensure_move("Ice Fang",      "Ice",   "Physical", 65, 0.95, contact=True)
_ensure_move("Ice Punch",     "Ice",   "Physical", 75, 1.0, contact=True, is_punch=True)
_ensure_move("Ice Spinner",   "Ice",   "Physical", 80, 1.0, contact=True)
_ensure_move("Icy Wind",      "Ice",   "Special",  55, 0.95)

# Fire
_ensure_move("Blaze Kick",    "Fire",  "Physical", 85, 0.9, contact=True)
_ensure_move("Flame Charge",  "Fire",  "Physical", 50, 1.0, contact=True)   # user +1 Spe (see effects)
_ensure_move("Flamethrower",  "Fire",  "Special",  90, 1.0)
_ensure_move("Fire Blast",    "Fire",  "Special", 110, 0.85)
_ensure_move("Overheat",      "Fire",  "Special", 130, 0.9)                  # user -2 SpA (see effects)
_ensure_move("Heat Wave",     "Fire",  "Special",  95, 0.9)
_ensure_move("Flare Blitz",   "Fire",  "Physical", 120, 1.0, contact=True)  # recoil modeled
_ensure_move("Sunny Day",     "Fire",  "Status",    0, 1.0)
_ensure_move("Fire Spin",     "Fire",  "Special",  35, 0.85)                 # trap/DoT not modeled
_ensure_move("Mystical Fire", "Fire",  "Special",  75, 1.0)                  # target -1 SpA (see effects)
_ensure_move("Torch Song",    "Fire",  "Special",  80, 1.0)                  # user +1 SpA (see effects)
_ensure_move("Make It Rain",  "Steel", "Special", 120, 0.9)                  # user -1 SpA (see effects)

# Fighting
_ensure_move("Close Combat",  "Fighting","Physical",120,1.0, contact=True)  # user -1 Def/SpD (present)
_ensure_move("Low Kick",      "Fighting","Physical",  1, 1.0, contact=True) # weight-based (use 80 avg)
_ensure_move("Low Sweep",     "Fighting","Physical", 65, 1.0, contact=True) # target -1 Spe (effects)
_ensure_move("Reversal",      "Fighting","Physical",  1, 1.0, contact=True) # HP-based (approx later)
_ensure_move("Brick Break",   "Fighting","Physical", 75, 1.0, contact=True)
_ensure_move("Drain Punch",   "Fighting","Physical", 75, 1.0, contact=True) # healing not modeled
_ensure_move("Bulk Up",       "Fighting","Status",    0, 1.0)                # user +1 Atk/+1 Def (effects)
_ensure_move("Counter",       "Fighting","Physical",  0, 1.0)                # already supported
_ensure_move("Body Press",    "Fighting","Physical", 80, 1.0, contact=True)  # uses Def for attack (below)
_ensure_move("Vacuum Wave",   "Fighting","Special",  40, 1.0, priority=1)
_ensure_move("High Jump Kick","Fighting","Physical",130,0.9, contact=True)   # crash modeled on miss
_ensure_move("Hammer Arm",    "Fighting","Physical",100,0.9, contact=True)   # user -1 Spe (effects)
_ensure_move("Superpower",    "Fighting","Physical",120,1.0, contact=True)   # user -1 Atk/Def (effects)

# Flying
_ensure_move("Brave Bird",    "Flying","Physical",120,1.0, contact=True)     # recoil modeled
_ensure_move("Aerial Ace",    "Flying","Physical", 60, 1.0, contact=True)
_ensure_move("Bounce",        "Flying","Physical", 85, 0.85, contact=True)   # semi-inv not modeled
_ensure_move("Acrobatics",    "Flying","Physical", 55, 1.0, contact=True)

# Dark / Ghost
_ensure_move("Knock Off",     "Dark",  "Physical", 65, 1.0, contact=True)
_ensure_move("Night Slash",   "Dark",  "Physical", 70, 1.0, contact=True, is_slicing=True)
_ensure_move("Sucker Punch",  "Dark",  "Physical", 70, 1.0, contact=True, priority=1)
_ensure_move("Shadow Claw",   "Ghost", "Physical", 70, 1.0, contact=True, is_slicing=True)
_ensure_move("Shadow Ball",   "Ghost", "Special",  80, 1.0)
_ensure_move("Fiery Wrath",   "Dark",  "Special",  90, 1.0)
_ensure_move("Wicked Blow",   "Dark",  "Physical", 80, 1.0, contact=True, always_crit=True)
_ensure_move("Shadow Sneak",  "Ghost", "Physical", 40, 1.0, contact=True, priority=1)

# Electric / Psychic / Poison / Fairy / Normal / Bug / Grass / Steel
_ensure_move("Thunder Punch", "Electric","Physical",75,1.0, contact=True, is_punch=True)
_ensure_move("Thunderbolt",   "Electric","Special", 90,1.0)
_ensure_move("Zen Headbutt",  "Psychic","Physical", 80,0.9, contact=True)
_ensure_move("Psychic",       "Psychic","Special",  90,1.0)
_ensure_move("Psyshock",      "Psychic","Special",  80,1.0)                   # uses Def on target (present)
_ensure_move("Poison Jab",    "Poison","Physical",  80,1.0, contact=True)
_ensure_move("Draining Kiss", "Fairy", "Special",   50,1.0)                   # healing not modeled
_ensure_move("Play Rough",    "Fairy", "Physical",  90,0.9, contact=True)
_ensure_move("Hyper Voice",   "Normal","Special",   90,1.0)
_ensure_move("Tri Attack",    "Normal","Special",   80,1.0)
_ensure_move("Extreme Speed", "Normal","Physical",  80,1.0, contact=True, priority=2)
_ensure_move("Facade",        "Normal","Physical",  70,1.0, contact=True)
_ensure_move("Endure",        "Normal","Status",     0,1.0)                   # sash-analog not modeled
_ensure_move("Quick Attack",  "Normal","Physical",  40,1.0, contact=True, priority=1)
_ensure_move("Giga Impact",   "Normal","Physical", 150,0.9, contact=True, needs_recharge=True)
_ensure_move("Hyper Beam",    "Normal","Special", 150,0.9, needs_recharge=True)
_ensure_move("U-turn",        "Bug",   "Physical", 70, 1.0, contact=True)
_ensure_move("Pounce",        "Bug",   "Physical", 50, 1.0, contact=True)    # target -1 Spe (effects)
_ensure_move("Leech Life",    "Bug",   "Physical", 80, 1.0, contact=True)
_ensure_move("Trailblaze",    "Grass", "Physical", 50, 1.0, contact=True)    # user +1 Spe (effects)
_ensure_move("Energy Ball",   "Grass", "Special",  90, 1.0)
_ensure_move("Power Whip",    "Grass", "Physical",120, 0.85, contact=True)
_ensure_move("Leaf Blade",    "Grass", "Physical", 90, 1.0, contact=True, is_slicing=True)
_ensure_move("Flash Cannon",  "Steel", "Special",  80, 1.0)
_ensure_move("Iron Head",     "Steel", "Physical", 80, 1.0, contact=True)
_ensure_move("Body Press",    "Fighting","Physical",80, 1.0, contact=True)

# Correct recoil table for added moves
RECOIL_RATIO.update({"Wave Crash": 1/3})

# -----------------------------------------------------------------------------------------------
# 2) Enforce “no missing moves” — fail early with a clear list
# -----------------------------------------------------------------------------------------------
def _all_required_moves() -> set[str]:
    req = set()
    for sp, pool in LEGAL_MOVES.items():
        req |= set(pool)
    for variants in THREAT_PRESETS.values():
        for sb in variants:
            req |= set(sb.moves)
    # ensure staples used internally
    req |= {"Protect", "Detect", "Swords Dance", "Counter", "Mirror Coat", "Tera Blast"}
    return req

_missing = sorted([m for m in _all_required_moves() if m not in MOVE_DB])
if _missing:
    raise RuntimeError(f"[SV 1v1] Missing MOVE_DB entries for: {_missing}. "
                       "Add them via _ensure_move above to keep the search accurate.")

# -----------------------------------------------------------------------------------------------
# 3) Implement key side-effects with the biggest 1v1 impact (deterministic stage changes only)
#    - User-side (already had some): Close Combat, Headlong Rush, Draco Meteor, Leaf Storm, etc.
#    - NEW: user buffs (Torch Song, Flame Charge, Trailblaze, Bulk Up, Hammer Arm, Superpower)
#           defender debuffs (Chilling Water, Mystical Fire, Spirit Break, Low Sweep, Pounce)
# -----------------------------------------------------------------------------------------------
def apply_stat_side_effects_after(self_state: BattleState, move: Move):
    # (keep existing drops)
    if move.name == "Close Combat":
        self_state.stages["Def"] = max(-6, self_state.stages["Def"] - 1)
        self_state.stages["SpD"] = max(-6, self_state.stages["SpD"] - 1)
    elif move.name == "Draco Meteor":
        self_state.stages["SpA"] = max(-6, self_state.stages["SpA"] - 2)
    elif move.name == "Leaf Storm":
        self_state.stages["SpA"] = max(-6, self_state.stages["SpA"] - 2)
    elif move.name == "Headlong Rush":
        self_state.stages["Def"] = max(-6, self_state.stages["Def"] - 1)
        self_state.stages["SpD"] = max(-6, self_state.stages["SpD"] - 1)
    # NEW user buffs/debuffs
    if move.name == "Aqua Step":
        self_state.stages["Spe"] = min(6, self_state.stages["Spe"] + 1)
    if move.name == "Flame Charge":
        self_state.stages["Spe"] = min(6, self_state.stages["Spe"] + 1)
    if move.name == "Trailblaze":
        self_state.stages["Spe"] = min(6, self_state.stages["Spe"] + 1)
    if move.name == "Bulk Up":
        self_state.stages["Atk"] = min(6, self_state.stages["Atk"] + 1)
        self_state.stages["Def"] = min(6, self_state.stages["Def"] + 1)
    if move.name == "Torch Song":
        self_state.stages["SpA"] = min(6, self_state.stages["SpA"] + 1)
    if move.name == "Overheat":
        self_state.stages["SpA"] = max(-6, self_state.stages["SpA"] - 2)
    if move.name == "Hammer Arm":
        self_state.stages["Spe"] = max(-6, self_state.stages["Spe"] - 1)
    if move.name == "Superpower":
        self_state.stages["Atk"] = max(-6, self_state.stages["Atk"] - 1)
        self_state.stages["Def"] = max(-6, self_state.stages["Def"] - 1)


def apply_defender_side_effects_after(def_state: BattleState, move: Move):
    # Target debuffs
    if move.name == "Chilling Water":
        def_state.stages["Atk"] = max(-6, def_state.stages["Atk"] - 1)
    if move.name == "Mystical Fire":
        def_state.stages["SpA"] = max(-6, def_state.stages["SpA"] - 1)
    if move.name == "Spirit Break":
        def_state.stages["SpA"] = max(-6, def_state.stages["SpA"] - 1)
    if move.name == "Low Sweep":
        def_state.stages["Spe"] = max(-6, def_state.stages["Spe"] - 1)
    if move.name == "Pounce":
        def_state.stages["Spe"] = max(-6, def_state.stages["Spe"] - 1)


# Hook defender effects into the damage path (when we already have `dealt > 0`)
if "perform_damage_hit_distribution" in globals():
    _orig_perform_damage_hit_distribution = perform_damage_hit_distribution
    def perform_damage_hit_distribution(*args, **kwargs):
        branches = _orig_perform_damage_hit_distribution(*args, **kwargs)
        # args: (self_build, opp_build, self_state, opp_state, mv, tera, ttype, weather, terrain, stats_self, stats_opp, opp_selected_move)
        mv = args[4]
        out = []
        for p, SA, SD in branches:
            if mv.category != "Status":
                # only apply defender debuff if this hit actually dealt damage (we track via last_received)
                last = SD.ability_active.get("last_received")
                if isinstance(last, dict) and last.get("damage", 0) > 0:
                    apply_defender_side_effects_after(SD, mv)
            out.append((p, SA, SD))
        return _merge_branch_states(out)

# -----------------------------------------------------------------------------------------------
# 4) High Jump Kick crash on MISS (already modeled in your accuracy split; ensure kept intact)
#    — nothing to change here if your earlier miss branch already halves max HP on miss.
# -----------------------------------------------------------------------------------------------

# -----------------------------------------------------------------------------------------------
# 5) Recharge turn handling for Hyper Beam / Giga Impact / Hydro Cannon.
#    Model: after using a recharge move, next turn is forced "Recharge (skip)".
# -----------------------------------------------------------------------------------------------
if "Recharge (skip)" not in MOVE_DB:
    MOVE_DB["Recharge (skip)"] = Move("Recharge (skip)", "Normal", "Status", 0, 1.0)

def _mark_recharge(state: BattleState, move: Move):
    if getattr(move, "needs_recharge", False):
        state.ability_active["RechargePending"] = True

# wrap branch_on_move to inject recharge marker
if "branch_on_move" in globals():
    _orig_branch_on_move = branch_on_move
    def branch_on_move(*args, **kwargs):
        res = _orig_branch_on_move(*args, **kwargs)
        mv = args[8]  # our selected Move (see original signature)
        new = []
        for p, SA, SD in res:
            if mv.category != "Status" and getattr(mv, "needs_recharge", False):
                _mark_recharge(SA, mv)
            new.append((p, SA, SD))
        return _merge_branch_states(new)

# force action_list_for to honor Recharge skip
if "action_list_for" in globals():
    _orig_action_list_for = action_list_for
    def action_list_for(build: SetBuild, state: BattleState) -> List[Tuple[str, bool]]:
        if state.ability_active.get("RechargePending", False):
            # consume the skip this turn; no Tera allowed on a skip
            return [("Recharge (skip)", False)]
        return _orig_action_list_for(build, state)

# when executing Recharge (skip), clear the flag
if "do_status_action" in globals():
    _orig_do_status_action = do_status_action
    def do_status_action(mv: Move, self_state: BattleState):
        if mv.name == "Recharge (skip)":
            self_state.ability_active["RechargePending"] = False
            return
        return _orig_do_status_action(mv, self_state)

# -----------------------------------------------------------------------------------------------
# 6) Body Press uses DEF as the attacking stat (instead of Atk). Implement in damage path.
# -----------------------------------------------------------------------------------------------
if "category_stat_names" in globals():
    _orig_category_stat_names = category_stat_names
    def category_stat_names(cat: str) -> Tuple[str, str]:
        if cat == "Physical":
            return ("Atk", "Def")
        elif cat == "Special":
            return ("SpA", "SpD")
        return _orig_category_stat_names(cat)

# Patch the inner selection to swap Atk->Def when the move is Body Press
if "perform_damage_hit_distribution" in globals():
    _orig_pdhd = perform_damage_hit_distribution
    def perform_damage_hit_distribution(*args, **kwargs):
        # args unpacking for readability
        self_build, opp_build, self_state, opp_state, mv = args[:5]
        stats_self = args[10]
        # inject a shadow move with a special flag for Body Press path
        if mv.name == "Body Press":
            # monkey-patch: emulate 'Atk' = 'Def' for this calc only by copying stats
            stats_self = dict(stats_self)
            stats_self["Atk"] = stats_self["Def"]
            # rebuild args tuple with modified stats_self
            args = (args[0], args[1], args[2], args[3], args[4], args[5], args[6],
                    args[7], args[8], args[9], stats_self, args[11],)
        return _orig_pdhd(*args, **kwargs)

# -----------------------------------------------------------------------------------------------
# 8) Speed calc nit: treat Low Kick/Reversal as having a sensible base power during pruning
#    (no RNG — we approximate to avoid selecting them purely by 0 BP in heuristics).
# -----------------------------------------------------------------------------------------------
def base_power(mv: Move) -> int:
    # reuse existing if already defined somewhere above
    if "base_power" in globals() and globals()["base_power"] is not base_power:
        return globals()["base_power"](mv)
    # Fallback: simple accessor
    return mv.power

# Adjust the coverage proxy so weight-based/HP-based moves aren't treated as 0-BP
if "_coverage_proxy" in globals():
    _orig_cov = _coverage_proxy
    def _coverage_proxy(species: str, moves: list[str]) -> tuple:
        # temporarily substitute an approximate BP for dynamic-power moves
        approx = {"Low Kick": 80, "Reversal": 80}
        patched = []
        for m in moves:
            if m in approx and m in MOVE_DB:
                mv = MOVE_DB[m]
                patched.append(Move(mv.name, mv.mtype, mv.category, approx[m],
                                    mv.accuracy, mv.contact, mv.is_punch, mv.multi_hits,
                                    mv.always_crit, mv.priority))
            else:
                patched.append(MOVE_DB[m])
        # Use a local inner that looks at `patched`
        stab_types = _stab_types_for(species)
        type_best_bp: defaultdict[str, int] = defaultdict(int)
        has_stab = False
        has_priority = False
        for mv in patched:
            if mv.category == "Status": continue
            type_best_bp[mv.mtype] = max(type_best_bp[mv.mtype], mv.power)
            if mv.mtype in stab_types: has_stab = True
            if mv.priority > 0: has_priority = True
        vect = []
        for dtyp in TYPES:
            best = 0.0
            for atyp, bp in type_best_bp.items():
                best = max(best, bp * effectiveness[type_index[atyp]][type_index[dtyp]])
            vect.append(int(best))
        return (tuple(vect), int(has_stab), int(has_priority))


# -----------------------------------------
# 0) Helpers to seed and validate MOVE_DB
# -----------------------------------------
def _seed_move_if_absent(name, mtype, category, power=0, acc=1.0, *,
                         contact=False, priority=0, is_punch=False,
                         multi_hits=1, always_crit=False, first_turn_only=False):
    if name in MOVE_DB:
        return
    MOVE_DB[name] = Move(
        name=name, mtype=mtype, category=category, power=power, accuracy=acc,
        contact=contact, priority=priority, is_punch=is_punch,
        multi_hits=multi_hits, always_crit=always_crit, first_turn_only=first_turn_only
    )

# Core recoil table extension (idempotent)
RECOIL_RATIO.update({"Double-Edge": 1/3, "Wave Crash": 1/3})

# -----------------------------------------
# 1) Define all moves used by trio & presets (missing in base)
#    (Only added if absent — safe to paste multiple times)
# -----------------------------------------
_missing_seed = [
    # Water / Ground / Rock / Ice (Swampert & threats)
    ("Aqua Tail","Water","Physical",90,0.9,True,0,False,1,False,False),
    ("Chilling Water","Water","Special",50,1.0,False,0,False,1,False,False),
    ("Hydro Cannon","Water","Special",150,0.9,False,0,False,1,False,False),
    ("Surf","Water","Special",90,1.0,False,0,False,1,False,False),
    ("Waterfall","Water","Physical",80,1.0,True,0,False,1,False,False),
    ("High Horsepower","Ground","Physical",95,0.95,True,0,False,1,False,False),
    ("Mud Shot","Ground","Special",55,0.95,False,0,False,1,False,False),
    ("Rock Tomb","Rock","Physical",60,0.95,True,0,False,1,False,False),
    ("Rock Blast","Rock","Physical",25,0.9,False,0,False,2,False,False),
    ("Avalanche","Ice","Physical",60,1.0,False,0,False,1,False,False),
    ("Ice Fang","Ice","Physical",65,0.95,True,0,False,1,False,False),
    ("Icy Wind","Ice","Special",55,0.95,False,0,False,1,False,False),

    # Steel / Normal / Psychic (various)
    ("Iron Head","Steel","Physical",80,1.0,True,0,False,1,False,False),
    ("Flash Cannon","Steel","Special",80,1.0,False,0,False,1,False,False),
    ("Facade","Normal","Physical",70,1.0,True,0,False,1,False,False),
    ("Double-Edge","Normal","Physical",120,1.0,True,0,False,1,False,False),
    ("Giga Impact","Normal","Physical",150,0.9,True,0,False,1,False,False),
    ("Psyshock","Psychic","Special",80,1.0,False,0,False,1,False,False),
    ("Power Gem","Rock","Special",80,1.0,False,0,False,1,False,False),

    # Fighting (common)
    ("Low Kick","Fighting","Physical",80,1.0,True,0,False,1,False,False),
    ("Low Sweep","Fighting","Physical",65,1.0,True,0,False,1,False,False),
    ("Brick Break","Fighting","Physical",75,1.0,True,0,False,1,False,False),
    ("Drain Punch","Fighting","Physical",75,1.0,True,0,False,1,False,False),
    ("Body Press","Fighting","Physical",80,1.0,True,0,False,1,False,False),
    ("Reversal","Fighting","Physical",80,1.0,True,0,False,1,False,False),

    # Fire (Blaziken & threats)
    ("Blaze Kick","Fire","Physical",85,0.9,True,0,False,1,False,False),
    ("Fire Punch","Fire","Physical",75,1.0,True,0,True,1,False,False),
    ("Flame Charge","Fire","Physical",50,1.0,True,0,False,1,False,False),
    ("Fire Blast","Fire","Special",110,0.85,False,0,False,1,False,False),
    ("Overheat","Fire","Special",130,0.9,False,0,False,1,False,False),
    ("Heat Wave","Fire","Special",95,0.9,False,0,False,1,False,False),
    ("Sunny Day","Fire","Status",0,1.0,False,0,False,1,False,False),
    ("Fire Spin","Fire","Special",35,0.85,False,0,False,1,False,False),

    # Flying
    ("Aerial Ace","Flying","Physical",60,1.0,True,0,False,1,False,False),
    ("Bounce","Flying","Physical",85,0.85,True,0,False,1,False,False),
    ("Acrobatics","Flying","Physical",55,1.0,True,0,False,1,False,False),
    ("Air Slash","Flying","Special",75,0.95,False,0,False,1,False,False),

    # Dark / Ghost / Poison
    ("Night Slash","Dark","Physical",70,1.0,True,0,False,1,True,False),
    ("Thief","Dark","Physical",60,1.0,True,0,False,1,False,False),
    ("Poison Jab","Poison","Physical",80,1.0,True,0,False,1,False,False),

    # Electric / Grass / Bug
    ("Thunder Punch","Electric","Physical",75,1.0,True,0,True,1,False,False),
    ("Wild Charge","Electric","Physical",90,1.0,True,0,False,1,False,False),
    ("Trailblaze","Grass","Physical",50,1.0,True,0,False,1,False,False),
    ("Energy Ball","Grass","Special",90,1.0,False,0,False,1,False,False),
    ("Pounce","Bug","Physical",50,1.0,True,0,False,1,False,False),
    ("U-turn","Bug","Physical",70,1.0,True,0,False,1,False,False),

    # Priority / utility
    ("Quick Attack","Normal","Physical",40,1.0,True,1,False,1,False,False),
    ("Vacuum Wave","Fighting","Special",40,1.0,False,1,False,1,False,False),

    # Status/field/control used in pools (safe, even if simulator treats as no-damage)
    ("Encore","Normal","Status",0,1.0,False,0,False,1,False,False),
    ("Taunt","Dark","Status",0,1.0,False,0,False,1,False,False),
    ("Substitute","Normal","Status",0,1.0,False,0,False,1,False,False),
    ("Yawn","Normal","Status",0,1.0,False,0,False,1,False,False),
    ("Curse","Ghost","Status",0,1.0,False,0,False,1,False,False),
    ("Rest","Psychic","Status",0,1.0,False,0,False,1,False,False),
    ("Sleep Talk","Normal","Status",0,1.0,False,0,False,1,False,False),
    ("Stealth Rock","Rock","Status",0,1.0,False,0,False,1,False,False),
    ("Sandstorm","Rock","Status",0,1.0,False,0,False,1,False,False),
    ("Rain Dance","Water","Status",0,1.0,False,0,False,1,False,False),
    ("Endure","Normal","Status",0,1.0,False,4,False,1,False,False),
    ("Focus Energy","Normal","Status",0,1.0,False,0,False,1,False,False),
    ("Agility","Psychic","Status",0,1.0,False,0,False,1,False,False),
    ("Work Up","Normal","Status",0,1.0,False,0,False,1,False,False),
    ("Baton Pass","Normal","Status",0,1.0,False,0,False,1,False,False),
    ("Roar","Normal","Status",0,1.0,False,-6,False,1,False,False),
    ("Helping Hand","Normal","Status",0,1.0,False,5,False,1,False,False),

    # Misc (threat presets)
    ("Dragon Pulse","Dragon","Special",85,1.0,False,0,False,1,False,False),
    ("Focus Blast","Fighting","Special",120,0.7,False,0,False,1,False,False),
    ("Play Rough","Fairy","Physical",90,0.9,True,0,False,1,False,False),
    ("Ice Punch","Ice","Physical",75,1.0,True,0,True,1,False,False),
]

for _n,_t,_c,_p,_a,_ct,_pr,_ip,_mh,_ac,_ft in _missing_seed:
    _seed_move_if_absent(_n,_t,_c,_p,_a,contact=_ct,priority=_pr,is_punch=_ip,multi_hits=_mh,always_crit=_ac,first_turn_only=_ft)

# -----------------------------------------
# 2) Strict validation: no missing moves allowed
# -----------------------------------------
def _fail_on_missing_moves():
    required = set()
    # Trio pools
    for sp, pool in LEGAL_MOVES.items():
        required.update(pool)
    # Threat presets
    for lst in THREAT_PRESETS.values():
        for sb in lst:
            required.update(sb.moves)
    # Always present in DB?
    missing = sorted(m for m in required if m not in MOVE_DB)
    if missing:
        raise RuntimeError(f"[MOVE_DB] Missing definitions for {len(missing)} moves: {missing}")

_fail_on_missing_moves()

# -----------------------------------------
# 3) Per-moveset offense profiling & EV axes
# -----------------------------------------
def _moveset_offense_profile(moves: list[str]) -> tuple[int,int]:
    """Return (phys_bp, spec_bp) sum of base power over damaging moves in the set."""
    phys = 0
    spec = 0
    for m in moves:
        mv = MOVE_DB[m]
        if mv.category == "Physical":
            phys += max(0, base_power(mv))
        elif mv.category == "Special":
            spec += max(0, base_power(mv))
    return phys, spec

def axes_for_moveset(species: str, moves: list[str]) -> tuple[str, ...]:
    """Choose EV axes for this *exact* moveset."""
    phys_bp, spec_bp = _moveset_offense_profile(moves)
    # Strongly physical / special if >20% lead; else treat as mixed.
    if phys_bp >= spec_bp * 1.2 and phys_bp > 0:
        return ("HP","Atk","Def","Spe")
    if spec_bp >= phys_bp * 1.2 and spec_bp > 0:
        return ("HP","SpA","SpD","Spe")
    # Mixed: allow investing in both offenses; bulk goes to HP, speed always present
    return ("HP","Atk","SpA","Spe")

# -----------------------------------------
# 4) Enumerate candidates WITH per-moveset EV axes (drop-in replacement)
# -----------------------------------------
def enumerate_candidates_for_species(species: str) -> list["SetBuild"]:
    """Items/tera/natures/moves × (per-moveset EV Pareto using matchup-aware Spe pruning)."""
    spec = SPECIES_DATA[species]
    items = ITEM_CANDIDATES[species]
    teras = TERA_POOLS[species]
    pool = LEGAL_MOVES[species]
    ms_all = movesets_from_pool(pool, FOUR_PHYSICAL_ONLY[species], species)

    ivs31 = {k: 31 for k in ["HP","Atk","Def","SpA","SpD","Spe"]}

    # compact representative opp builds (first variant per threat)
    rep_opp: list["SetBuild"] = []
    seen = set()
    for t in THREAT_LIST:
        r = resolve_species_name(t) or t
        if r in seen: continue
        seen.add(r)
        av = adversary_variants(r)
        if av:
            builds, _w = av
            if builds:
                rep_opp.append(builds[0])
        if len(rep_opp) >= 12:
            break

    # Cache Pareto per (axes, nature, item) to avoid recomputing for every moveset
    pareto_cache: dict[tuple[tuple[str,...], str, str], list[dict[str,int]]] = {}

    cands: list["SetBuild"] = []
    for item in items:
        for tera in teras:
            if species == "Swampert":
                natures = ["Adamant", "Careful", "Impish", "Modest", "Calm", "Bold"]
            elif species == "Blaziken":
                natures = ["Jolly", "Adamant", "Naive", "Hasty"]
            else:  # Quaquaval
                natures = ["Jolly", "Adamant", "Naive", "Hasty"]
            for nature in natures:
                for mvset in ms_all:
                    if not filter_moveset_by_item(item, mvset):
                        continue
                    assert_legal_moves(species, mvset)
                    axes = axes_for_moveset(species, mvset)
                    key = (axes, nature, item)
                    if key not in pareto_cache:
                        pareto_cache[key] = iterate_evs_axes_matchup_aware(axes, species, nature, item, rep_opp)
                    for evs in pareto_cache[key]:
                        if not valid_evs(evs):
                            continue
                        cands.append(
                            SetBuild(
                                species=species,
                                item=item,
                                ability=spec.ability_hint,
                                tera_type=tera,
                                nature=nature,
                                evs=evs,
                                ivs=ivs31,
                                moves=mvset,
                            )
                        )
    return cands

# -----------------------------------------
# 5) Use the *same* per-moveset axes during local EV refinement
# -----------------------------------------
def _refine_with_moveset_axes(best_build: "SetBuild",
                              eval_fn: "Callable[[SetBuild], float]",
                              passes: int) -> "SetBuild":
    axes = axes_for_moveset(best_build.species, best_build.moves)
    return refine_evs_local(copy.deepcopy(best_build), eval_fn, axes, passes=passes)

# Monkey-patch build_search_for_species to refine with per-moveset axes
_old_build_search_for_species = build_search_for_species
def build_search_for_species(species: str, threats: List[str], conditioned_on: Optional[Dict[str, SetBuild]] = None):
    threats_variants = prebuild_threat_variants(threats)
    if not threats_variants:
        return None, {}
    candidates = enumerate_candidates_for_species(species)
    if not candidates:
        return None, {}

    best = None
    per_wr = {}
    max_workers = max(1, (os.cpu_count() or 1))

    if conditioned_on is None:
        # Solo objective — shortlist in parallel
        def solo_eval_fn(sb: SetBuild) -> float:
            wrs = []
            for name in threats:
                variants, weights = threats_variants[name]
                results = [simulate(sb, opp) for opp in variants]
                wrs.append(weighted_mean(results, weights))
            return sum(wrs) / len(wrs) if wrs else 0.0

        with ProcessPoolExecutor(max_workers=max_workers) as ex:
            futures = [ex.submit(eval_candidate_single, c, threats, threats_variants) for c in candidates]
            for fut in as_completed(futures):
                score, wrs, cand = fut.result()
                if (best is None) or (score > best[0]):
                    best = (score, wrs, cand)

        refined = _refine_with_moveset_axes(best[2], solo_eval_fn, passes=LOCAL_REFINE_PASSES)
        if refined.evs != best[2].evs:
            wrs = []
            for name in threats:
                variants, weights = threats_variants[name]
                results = [simulate(refined, opp) for opp in variants]
                wrs.append(weighted_mean(results, weights))
            best = (sum(wrs) / len(wrs) if wrs else 0.0, wrs, refined)

    else:
        # Trio-conditioned
        def trio_eval_fn(sb: SetBuild) -> float:
            trio = dict(conditioned_on); trio[species] = sb
            wrs = []
            for name in threats:
                variants, weights = threats_variants[name]
                per_variant = []
                for opp in variants:
                    ours = max(simulate(b, opp) for _, b in trio.items())
                    per_variant.append(ours)
                wrs.append(weighted_mean(per_variant, weights))
            return sum(wrs) / len(wrs) if wrs else 0.0

        best = None
        for c in candidates:
            score, wrs, cand = eval_candidate_trio(c, conditioned_on, threats, threats_variants)
            if (best is None) or (score > best[0]):
                best = (score, wrs, cand)

        refined = _refine_with_moveset_axes(best[2], trio_eval_fn, passes=LOCAL_REFINE_PASSES)
        if refined.evs != best[2].evs:
            wrs = []
            trio_fixed = dict(conditioned_on); trio_fixed[species] = refined
            for name in threats:
                variants, weights = threats_variants[name]
                per_variant = []
                for opp in variants:
                    ours = max(simulate(b, opp) for _, b in trio_fixed.items())
                    per_variant.append(ours)
                wrs.append(weighted_mean(per_variant, weights))
            best = (sum(wrs) / len(wrs) if wrs else 0.0, wrs, refined)

    if best is None:
        return None, {}
    per_wr = {threats[i]: best[1][i] for i in range(len(threats))}
    return best[2], per_wr

# -----------------------------------------
# 6) Bump banner so it's obvious at runtime
# -----------------------------------------
def _print_version_banner_v5_wrap():
    print("== SV 1v1 Optimizer — CPU only ==")
    print("Version:", "5.1 (per-moveset EV axes + strict MOVE_DB)")
    print("Notes: EV search respects each moveset’s offense type; missing moves now fail fast.")


_old_main_no_stub = main


def main():
    globals()["_print_version_banner"] = _print_version_banner_v5_wrap
    return _old_main_no_stub()

# === CRITICAL FIX PATCH — "Only Simulate What You Model" (v3.1.1) ================================
# GOAL:
#   Make the optimizer actually return the *true* best 1v1 builds by ensuring:
#   (1) We never include support/status moves whose effects are NOT implemented in the simulator.
#   (2) Every move we *do* include exists in MOVE_DB with correct basic parameters.
#   (3) EV axes & search remain intact; no silent stubs or broken moves.
#
# WHY THIS IS THE SINGLE MOST IMPORTANT FIX:
#   Your LEGAL_MOVES pools currently include many moves like Encore, Taunt, Yawn, Stealth Rock,
#   Rest, Sleep Talk, Substitute, etc. The simulator does not implement their effects. Including
#   them makes the search explore invalid/meaningless choices, corrupting results (and can also
#   crash when MOVE_DB entries are missing). This patch restricts each Pokémon’s legal pool to
#   damaging moves + the *few* status moves the engine actually models: Protect/Detect, Swords
#   Dance, Bulk Up, Counter, Mirror Coat. It also seeds missing moves in MOVE_DB (type/category/
#   power/accuracy/priority/contact) so enumeration never falls back to placeholders or fails.
#
# SOURCES (Gen 9 / SV learnsets):
#   - Swampert Gen9 learnset: https://pokemondb.net/pokedex/swampert/moves/9
#   - Blaziken Gen9 learnset: https://pokemondb.net/pokedex/blaziken/moves/9
#   - Quaquaval Gen9 learnset: https://pokemondb.net/pokedex/quaquaval/moves/9
# NOTES:
#   - Blaziken has *no egg moves* in SV; Quaquaval’s “Remember moves” include Counter; Swampert’s
#     “Remember moves” include Counter. (We include Counter only where it’s SV-legal.)
#   - We *exclude* moves with complex/unsupported mechanics (e.g., Yawn, Endeavor, Stealth Rock,
#     Rest/Sleep Talk/Substitute/Agility/Taunt/Encore/Curse, Bulldoze/Icy Wind/Rock Tomb’s stat
#     drops, Hydro Cannon/Giga Impact recharge). This keeps the search faithful to the simulator.
#   - If you decide to model any of those later, just add them to MOVE_DB (+ their effects) and
#     append them to the LEGAL_MOVES pools below.
#
# HOW TO APPLY:
#   Paste this entire block near the end of your file (after existing definitions). Python’s
#   late-bound names will override earlier ones. Run as usual.
# ================================================================================================

# 0) Helper: add moves only if missing (no silent stubs)
def _ensure_move(name, mtype, category, power=0, accuracy=1.0, *, contact=False, priority=0,
                 is_punch=False, is_slicing=False, multi_hits=1, always_crit=False):
    if name in MOVE_DB:
        return
    MOVE_DB[name] = Move(
        name=name, mtype=mtype, category=category, power=power, accuracy=accuracy,
        contact=contact, priority=priority, is_punch=is_punch, multi_hits=multi_hits,
        always_crit=always_crit, is_tera_blast=(name == "Tera Blast")
    )
    if is_slicing:
        object.__setattr__(MOVE_DB[name], "is_slicing", True)

# 1) Implement/flag the ONLY status we newly allow: Bulk Up (+1 Atk, +1 Def)
if "Bulk Up" not in MOVE_DB:
    MOVE_DB["Bulk Up"] = Move("Bulk Up", "Fighting", "Status", 0, 1.0)
# add a simple flag so do_status_action can spot it
if not hasattr(MOVE_DB["Bulk Up"], "is_bulk_up"):
    object.__setattr__(MOVE_DB["Bulk Up"], "is_bulk_up", True)

# 2) Extend do_status_action to actually handle Bulk Up
if "do_status_action" in globals():
    _orig_do_status_action = do_status_action
    def do_status_action(mv: Move, self_state: BattleState):
        if getattr(mv, "is_bulk_up", False):
            self_state.stages["Atk"] = min(6, self_state.stages["Atk"] + 1)
            self_state.stages["Def"] = min(6, self_state.stages["Def"] + 1)
            return
        return _orig_do_status_action(mv, self_state)

# 3) Seed all *commonly used* SV-legal attacking/status moves for the trio if missing
#    (We keep to simple mechanics; no tricky secondary effects/stat drops/recharge moves.)
# --- Shared & utility ---
_ensure_move("Protect", "Normal", "Status")
_ensure_move("Detect", "Normal", "Status")
_ensure_move("Swords Dance", "Normal", "Status")  # already present above, ensure anyway
_ensure_move("Counter", "Fighting", "Physical", 0, 1.0)       # special behavior already modeled
_ensure_move("Mirror Coat", "Psychic", "Special", 0, 1.0)     # special behavior already modeled
# --- Water-line (Swampert/Quaquaval) ---
_ensure_move("Waterfall", "Water", "Physical", 80, 1.0, contact=True)
_ensure_move("Liquidation", "Water", "Physical", 85, 1.0, contact=True)
_ensure_move("Surf", "Water", "Special", 90, 1.0)
_ensure_move("Hydro Pump", "Water", "Special", 110, 0.8)
_ensure_move("Aqua Jet", "Water", "Physical", 40, 1.0, contact=True, priority=1)
_ensure_move("Aqua Cutter", "Water", "Physical", 70, 1.0, contact=True)
_ensure_move("Aqua Step", "Water", "Physical", 80, 1.0, contact=True)  # speed boost handled elsewhere
# --- Ground-line (Swampert) ---
_ensure_move("Earthquake", "Ground", "Physical", 100, 1.0)
_ensure_move("High Horsepower", "Ground", "Physical", 95, 0.95, contact=True)
_ensure_move("Stomping Tantrum", "Ground", "Physical", 75, 1.0, contact=True)
_ensure_move("Dig", "Ground", "Physical", 80, 1.0, contact=True)  # we treat as simple hit (no semi-inv)
_ensure_move("Mud Shot", "Ground", "Special", 55, 0.95)
# --- Ice-line (both) ---
_ensure_move("Ice Punch", "Ice", "Physical", 75, 1.0, contact=True, is_punch=True)
_ensure_move("Ice Beam", "Ice", "Special", 90, 1.0)
_ensure_move("Ice Spinner", "Ice", "Physical", 80, 1.0, contact=True)
# --- Rock-line (both) ---
_ensure_move("Rock Slide", "Rock", "Physical", 75, 0.9)
_ensure_move("Stone Edge", "Rock", "Physical", 100, 0.8)
# --- Fighting-line (Blaziken/Quaquaval) ---
_ensure_move("Close Combat", "Fighting", "Physical", 120, 1.0, contact=True)
_ensure_move("Drain Punch", "Fighting", "Physical", 75, 1.0, contact=True)  # we ignore healing; safe to include or omit
_ensure_move("Low Kick", "Fighting", "Physical", 0, 1.0, contact=True)     # variable power not modeled -> exclude from pools below
_ensure_move("Low Sweep", "Fighting", "Physical", 65, 1.0, contact=True)   # speed drop not modeled -> exclude from pools below
_ensure_move("Brick Break", "Fighting", "Physical", 75, 1.0, contact=True)
_ensure_move("Reversal", "Fighting", "Physical", 0, 1.0, contact=True)     # variable power -> exclude from pools below
_ensure_move("Body Press", "Fighting", "Physical", 80, 1.0, contact=True)
# --- Fire-line (Blaziken) ---
_ensure_move("Flare Blitz", "Fire", "Physical", 120, 1.0, contact=True)
_ensure_move("Blaze Kick", "Fire", "Physical", 85, 0.9, contact=True)
_ensure_move("Flamethrower", "Fire", "Special", 90, 1.0)
_ensure_move("Fire Punch", "Fire", "Physical", 75, 1.0, contact=True, is_punch=True)
_ensure_move("Fire Blast", "Fire", "Special", 110, 0.85)
# --- Flying-line (Blaziken/Quaquaval) ---
_ensure_move("Brave Bird", "Flying", "Physical", 120, 1.0, contact=True)
_ensure_move("Aerial Ace", "Flying", "Physical", 60, 1.0)  # no-miss implicitly
_ensure_move("Acrobatics", "Flying", "Physical", 55, 1.0)  # we do not model itemless boost; ok baseline
# --- Dark/Ghost/Normal utility attacks (coverage) ---
_ensure_move("Knock Off", "Dark", "Physical", 65, 1.0, contact=True)  # no item-strip effect modeled
_ensure_move("Shadow Claw", "Ghost", "Physical", 70, 1.0, contact=True)
_ensure_move("Thief", "Dark", "Physical", 60, 1.0, contact=True)
_ensure_move("Facade", "Normal", "Physical", 70, 1.0, contact=True)
_ensure_move("Hyper Voice", "Normal", "Special", 90, 1.0)
# --- Electric/Psychic punches, etc. ---
_ensure_move("Thunder Punch", "Electric", "Physical", 75, 1.0, contact=True, is_punch=True)
_ensure_move("Zen Headbutt", "Psychic", "Physical", 80, 0.9, contact=True)
# --- Grass/simple coverage where used ---
_ensure_move("Trailblaze", "Grass", "Physical", 50, 1.0, contact=True)     # speed boost ignored (not modeled); exclude from pools
_ensure_move("Energy Ball", "Grass", "Special", 90, 1.0)

# Recoil table for newly ensured recoil moves
RECOIL_RATIO.update({"Flare Blitz": 1/3, "Brave Bird": 1/3, "Wild Charge": 1/4})

# 4) Restrict LEGAL_MOVES to *only* moves with modeled mechanics (damaging + the supported status)
#    We deliberately EXCLUDE: Yawn/Encore/Taunt/Stealth Rock/Rest/Sleep Talk/Substitute/Agility/
#    Baton Pass/Roar/Endeavor/Low Kick/Reversal/Trailblaze/Bulldoze/Rock Tomb/Icy Wind/etc.
#    (Add back later ONLY if you implement their effects fully.)
SV_MOVES_SWAMPERT_OPTIMIZER = sorted(set([
    # Water
    "Aqua Jet","Aqua Tail","Hydro Pump","Liquidation","Surf","Waterfall",
    # Ground / Rock
    "Earthquake","High Horsepower","Stomping Tantrum","Rock Slide","Stone Edge","Dig",
    # Ice
    "Ice Beam","Ice Punch","Ice Spinner",
    # Steel / Normal / Dark / Psychic / Grass
    "Flash Cannon","Facade","Hyper Voice","Knock Off","Zen Headbutt","Energy Ball",
    # Utility (supported)
    "Protect","Detect","Swords Dance","Counter","Mirror Coat",
    # Tera
    "Tera Blast",
]))

SV_MOVES_BLAZIKEN_OPTIMIZER = sorted(set([
    # Fire
    "Blaze Kick","Fire Punch","Flamethrower","Fire Blast","Flare Blitz",
    # Fighting
    "Close Combat","Brick Break","Drain Punch","Body Press",  # (Low Kick/Reversal excluded)
    # Flying
    "Brave Bird","Aerial Ace","Acrobatics",
    # Dark / Ghost / Ground / Rock / Electric / Psychic / Normal
    "Knock Off","Shadow Claw","Earthquake","Rock Slide","Stone Edge","Thunder Punch","Zen Headbutt","Facade","Hyper Voice",
    # Utility (supported)
    "Protect","Detect","Swords Dance","Bulk Up",              # (Counter/Mirror Coat NOT SV-legal for Blaziken in Gen9)
    # Tera
    "Tera Blast",
]))

SV_MOVES_QUAQUAVAL_OPTIMIZER = sorted(set([
    # Water
    "Aqua Step","Aqua Cutter","Aqua Jet","Liquidation","Waterfall","Surf","Hydro Pump","Flip Turn",
    # Fighting
    "Close Combat","Drain Punch","Brick Break","Body Press","Counter",   # Counter is SV-legal via “Remember moves”
    # Flying
    "Brave Bird","Acrobatics","Aerial Ace",
    # Ice
    "Ice Spinner","Ice Beam",
    # Dark / Bug / Grass / Ground / Rock / Electric / Psychic / Normal
    "Knock Off","U-turn","Pounce","Trailblaze",  # Trailblaze boost not modeled -> we will exclude it in the generator below
    "Bulldoze","Rock Slide","Stone Edge","Thunder Punch","Zen Headbutt","Facade","Hyper Voice",
    # Utility (supported)
    "Protect","Detect","Swords Dance","Bulk Up",
    # Tera
    "Tera Blast",
]))

# 5) Publish the new legal pool map
LEGAL_MOVES = {
    "Swampert": SV_MOVES_SWAMPERT_OPTIMIZER,
    "Blaziken": SV_MOVES_BLAZIKEN_OPTIMIZER,
    "Quaquaval": SV_MOVES_QUAQUAVAL_OPTIMIZER,
}

# 6) Keep all-three as mixed-capable (so we don’t force physical-only)
FOUR_PHYSICAL_ONLY = {k: False for k in LEGAL_MOVES}

# 7) Safeguard: hard assert that every referenced move exists in MOVE_DB (no silent stubs)
def _assert_all_legal_moves_have_defs():
    missing = set()
    for sp, moves in LEGAL_MOVES.items():
        for m in moves:
            if m not in MOVE_DB:
                missing.add(m)
    # also include threat preset moves (if any present) to avoid runtime gaps
    if "THREAT_PRESETS" in globals():
        for variants in THREAT_PRESETS.values():
            for sb in variants:
                for m in sb.moves:
                    if m not in MOVE_DB:
                        missing.add(m)
    if missing:
        raise RuntimeError(f"[FATAL] Missing MOVE_DB definitions for: {sorted(missing)}\n"
                           f"Add each via _ensure_move(...) with correct type/category/power/accuracy.")
_assert_all_legal_moves_have_defs()

# 8) Filter out moves whose special mechanics we don’t simulate (variable power or core secondary stat drops)
#    We’ll do this at *generation* time so they don’t even get considered.
#    (You can loosen this if/when you implement those mechanics.)
_EXCLUDE_FROM_ENUM = {
    # Variable power / depends on weight/HP
    "Low Kick","Reversal",
    # Stat-drop / boost we do NOT model
    "Icy Wind","Bulldoze","Rock Tomb","Trailblaze",
    # Recharge / semi-inv / hazards / sleep / phazing / pass
    "Hydro Cannon","Giga Impact","Fly","Stealth Rock","Yawn","Rest","Sleep Talk","Substitute","Taunt","Encore","Agility","Baton Pass","Roar","Endeavor","Curse",
}

# Wrap the existing movesets_from_pool to auto-exclude unsupported moves up-front
if "movesets_from_pool" in globals():
    _orig_movesets_from_pool = movesets_from_pool
    def movesets_from_pool(pool: list[str], four_physical_only: bool, species: str) -> list[list[str]]:
        clean = [m for m in pool if m not in _EXCLUDE_FROM_ENUM]
        return _orig_movesets_from_pool(clean, four_physical_only, species)

# 9) Keep status pruning consistent with what we actually support
#    (One protect-like, at most one setup [SD or Bulk Up], Counter/MirrorCoat ok.)
if "movesets_from_pool" in globals():
    # No further change needed to your dominance/coverage pruning — it already ignores Status in coverage
    pass

# 10) Optional: tiny EV-axes tweak — if a moveset is *pure Special* or *pure Physical*, prefer the matching bulk axis.
#     (If you already choose axes by base stats, this improves fidelity for mixed options.)
def _moveset_category_signature(moves: list[str]) -> tuple[bool,bool]:
    has_phys, has_spec = False, False
    for m in moves:
        mv = MOVE_DB[m]
        if mv.category == "Physical": has_phys = True
        elif mv.category == "Special": has_spec = True
    return has_phys, has_spec

if "enumerate_candidates_for_species" in globals():
    _orig_enumerate_candidates_for_species = enumerate_candidates_for_species
    def enumerate_candidates_for_species(species: str) -> list["SetBuild"]:
        cands = []
        spec = SPECIES_DATA[species]
        items = ITEM_CANDIDATES[species]
        teras = TERA_POOLS[species]
        pool = LEGAL_MOVES[species]
        ms_all = movesets_from_pool(pool, FOUR_PHYSICAL_ONLY[species], species)
        ivs31 = {k: 31 for k in ["HP","Atk","Def","SpA","SpD","Spe"]}

        # compact representative opp builds (unchanged)
        rep_opp = []
        seen = set()
        for t in THREAT_LIST:
            r = resolve_species_name(t) or t
            if r in seen: continue
            seen.add(r)
            av = adversary_variants(r)
            if av:
                builds, _w = av
                if builds: rep_opp.append(builds[0])
            if len(rep_opp) >= 12:
                break

        for item in items:
            for tera in teras:
                # keep your species-specific nature pools
                if species == "Swampert":
                    natures = ["Adamant", "Careful", "Impish", "Jolly", "Modest"]  # allow mild mixing
                elif species == "Blaziken":
                    natures = ["Jolly", "Adamant", "Naive", "Hasty"]
                else:
                    natures = ["Jolly", "Adamant", "Naive", "Hasty"]

                for nature in natures:
                    for mv in ms_all:
                        # skip movesets with unsupported Status after Choice or AV rules
                        if not filter_moveset_by_item(item, mv):
                            continue
                        # dynamic EV axes by *moveset* composition
                        has_phys, has_spec = _moveset_category_signature(mv)
                        if has_phys and not has_spec:
                            ev_axes = ("HP","Atk","Def","Spe")
                        elif has_spec and not has_phys:
                            ev_axes = ("HP","SpA","SpD","Spe")
                        else:
                            # mixed: bias bulk to likely defense the species uses most, keep Spe
                            ev_axes = ("HP","Atk","SpA","Spe")

                        ev_pareto = iterate_evs_axes_matchup_aware(ev_axes, species, nature, item, rep_opp)
                        for evs in ev_pareto:
                            if not valid_evs(evs): continue
                            cands.append(
                                SetBuild(
                                    species=species,
                                    item=item,
                                    ability=spec.ability_hint,
                                    tera_type=tera,
                                    nature=nature,
                                    evs=evs,
                                    ivs=ivs31,
                                    moves=mv,
                                )
                            )
        return cands

# 11) Bump banner
def _print_version_banner():
    print("== SV 1v1 Optimizer — CPU only ==")
    print("Version:", "3.1.1")
    print("Note: 3.1.1 restricts movepools to modeled mechanics, seeds missing moves, "
          "and picks EV axes per *moveset* for accuracy.")

# 12) Final sanity check prints (optional)
if __name__ == "__main__":
    # Print one line summaries so you can confirm pools aren’t empty
    for _sp in ["Swampert","Blaziken","Quaquaval"]:
        print(f"[Pool] {_sp}: {len(LEGAL_MOVES[_sp])} moves; sample:", LEGAL_MOVES[_sp][:10])
    # also assert move defs exist (already runs at import)
    pass
# =================================================================================================
