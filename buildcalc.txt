#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
SV 1v1 (L100) PERFECT-BUILD OPTIMIZER — CPU-ONLY, SINGLE FILE
Version: 3.0.1 (Gen9-lite mechanics with optimal-play & stochastic branching, Py3.9+)
Author: ChatGPT (single-file, no web, no external deps)

WHAT'S NEW (3.0.1 over 3.0.0)
-----------------------------
- FIX: Grounded check now uses current defensive typing (post-Tera) so Electric Terrain
  boosts apply correctly when Flying is lost (or gained) via Terastallization.
- FIX: Tera Blast category now switches to Physical/Special ONLY when Terastallized,
  using the higher of Atk vs SpA; otherwise it remains Normal/Special.
- Minor internal cleanups; mechanics & scoring unchanged.

WHAT'S NEW (3.0.0 over 2.2.1)
-----------------------------
- CORE: True stochastic rules. We branch on hit/miss (and always-crit where relevant) instead of
  multiplying by accuracy. All thresholded effects (Focus Sash, Sturdy, Sitrus, Weakness Policy,
  recoil, Multiscale) now fire on actual hits only.
- ENDING: Official 1v1 sudden-death: after EXACTLY 3 full turns (or earlier KOs), higher %HP wins;
  equal is a tie. No heuristic horizon eval.
- FIELDS: Sun and Electric Terrain now boost move power properly (Sun: Fire×1.5, Water×0.5;
  Electric Terrain: grounded Electric×1.3). “Grounded” approximated by current defensive typing.
- TERA: Tera timing is applied before acting; STAB rules consistent for non–Tera Blast moves.
- CHOICE LOCK: Runtime enforcement—once locked, only that move remains (no status/counter/coat).
- SCORING: Mean P(win) vs each threat’s variant mix (equal weights by default) instead of worst-case.
  Trio metric uses best-of-three vs a threat’s variant mixture.
- SEARCH: SEARCH_TURNS is now 3 by default (full 1v1 window). EV refine runs on top candidates.

USAGE
-----
$ python sv1v1_optimizer.py
- Tune speed/quality: EV_STEPS, SEARCH_TURNS (keep 3 for faithful 1v1), THREAT_LIST.
- No dependencies. Deterministic given the code (stochastic is computed exactly by branching).

LICENSE
-------
Public domain (as-is). No warranty.
"""

import copy
import itertools
import math
import os
import time
from collections import defaultdict
from concurrent.futures import ProcessPoolExecutor, as_completed
from dataclasses import dataclass, field
from functools import lru_cache
from typing import Callable, Dict, List, Optional, Tuple, Union

from math import floor

# Canonical Gen 3+ damage roll distribution: uniform over 16 integers (85..100)
ROLL_TABLE: tuple[float, ...] = tuple(r / 100.0 for r in range(85, 101))  # 0.85..1.00
ROLL_PROB: float = 1.0 / 16.0


def _packed_state_signature(build: "SetBuild", st: "BattleState") -> tuple:
    """Compact signature used to merge equivalent branches after damage roll expansion."""

    return (
        st.hp,
        st.max_hp,
        st.stages["Atk"],
        st.stages["Def"],
        st.stages["SpA"],
        st.stages["SpD"],
        st.stages["Spe"],
        st.sash_intact,
        st.sturdy_intact,
        st.tera_used,
        st.tera_type,
        bool(st.ability_active.get("Protect", False)),
        st.locked_move,
        st.multiscale_on,
        tuple(sorted(k for k, v in st.consumed_item.items() if v)),
    )


def _merge_branch_states(
    branches: list[tuple[float, "BattleState", "BattleState"]]
) -> list[tuple[float, "BattleState", "BattleState"]]:
    """Merge branches that are state-equivalent to control branching growth."""

    merged: dict[tuple, tuple[float, "BattleState", "BattleState"]] = {}
    for p, A, B in branches:
        sig = (_packed_state_signature(None, A), _packed_state_signature(None, B))
        if sig in merged:
            oldp, oldA, oldB = merged[sig]
            merged[sig] = (oldp + p, A, B)
        else:
            merged[sig] = (p, A, B)
    return list(merged.values())

# ===== EV SEARCH — FULL GRID + MATCHUP-AWARE SPEED TIERS + PARETO + LOCAL REFINEMENT =============

EV_STEPS = list(range(0, 253, 4))  # 0..252 in legal 4-EV increments
EV_TOTAL_MAX = 510                 # keep in sync with the rest of your code


def _nature_mult(nat: str, stat: str) -> float:
    up, down = NATURES.get(nat, (None, None))
    if up == stat:
        return 1.1
    if down == stat:
        return 0.9
    return 1.0


def _spe_after_mod(base_stats: dict, nature: str, ev: int, iv: int, item: str, stages: int, pq_speed_mult: float) -> float:
    raw = floor(((2 * base_stats["Spe"] + iv + ev // 4) * 100) / 100) + 5
    raw = floor(raw * _nature_mult(nature, "Spe"))
    scarf = 1.5 if item == "Choice Scarf" else 1.0
    s = max(-6, min(6, stages))
    stage_m = (2 + s) / 2 if s >= 0 else 2 / (2 - s)
    return raw * scarf * stage_m * pq_speed_mult


def _speed_targets_for(attacker_species: str, attacker_item: str, attacker_nature: str, opp_builds: list["SetBuild"]) -> list[int]:
    """Derive realistic Speed targets to prune Spe EVs to meaningful breakpoints."""
    iv31 = 31
    ability = SPECIES_DATA[attacker_species].ability_hint
    pq_candidates = (1.0, 1.3) if ability in ("Protosynthesis", "Quark Drive") else (1.0,)
    plus_one_possible = (ability == "Speed Boost") or (attacker_species == "Quaquaval")  # Aqua Step

    # rough upper-bound opponent speeds (fast nature 252 & neutral 252)
    targets = set()
    for ob in (opp_builds or []):
        ob_spec = SPECIES_DATA[ob.species]
        ob_fast = _spe_after_mod(ob_spec.base, "Jolly", 252, iv31, "", 0, 1.0)
        ob_neut = _spe_after_mod(ob_spec.base, "Adamant", 252, iv31, "", 0, 1.0)
        for b in (ob_fast, ob_neut):
            for margin in (0, 1, 2):
                targets.add(int(b) + margin)

    if plus_one_possible:
        targets |= {t + 1 for t in list(targets)}

    for pqm in pq_candidates:
        for t in list(targets):
            targets.add(int(t * pqm))

    if not targets:
        return EV_STEPS.copy()

    cand = {0, 252}
    for pqm in pq_candidates:
        for stg in ((0, 1) if plus_one_possible else (0,)):
            for tgt in sorted(targets):
                chosen = None
                for ev in EV_STEPS:
                    eff = _spe_after_mod(SPECIES_DATA[attacker_species].base, attacker_nature, ev, iv31, attacker_item, stg, pqm)
                    if eff >= tgt:
                        chosen = ev
                        break
                if chosen is not None:
                    cand.add(chosen)
                    if chosen >= 4:
                        cand.add(chosen - 4)
    return sorted(cand)


def _proxy_tuple(spec: "Species", nature: str, evs: dict[str, int]) -> tuple[int, int, int, int, int]:
    """Cheap dominance proxy over atk-like, spa-like, bulk (HP*Def, HP*SpD), and Speed."""
    ivs = {"HP": 31, "Atk": 31, "Def": 31, "SpA": 31, "SpD": 31, "Spe": 31}
    st = calc_stats(spec, nature, evs, ivs)
    return (st["Atk"], st["SpA"], st["HP"] * st["Def"], st["HP"] * st["SpD"], st["Spe"])


def iterate_evs_axes_matchup_aware(
    axes: tuple[str, ...],
    species: str,
    nature: str,
    item: str,
    opp_builds: list["SetBuild"],
) -> list[dict[str, int]]:
    """Enumerate legal EVs with matchup-aware Spe pruning and Pareto filtering."""
    spec = SPECIES_DATA[species]
    spe_values = _speed_targets_for(species, item, nature, opp_builds) if "Spe" in axes else []
    grid_per_axis = [spe_values if (a == "Spe" and spe_values) else EV_STEPS for a in axes]

    def _valid(e: dict[str, int]) -> bool:
        return sum(e.values()) <= EV_TOTAL_MAX and all((v % 4) == 0 and v <= 252 for v in e.values())

    pareto: list[tuple[tuple[int, int, int, int, int], int, dict[str, int]]] = []
    for vals in itertools.product(*grid_per_axis):
        e = {ax: vals[i] for i, ax in enumerate(axes)}
        for k in ("HP","Atk","Def","SpA","SpD","Spe"):
            e.setdefault(k, 0)
        if not _valid(e):
            continue
        key = _proxy_tuple(spec, nature, e)

        dominated = False
        to_remove: list[int] = []
        for idx, (ok, _, _) in enumerate(pareto):
            ge_all = all(k >= o for k, o in zip(key, ok))
            gt_any = any(k > o for k, o in zip(key, ok))
            le_all = all(k <= o for k, o in zip(key, ok))
            lt_any = any(k < o for k, o in zip(key, ok))
            if ge_all and gt_any:
                to_remove.append(idx)  # new dominates old
            elif le_all and lt_any:
                dominated = True       # old dominates new
                break
        if dominated:
            continue
        for j in reversed(to_remove):
            pareto.pop(j)
        pareto.append((key, sum(e.values()), e))
    return [e for _, _, e in pareto]


def refine_evs_local(
    base: "SetBuild",
    eval_fn: Callable[["SetBuild"], float],
    axes: tuple[str, ...],
    passes: int = 128,
) -> "SetBuild":
    """Exact hill-climb over 4-EV swaps among the chosen axes scored by the true simulator."""
    best = copy.deepcopy(base)
    best_score = eval_fn(best)
    tabu: set[tuple[int, int, int, int, int, int]] = set()

    def pack(ev: dict[str, int]) -> tuple[int, int, int, int, int, int]:
        return (ev["HP"], ev["Atk"], ev["Def"], ev["SpA"], ev["SpD"], ev["Spe"])

    step = 4
    for _ in range(passes):
        improved = False
        cur = best.evs
        tabu.add(pack(cur))
        for i in range(len(axes)):
            for j in range(len(axes)):
                if i == j: continue
                a, b = axes[i], axes[j]
                if cur[b] < step or cur[a] > 248:  # bounds
                    continue
                cand_evs = dict(cur)
                cand_evs[a] += step
                cand_evs[b] -= step
                if sum(cand_evs.values()) > EV_TOTAL_MAX:
                    continue
                key = pack(cand_evs)
                if key in tabu:
                    continue
                cand = copy.deepcopy(best)
                cand.evs = cand_evs
                score = eval_fn(cand)
                if score > best_score + 1e-12:
                    best, best_score, improved = cand, score, True
                    break
            if improved: break
        if not improved:
            break
    return best


def enumerate_candidates_for_species(species: str) -> list["SetBuild"]:
    """Items/tera/natures/moves × (matchup-aware EV Pareto)."""
    spec = SPECIES_DATA[species]
    items = ITEM_CANDIDATES[species]
    teras = TERA_POOLS[species]
    pool = LEGAL_MOVES[species]
    ms_all = movesets_from_pool(pool, FOUR_PHYSICAL_ONLY[species], species)

    ev_axes = ("HP","Atk","Def","Spe") if spec.base["Atk"] >= spec.base["SpA"] else ("HP","SpA","SpD","Spe")
    ivs31 = {k: 31 for k in ["HP","Atk","Def","SpA","SpD","Spe"]}

    # compact representative opp builds (first variant per threat)
    rep_opp: list["SetBuild"] = []
    seen = set()
    for t in THREAT_LIST:
        r = resolve_species_name(t) or t
        if r in seen: continue
        seen.add(r)
        av = adversary_variants(r)
        if av:
            builds, _w = av
            if builds:
                rep_opp.append(builds[0])
        if len(rep_opp) >= 12:
            break

    cands: list["SetBuild"] = []
    for item in items:
        for tera in teras:
            if species == "Swampert":
                natures = ["Adamant", "Careful", "Impish"]
            elif species == "Blaziken":
                natures = ["Jolly", "Adamant"]
            else:
                natures = ["Jolly", "Adamant"]
            for nature in natures:
                ev_pareto = iterate_evs_axes_matchup_aware(ev_axes, species, nature, item, rep_opp)
                for evs in ev_pareto:
                    if not valid_evs(evs):
                        continue
                    for mv in ms_all:
                        if not filter_moveset_by_item(item, mv):
                            continue
                        assert_legal_moves(species, mv)
                        cands.append(
                            SetBuild(
                                species=species,
                                item=item,
                                ability=spec.ability_hint,
                                tera_type=tera,
                                nature=nature,
                                evs=evs,
                                ivs=ivs31,
                                moves=mv,
                            )
                        )
    return cands

# ===== MOVE REGISTRY HELPERS (add missing moves with sensible defaults; no duplicates) ============

def _add_if_missing(
    name: str,
    mtype: str,
    category: str,         # "Physical" | "Special" | "Status"
    power: int = 0,
    accuracy: float = 1.0,
    *,
    contact: bool = False,
    priority: int = 0,
    is_punch: bool = False,
    is_slicing: bool = False,
    multi_hits: int = 1,
    always_crit: bool = False,
):
    if name in MOVE_DB:
        return
    MOVE_DB[name] = Move(
        name=name,
        mtype=mtype,
        category=category,
        power=power,
        accuracy=accuracy,
        contact=contact,
        priority=priority,
        is_punch=is_punch,
        multi_hits=multi_hits,
        always_crit=always_crit,
        is_tera_blast=(name == "Tera Blast"),
    )
    if is_slicing:
        object.__setattr__(MOVE_DB[name], "is_slicing", True)

# Priority / staples / signatures likely encountered in threats or trio movepools
for __mv in [
    ("Extreme Speed","Normal","Physical",80,1.0,True,2,False,False,1,False),
    ("Bullet Punch","Steel","Physical",40,1.0,True,1,False,False,1,False),
    ("Mach Punch","Fighting","Physical",40,1.0,True,1,False,False,1,False),
    ("Aqua Jet","Water","Physical",40,1.0,True,1,False,False,1,False),
    ("Ice Shard","Ice","Physical",40,1.0,False,1,False,False,1,False),
    ("Kowtow Cleave","Dark","Physical",85,1.0,True,0,False,False,1,False),
    ("Make It Rain","Steel","Special",120,0.9,False,0,False,False,1,False),
    ("Salt Cure","Rock","Physical",40,1.0,False,0,False,False,1,False),
    ("Torch Song","Fire","Special",80,1.0,False,0,False,False,1,False),
    ("Fiery Wrath","Dark","Special",90,1.0,False,0,False,False,1,False),
    ("Ivy Cudgel","Grass","Physical",100,1.0,True,0,False,False,1,False),
    ("Hydro Steam","Water","Special",80,1.0,False,0,False,False,1,False),
    ("Wicked Blow","Dark","Physical",80,1.0,True,0,False,False,1,True),
    ("Surging Strikes","Water","Physical",25,1.0,True,0,False,False,3,True),
    ("Flower Trick","Grass","Physical",70,1.0,True,0,False,False,1,True),
    ("Icicle Crash","Ice","Physical",85,0.9,True,0,False,False,1,False),
    ("Sacred Sword","Fighting","Physical",90,1.0,True,0,False,False,1,False),
    ("Spirit Break","Fairy","Physical",75,1.0,True,0,False,False,1,False),
    ("Blood Moon","Normal","Special",140,0.9,False,0,False,False,1,False),
    ("Steam Eruption","Water","Special",110,0.95,False,0,False,False,1,False),
    ("Tachyon Cutter","Steel","Special",50,1.0,False,0,False,False,1,False),
    ("Draining Kiss","Fairy","Special",50,1.0,False,0,False,False,1,False),
    ("Hyper Voice","Normal","Special",90,1.0,False,0,False,False,1,False),
    ("Mystical Fire","Fire","Special",75,1.0,False,0,False,False,1,False),
    ("Freeze-Dry","Ice","Special",70,1.0,False,0,False,False,1,False),
    ("Flip Turn","Water","Physical",60,1.0,True,0,False,False,1,False),
]:
    _add_if_missing(*__mv)

RECOIL_RATIO.update({"Flare Blitz": 1/3, "Brave Bird": 1/3, "Wild Charge": 1/4, "Wave Crash": 1/3})

# ===== TRIO MOVEPOOLS (SV-legal; level/TM/egg/move tutor remembered in SV) =======================

SV_MOVES_SWAMPERT = sorted(set([
    # Water
    "Aqua Jet","Aqua Tail","Chilling Water","Hydro Pump","Hydro Cannon","Liquidation","Rain Dance","Surf","Waterfall",
    # Ground / Rock
    "Bulldoze","Dig","Earthquake","High Horsepower","Mud Shot","Rock Slide","Rock Tomb","Sandstorm","Stealth Rock","Stone Edge","Stomping Tantrum",
    # Ice
    "Avalanche","Ice Beam","Ice Fang","Ice Punch","Ice Spinner","Icy Wind",
    # Steel / Normal
    "Flash Cannon","Facade","Double-Edge","Giga Impact","Hyper Beam","Endeavor",
    # Utility / Status
    "Protect","Detect","Substitute","Yawn","Curse","Rest","Sleep Talk",
    # Coverage / Misc
    "Brick Break","Body Press","Counter","Low Kick","Low Sweep","Power-Up Punch",
    "Trailblaze","Energy Ball",  # Grass coverage via TM
    "Rock Blast","Iron Head","Knock Off","Thief","Shadow Claw","Zen Headbutt","Psychic","Psyshock",
    # Electric (limited punches/TM)
    "Thunder Punch","Wild Charge",
    # Flying / Bug (rare TMs)
    "Aerial Ace","U-turn",
    # Tera
    "Tera Blast",
]))

SV_MOVES_BLAZIKEN = sorted(set([
    # Fire
    "Blaze Kick","Fire Punch","Flame Charge","Flamethrower","Fire Blast","Overheat","Heat Wave","Flare Blitz","Sunny Day","Fire Spin",
    # Fighting
    "Close Combat","Low Kick","Low Sweep","Reversal","Brick Break","Drain Punch","Bulk Up","Counter","Body Press","Vacuum Wave",
    # Flying
    "Brave Bird","Aerial Ace","Bounce","Acrobatics",
    # Dark / Ghost
    "Knock Off","Night Slash","Thief","Sucker Punch","Shadow Claw",
    # Ground / Rock
    "Bulldoze","Dig","Earthquake","Rock Slide","Rock Tomb","Stone Edge","Stomping Tantrum",
    # Electric / Psychic / Poison
    "Thunder Punch","Zen Headbutt","Poison Jab",
    # Normal / Utility
    "Quick Attack","Giga Impact","Hyper Beam","Facade","Endure","Protect","Detect","Substitute","Focus Energy","Agility","Taunt","Encore","Sunny Day","Rest","Sleep Talk","Work Up","Baton Pass","Roar",
    # Bug / Grass
    "U-turn","Pounce","Trailblaze","Leech Life",
    # Water (niche TM)
    "Rain Dance",
    # Tera
    "Tera Blast",
]))

SV_MOVES_QUAQUAVAL = sorted(set([
    # Signature / Water
    "Aqua Step","Aqua Cutter","Aqua Jet","Liquidation","Waterfall","Flip Turn","Surf","Hydro Pump","Hydro Cannon","Chilling Water","Rain Dance",
    # Fighting
    "Close Combat","Drain Punch","Brick Break","Low Kick","Low Sweep","Reversal","Bulk Up","Body Press","Counter",
    # Flying
    "Brave Bird","Acrobatics","Aerial Ace","Air Slash","Hurricane",
    # Ice
    "Ice Spinner","Avalanche","Icy Wind","Ice Beam",
    # Dark / Bug / Grass
    "Knock Off","U-turn","Pounce","Trailblaze",
    # Utility / Normal
    "Protect","Detect","Encore","Taunt","Substitute","Rest","Sleep Talk","Giga Impact","Hyper Beam","Facade","Endure","Helping Hand",
    # Ground / Rock (TMs)
    "Bulldoze","Rock Slide","Rock Tomb","Stone Edge",
    # Electric / Psychic (limited TMs)
    "Thunder Punch","Zen Headbutt",
    # Tera
    "Tera Blast",
]))

# Ensure every referenced move exists in MOVE_DB
for _mv in (SV_MOVES_SWAMPERT + SV_MOVES_BLAZIKEN + SV_MOVES_QUAQUAVAL):
    if _mv not in MOVE_DB:
        _add_if_missing(_mv, "Normal", "Status", 0, 1.0)

# Maintain legacy aliases for downstream consumers
LEGAL_MOVES_SWAMPERT = SV_MOVES_SWAMPERT
LEGAL_MOVES_BLAZIKEN = SV_MOVES_BLAZIKEN
LEGAL_MOVES_QUAQUAVAL = SV_MOVES_QUAQUAVAL

# Trio legal move map used by your enumerator
LEGAL_MOVES = {
    "Swampert": SV_MOVES_SWAMPERT,
    "Blaziken": SV_MOVES_BLAZIKEN,
    "Quaquaval": SV_MOVES_QUAQUAVAL,
}

# ===== ABILITY MULTIPLIERS (biggest effect-size; offense & defense) ==============================

def ability_offense_mult(
    self_build: SetBuild,
    self_state: BattleState,
    mv: Move,
    stats_self: Dict[str, int],
    current_stab_mult: float,
) -> Tuple[float, float]:
    """
    Returns (atk_like_multiplier, stab_multiplier_adjustment).
    - atk_like_multiplier multiplies the effective attacking stat AFTER stages/choice/PQ.
    - stab_multiplier_adjustment multiplies the computed STAB (for Adaptability etc).
    """
    name = SPECIES_DATA[self_build.species].ability_hint or ""
    atk_mult = 1.0
    stab_adj = 1.0

    if name == "Huge Power" and mv.category == "Physical":
        atk_mult *= 2.0
    if mv.category != "Status" and base_power(mv) <= 60 and name == "Technician":
        atk_mult *= 1.5
    if name == "Tough Claws" and is_contact_effective(mv, self_build.item):
        atk_mult *= 1.3
    if name == "Iron Fist" and mv.is_punch:
        atk_mult *= 1.2
    if name == "Sharpness" and getattr(mv, "is_slicing", False):
        atk_mult *= 1.5

    low_hp = (self_state.hp * 3) <= self_state.max_hp
    if low_hp:
        if name == "Torrent" and mv.mtype == "Water":   atk_mult *= 1.5
        if name == "Blaze"   and mv.mtype == "Fire":    atk_mult *= 1.5
        if name == "Overgrow"and mv.mtype == "Grass":   atk_mult *= 1.5
        if name == "Swarm"   and mv.mtype == "Bug":     atk_mult *= 1.5

    if name == "Adaptability" and current_stab_mult > 1.0 and mv.category != "Status":
        stab_adj *= (2.0 / 1.5)  # boost STAB from 1.5x to 2.0x

    return atk_mult, stab_adj


def ability_defense_mult(opp_build: SetBuild, mv: Move) -> float:
    """Defender-side reduction (e.g., Thick Fat)."""
    name = SPECIES_DATA[opp_build.species].ability_hint or ""
    if name == "Thick Fat" and mv.mtype in ("Fire","Ice"):
        return 0.5
    return 1.0

# Helpful ability hints for key threats (only used when present)
def _bump_ability_hint(spec_name: str, ability: str):
    if spec_name in SPECIES_DATA:
        sp = SPECIES_DATA[spec_name]
        SPECIES_DATA[spec_name] = Species(sp.name, sp.types, sp.base, ability)

for __pair in [
    ("Iron Bundle","Quark Drive"),
    ("Iron Hands","Quark Drive"),
    ("Azumarill","Huge Power"),
    ("Scizor","Technician"),
    ("Porygon-Z","Adaptability"),
]:
    _bump_ability_hint(*__pair)

# ===== MOVESIDE EFFECTS EXTENSION (Aqua Step speed boost; keep your existing drops) ==============

def apply_stat_side_effects_after(self_state: BattleState, move: Move):
    # Existing stage drops (examples)
    if move.name == "Close Combat":
        self_state.stages["Def"] = max(-6, self_state.stages["Def"] - 1)
        self_state.stages["SpD"] = max(-6, self_state.stages["SpD"] - 1)
    elif move.name == "Draco Meteor":
        self_state.stages["SpA"] = max(-6, self_state.stages["SpA"] - 2)
    elif move.name == "Leaf Storm":
        self_state.stages["SpA"] = max(-6, self_state.stages["SpA"] - 2)
    elif move.name == "Headlong Rush":
        self_state.stages["Def"] = max(-6, self_state.stages["Def"] - 1)
        self_state.stages["SpD"] = max(-6, self_state.stages["SpD"] - 1)
    # New: Aqua Step
    if move.name == "Aqua Step":
        self_state.stages["Spe"] = min(6, self_state.stages["Spe"] + 1)

def is_contact_effective(move: Move, attacker_item: str) -> bool:
    # Punching Glove removes contact on punching moves
    if attacker_item == "Punching Glove" and move.is_punch:
        return False
    return move.contact

# ===== THREAT PRESETS (legality-correct 1v1-style sets). Fallback generator remains available. ===

def _evs(hp, atk, deff, spa, spd, spe): return {"HP": hp, "Atk": atk, "Def": deff, "SpA": spa, "SpD": spd, "Spe": spe}
_IV31 = {"HP":31,"Atk":31,"Def":31,"SpA":31,"SpD":31,"Spe":31}

THREAT_PRESETS: dict[str, list[SetBuild]] = {
    "Dragonite": [
        SetBuild("Dragonite","Choice Band","Multiscale","Normal","Adamant",_evs(0,252,4,0,0,252),_IV31,["Extreme Speed","Outrage","Earthquake","Fire Punch"]),
        SetBuild("Dragonite","Weakness Policy","Multiscale","Normal","Adamant",_evs(252,252,4,0,0,0),_IV31,["Extreme Speed","Earthquake","Fire Punch","Dragon Claw"]),
    ],
    "Kingambit": [
        SetBuild("Kingambit","Black Glasses",None,"Dark","Adamant",_evs(0,252,4,0,0,252),_IV31,["Kowtow Cleave","Sucker Punch","Iron Head","Brick Break"]),
    ],
    "Flutter Mane": [
        SetBuild("Flutter Mane","Choice Specs","Protosynthesis","Fairy","Timid",_evs(0,0,4,252,0,252),_IV31,["Moonblast","Shadow Ball","Mystical Fire","Power Gem"]),
    ],
    "Iron Bundle": [
        SetBuild("Iron Bundle","Booster Energy","Quark Drive","Ice","Timid",_evs(0,0,4,252,0,252),_IV31,["Freeze-Dry","Hydro Pump","Ice Beam","Flip Turn"]),
        SetBuild("Iron Bundle","Focus Sash","Quark Drive","Ice","Timid",_evs(0,0,4,252,0,252),_IV31,["Freeze-Dry","Hydro Pump","Ice Beam","Encore"]),
    ],
    "Urshifu": [
        SetBuild("Urshifu","Choice Band",None,"Dark","Jolly",_evs(0,252,4,0,0,252),_IV31,["Wicked Blow","Close Combat","Sucker Punch","Iron Head"]),
    ],
    "Urshifu-Rapid-Strike": [
        SetBuild("Urshifu-Rapid-Strike","Choice Band",None,"Water","Jolly",_evs(0,252,4,0,0,252),_IV31,["Surging Strikes","Close Combat","Ice Spinner","Aqua Jet"]),
    ],
    "Volcarona": [
        SetBuild("Volcarona","Leftovers",None,"Fairy","Timid",_evs(252,0,4,0,0,252),_IV31,["Flamethrower","Bug Buzz","Giga Drain","Protect"]),
    ],
    "Gholdengo": [
        SetBuild("Gholdengo","Choice Specs",None,"Steel","Modest",_evs(0,0,0,252,4,252),_IV31,["Make It Rain","Shadow Ball","Thunderbolt","Focus Blast"]),
    ],
    "Garganacl": [
        SetBuild("Garganacl","Leftovers",None,"Water","Impish",_evs(252,0,252,0,4,0),_IV31,["Salt Cure","Body Press","Rock Slide","Protect"]),
    ],
    "Great Tusk": [
        SetBuild("Great Tusk","Choice Scarf",None,"Ground","Jolly",_evs(0,252,4,0,0,252),_IV31,["Headlong Rush","Close Combat","Ice Spinner","Rock Slide"]),
    ],
    "Iron Hands": [
        SetBuild("Iron Hands","Assault Vest",None,"Electric","Adamant",_evs(252,252,4,0,0,0),_IV31,["Drain Punch","Thunder Punch","Ice Punch","Earthquake"]),
    ],
    "Roaring Moon": [
        SetBuild("Roaring Moon","Booster Energy","Protosynthesis","Flying","Jolly",_evs(0,252,4,0,0,252),_IV31,["Acrobatics","Crunch","Earthquake","Dragon Claw"]),
    ],
    "Raging Bolt": [
        SetBuild("Raging Bolt","Choice Specs","Protosynthesis","Electric","Modest",_evs(0,0,0,252,4,252),_IV31,["Thunderbolt","Draco Meteor","Dragon Pulse","Flamethrower"]),
    ],
    "Walking Wake": [
        SetBuild("Walking Wake","Choice Specs","Protosynthesis","Water","Timid",_evs(0,0,0,252,4,252),_IV31,["Hydro Steam","Draco Meteor","Flamethrower","Dragon Pulse"]),
    ],
    "Garchomp": [
        SetBuild("Garchomp","Choice Band",None,"Ground","Jolly",_evs(0,252,4,0,0,252),_IV31,["Earthquake","Outrage","Rock Slide","Fire Punch"]),
    ],
    "Haxorus": [
        SetBuild("Haxorus","Choice Band",None,"Dragon","Jolly",_evs(0,252,4,0,0,252),_IV31,["Outrage","Earthquake","Poison Jab","Rock Slide"]),
    ],
    "Primarina": [
        SetBuild("Primarina","Choice Specs",None,"Fairy","Modest",_evs(0,0,0,252,4,252),_IV31,["Moonblast","Hydro Pump","Ice Beam","Psychic"]),
    ],
    "Moltres-Galar": [
        SetBuild("Moltres-Galar","Weakness Policy",None,"Dark","Modest",_evs(0,0,0,252,4,252),_IV31,["Fiery Wrath","Hurricane","Flamethrower","Protect"]),
    ],
    "Scizor": [
        SetBuild("Scizor","Life Orb",None,"Steel","Adamant",_evs(0,252,4,0,0,252),_IV31,["Bullet Punch","Close Combat","U-turn","Knock Off"]),
    ],
    "Skeledirge": [
        SetBuild("Skeledirge","Leftovers","Unaware","Fairy","Bold",_evs(252,0,252,0,4,0),_IV31,["Torch Song","Shadow Ball","Slack Off","Protect"]),
    ],
    "Sneasler": [
        SetBuild("Sneasler","Choice Band",None,"Flying","Jolly",_evs(0,252,4,0,0,252),_IV31,["Close Combat","Gunk Shot","Acrobatics","Ice Punch"]),
    ],
    "Dondozo": [
        SetBuild("Dondozo","Leftovers","Unaware","Water","Impish",_evs(252,252,4,0,0,0),_IV31,["Wave Crash","Body Press","Protect","Rest"]),
    ],
    "Porygon-Z": [
        SetBuild("Porygon-Z","Choice Specs","Adaptability","Normal","Timid",_evs(0,0,0,252,4,252),_IV31,["Hyper Voice","Tri Attack","Dark Pulse","Ice Beam"]),
    ],
    "Kyurem": [
        SetBuild("Kyurem","Choice Specs",None,"Ice","Timid",_evs(0,0,0,252,4,252),_IV31,["Freeze-Dry","Ice Beam","Earth Power","Draco Meteor"]),
    ],
    "Azumarill": [
        SetBuild("Azumarill","Sitrus Berry","Huge Power","Fairy","Adamant",_evs(252,252,4,0,0,0),_IV31,["Play Rough","Aqua Jet","Liquidation","Ice Punch"]),
    ],
    "Goodra-Hisui": [
        SetBuild("Goodra-Hisui","Assault Vest",None,"Steel","Modest",_evs(252,0,0,252,4,0),_IV31,["Draco Meteor","Flash Cannon","Thunderbolt","Flamethrower"]),
    ],
    "Landorus-Therian": [
        SetBuild("Landorus-Therian","Choice Scarf","Intimidate","Ground","Jolly",_evs(0,252,4,0,0,252),_IV31,["Earthquake","Stone Edge","U-turn","Knock Off"]),
    ],
    "Ninetales-Alola": [
        SetBuild("Ninetales-Alola","Light Clay",None,"Water","Timid",_evs(0,0,4,252,0,252),_IV31,["Freeze-Dry","Moonblast","Encore","Protect"]),
    ],
    "Ogerpon-Wellspring": [
        SetBuild("Ogerpon-Wellspring","Life Orb",None,"Water","Jolly",_evs(0,252,4,0,0,252),_IV31,["Ivy Cudgel","Power Whip","Play Rough","Knock Off"]),
    ],
    "Sylveon": [
        SetBuild("Sylveon","Choice Specs",None,"Fairy","Modest",_evs(252,0,0,252,4,0),_IV31,["Hyper Voice","Mystical Fire","Shadow Ball","Psyshock"]),
    ],
    "Volcanion": [
        SetBuild("Volcanion","Choice Specs",None,"Water","Modest",_evs(0,0,0,252,4,252),_IV31,["Steam Eruption","Flamethrower","Earth Power","Sludge Bomb"]),
    ],
    "Manaphy": [
        SetBuild("Manaphy","Leftovers",None,"Water","Timid",_evs(0,0,4,252,0,252),_IV31,["Surf","Ice Beam","Energy Ball","Protect"]),
    ],
    "Cresselia": [
        SetBuild("Cresselia","Leftovers",None,"Fairy","Calm",_evs(252,0,0,0,252,4),_IV31,["Psychic","Moonblast","Moonlight","Protect"]),
    ],
    "Meowscarada": [
        SetBuild("Meowscarada","Choice Band",None,"Grass","Jolly",_evs(0,252,4,0,0,252),_IV31,["Flower Trick","Knock Off","Play Rough","Low Kick"]),
    ],
}

# Keep your original generators, but prefer presets when available
if "_orig_make_default_adversary" not in globals():
    _orig_make_default_adversary = globals().get("make_default_adversary", lambda x: None)
def make_default_adversary(spec_name: str) -> Optional[SetBuild]:
    return _orig_make_default_adversary(spec_name) if _orig_make_default_adversary else None

if "_orig_adversary_variants" not in globals():
    _orig_adversary_variants = globals().get("adversary_variants", lambda x: None)
def adversary_variants(spec_name: str) -> Optional[Tuple[List[SetBuild], List[float]]]:
    key = resolve_species_name(spec_name) or spec_name
    if key in THREAT_PRESETS and THREAT_PRESETS[key]:
        variants = []
        for sb in THREAT_PRESETS[key]:
            # Only include variants whose moves exist in MOVE_DB
            ok = True
            for m in sb.moves:
                if m not in MOVE_DB:
                    ok = False; break
            if ok:
                variants.append(sb)
        if variants:
            w = [1.0/len(variants)]*len(variants)
            return variants, w
    if _orig_adversary_variants:
        return _orig_adversary_variants(spec_name)
    return None

# Optional alias normalization used elsewhere
ALIASES.update({"Galarian Moltres": "Moltres-Galar"})

# ===== USAGE IN SEARCH (example) ================================================================
# Wherever you currently do:
#   ev_candidates = iterate_evs_axes(...)
# replace it with:
#   ev_axes = ("HP","Atk","Def","Spe") if physical else ("HP","SpA","SpD","Spe")
#   ev_candidates = iterate_evs_axes_matchup_aware(ev_axes, species, nature, item, rep_opp_builds)
#
# And after scoring top-N builds:
#   best = refine_evs_local(best, eval_fn, ev_axes, passes=128)
#
# That’s it — the rest of your pipeline (items, tera, natures, movesets, simulator) remains unchanged.
# =================================================================================================

# =========================
#     TYPE CHART (GEN 9)
# =========================
TYPES = [
    "Normal",
    "Fire",
    "Water",
    "Electric",
    "Grass",
    "Ice",
    "Fighting",
    "Poison",
    "Ground",
    "Flying",
    "Psychic",
    "Bug",
    "Rock",
    "Ghost",
    "Dragon",
    "Dark",
    "Steel",
    "Fairy",
]

N = len(TYPES)
type_index: Dict[str, int] = {t: i for i, t in enumerate(TYPES)}
effectiveness: List[List[float]] = [[1.0 for _ in range(N)] for _ in range(N)]


def _se(a: str, b: str, m: float) -> None:
    effectiveness[type_index[a]][type_index[b]] = m


# Normal
_se("Normal", "Rock", 0.5)
_se("Normal", "Ghost", 0.0)
_se("Normal", "Steel", 0.5)
# Fire
for b in ["Grass", "Ice", "Bug", "Steel"]:
    _se("Fire", b, 2.0)
for b in ["Fire", "Water", "Rock", "Dragon"]:
    _se("Fire", b, 0.5)
# Water
for b in ["Fire", "Ground", "Rock"]:
    _se("Water", b, 2.0)
for b in ["Water", "Grass", "Dragon"]:
    _se("Water", b, 0.5)
# Electric
for b in ["Water", "Flying"]:
    _se("Electric", b, 2.0)
for b in ["Electric", "Grass", "Dragon"]:
    _se("Electric", b, 0.5)
_se("Electric", "Ground", 0.0)
# Grass
for b in ["Water", "Ground", "Rock"]:
    _se("Grass", b, 2.0)
for b in ["Fire", "Grass", "Poison", "Flying", "Bug", "Dragon", "Steel"]:
    _se("Grass", b, 0.5)
# Ice
for b in ["Grass", "Ground", "Flying", "Dragon"]:
    _se("Ice", b, 2.0)
for b in ["Fire", "Water", "Ice", "Steel"]:
    _se("Ice", b, 0.5)
# Fighting
for b in ["Normal", "Ice", "Rock", "Dark", "Steel"]:
    _se("Fighting", b, 2.0)
for b in ["Poison", "Flying", "Psychic", "Bug", "Fairy"]:
    _se("Fighting", b, 0.5)
_se("Fighting", "Ghost", 0.0)
# Poison
for b in ["Grass", "Fairy"]:
    _se("Poison", b, 2.0)
for b in ["Poison", "Ground", "Rock", "Ghost"]:
    _se("Poison", b, 0.5)
_se("Poison", "Steel", 0.0)
# Ground
for b in ["Fire", "Electric", "Poison", "Rock", "Steel"]:
    _se("Ground", b, 2.0)
for b in ["Grass", "Bug"]:
    _se("Ground", b, 0.5)
_se("Ground", "Flying", 0.0)
# Flying
for b in ["Grass", "Fighting", "Bug"]:
    _se("Flying", b, 2.0)
for b in ["Electric", "Rock", "Steel"]:
    _se("Flying", b, 0.5)
# Psychic
for b in ["Fighting", "Poison"]:
    _se("Psychic", b, 2.0)
for b in ["Psychic", "Steel"]:
    _se("Psychic", b, 0.5)
_se("Psychic", "Dark", 0.0)
# Bug
for b in ["Grass", "Psychic", "Dark"]:
    _se("Bug", b, 2.0)
for b in ["Fire", "Fighting", "Poison", "Flying", "Ghost", "Steel", "Fairy"]:
    _se("Bug", b, 0.5)
# Rock
for b in ["Fire", "Ice", "Flying", "Bug"]:
    _se("Rock", b, 2.0)
for b in ["Fighting", "Ground", "Steel"]:
    _se("Rock", b, 0.5)
# Ghost
for b in ["Psychic", "Ghost"]:
    _se("Ghost", b, 2.0)
for b in ["Dark"]:
    _se("Ghost", b, 0.5)
_se("Ghost", "Normal", 0.0)
# Dragon
for b in ["Dragon"]:
    _se("Dragon", b, 2.0)
for b in ["Steel"]:
    _se("Dragon", b, 0.5)
_se("Dragon", "Fairy", 0.0)
# Dark
for b in ["Psychic", "Ghost"]:
    _se("Dark", b, 2.0)
for b in ["Fighting", "Dark", "Fairy"]:
    _se("Dark", b, 0.5)
# Steel
for b in ["Ice", "Rock", "Fairy"]:
    _se("Steel", b, 2.0)
for b in ["Fire", "Water", "Electric", "Steel"]:
    _se("Steel", b, 0.5)
# Fairy
for b in ["Fighting", "Dragon", "Dark"]:
    _se("Fairy", b, 2.0)
for b in ["Fire", "Poison", "Steel"]:
    _se("Fairy", b, 0.5)

# Cache type multipliers (hot path)
_type_mult_cache: Dict[Tuple[int, int, int], float] = {}


def type_mult(move_type: str, defender_types: List[str]) -> float:
    t1 = type_index[move_type]
    d1 = type_index[defender_types[0]] if defender_types else -1
    d2 = type_index[defender_types[1]] if len(defender_types) > 1 else -1
    key = (t1, d1, d2)
    if key in _type_mult_cache:
        return _type_mult_cache[key]
    m = 1.0
    for dt in defender_types:
        m *= effectiveness[t1][type_index[dt]]
    _type_mult_cache[key] = m
    return m


# =========================
#       NATURES (L100)
# =========================
NATURES: Dict[str, Tuple[Optional[str], Optional[str]]] = {
    "Adamant": ("Atk", "SpA"),
    "Jolly": ("Spe", "SpA"),
    "Modest": ("SpA", "Atk"),
    "Timid": ("Spe", "Atk"),
    "Careful": ("SpD", "SpA"),
    "Calm": ("SpD", "Atk"),
    "Impish": ("Def", "SpA"),
    "Bold": ("Def", "Atk"),
    "Hasty": ("Spe", "Def"),
    "Naive": ("Spe", "SpD"),
    "Naughty": ("Atk", "SpD"),
    "Rash": ("SpA", "SpD"),
    "Mild": ("SpA", "Def"),
    "Lonely": ("Atk", "Def"),
    "Bashful": (None, None),
    "Docile": (None, None),
    "Serious": (None, None),
    "Hardy": (None, None),
    "Quirky": (None, None),
    "Gentle": ("SpD", "Def"),
}


def nature_mult(nature: str, stat: str) -> float:
    up, down = NATURES.get(nature, (None, None))
    if up == stat:
        return 1.1
    if down == stat:
        return 0.9
    return 1.0


# =========================
#         MOVES
# =========================
@dataclass(frozen=True)
class Move:
    name: str
    mtype: str
    category: str  # "Physical" or "Special" or "Status"
    power: int = 0
    accuracy: float = 1.0
    contact: bool = False
    is_punch: bool = False
    multi_hits: int = 1
    always_crit: bool = False
    priority: int = 0
    is_counter: bool = False
    is_mirror_coat: bool = False
    is_protect: bool = False
    is_swords_dance: bool = False
    is_tera_blast: bool = False
    # optional simple flags for common Gen 9 moves we included
    first_turn_only: bool = False  # e.g., First Impression


MOVE_DB: Dict[str, Move] = {
    # Utility
    "Protect": Move("Protect", "Normal", "Status", 0, 1.0, priority=4, is_protect=True),
    "Detect": Move(
        "Detect", "Normal", "Status", 0, 1.0, priority=4, is_protect=True
    ),  # alias
    "Swords Dance": Move(
        "Swords Dance", "Normal", "Status", 0, 1.0, is_swords_dance=True
    ),
    "Counter": Move(
        "Counter", "Fighting", "Physical", 0, 1.0, priority=-5, is_counter=True
    ),
    "Mirror Coat": Move(
        "Mirror Coat", "Psychic", "Special", 0, 1.0, priority=-5, is_mirror_coat=True
    ),
    # Tera Blast
    "Tera Blast": Move("Tera Blast", "Normal", "Special", 80, 1.0, is_tera_blast=True),
    # Physical staples
    "Earthquake": Move("Earthquake", "Ground", "Physical", 100, 1.0),
    "Liquidation": Move("Liquidation", "Water", "Physical", 85, 1.0, contact=True),
    "Ice Punch": Move(
        "Ice Punch", "Ice", "Physical", 75, 1.0, contact=True, is_punch=True
    ),
    "Rock Slide": Move("Rock Slide", "Rock", "Physical", 75, 0.9),
    "Flare Blitz": Move("Flare Blitz", "Fire", "Physical", 120, 1.0, contact=True),
    "Close Combat": Move(
        "Close Combat", "Fighting", "Physical", 120, 1.0, contact=True
    ),
    "Aqua Step": Move("Aqua Step", "Water", "Physical", 80, 1.0, contact=True),
    "Ice Spinner": Move("Ice Spinner", "Ice", "Physical", 80, 1.0, contact=True),
    "Brave Bird": Move("Brave Bird", "Flying", "Physical", 120, 1.0, contact=True),
    "Outrage": Move("Outrage", "Dragon", "Physical", 120, 1.0, contact=True),
    "Extreme Speed": Move(
        "Extreme Speed", "Normal", "Physical", 80, 1.0, priority=2, contact=True
    ),
    "Sucker Punch": Move(
        "Sucker Punch", "Dark", "Physical", 70, 1.0, priority=1, contact=True
    ),
    "Iron Head": Move("Iron Head", "Steel", "Physical", 80, 1.0, contact=True),
    "Knock Off": Move("Knock Off", "Dark", "Physical", 65, 1.0, contact=True),
    "Stone Edge": Move("Stone Edge", "Rock", "Physical", 100, 0.8),
    "Gunk Shot": Move("Gunk Shot", "Poison", "Physical", 120, 0.8, contact=True),
    "Surging Strikes": Move(
        "Surging Strikes",
        "Water",
        "Physical",
        25,
        1.0,
        contact=True,
        multi_hits=3,
        always_crit=True,
    ),
    "Wild Charge": Move("Wild Charge", "Electric", "Physical", 90, 1.0, contact=True),
    "Zen Headbutt": Move("Zen Headbutt", "Psychic", "Physical", 80, 0.9, contact=True),
    "Play Rough": Move("Play Rough", "Fairy", "Physical", 90, 0.9, contact=True),
    "Shadow Claw": Move("Shadow Claw", "Ghost", "Physical", 70, 1.0, contact=True),
    "Leech Life": Move("Leech Life", "Bug", "Physical", 80, 1.0, contact=True),
    "Power Whip": Move("Power Whip", "Grass", "Physical", 120, 0.85, contact=True),
    "Leaf Blade": Move("Leaf Blade", "Grass", "Physical", 90, 1.0, contact=True),
    # a few common Gen 9 additions that are easy to model
    "Headlong Rush": Move(
        "Headlong Rush", "Ground", "Physical", 120, 1.0, contact=True
    ),
    "First Impression": Move(
        "First Impression",
        "Bug",
        "Physical",
        90,
        1.0,
        contact=True,
        priority=2,
        first_turn_only=True,
    ),
    "Shadow Sneak": Move(
        "Shadow Sneak", "Ghost", "Physical", 40, 1.0, contact=True, priority=1
    ),
    # Special staples
    "Moonblast": Move("Moonblast", "Fairy", "Special", 95, 1.0),
    "Shadow Ball": Move("Shadow Ball", "Ghost", "Special", 80, 1.0),
    "Draco Meteor": Move("Draco Meteor", "Dragon", "Special", 130, 0.9),
    "Thunderbolt": Move("Thunderbolt", "Electric", "Special", 90, 1.0),
    "Ice Beam": Move("Ice Beam", "Ice", "Special", 90, 1.0),
    "Flamethrower": Move("Flamethrower", "Fire", "Special", 90, 1.0),
    "Hydro Pump": Move("Hydro Pump", "Water", "Special", 110, 0.8),
    "Psychic": Move("Psychic", "Psychic", "Special", 90, 1.0),
    "Psyshock": Move("Psyshock", "Psychic", "Special", 80, 1.0),  # SpA vs Def
    "Hurricane": Move("Hurricane", "Flying", "Special", 110, 0.7),
    "Flash Cannon": Move("Flash Cannon", "Steel", "Special", 80, 1.0),
    "Dark Pulse": Move("Dark Pulse", "Dark", "Special", 80, 1.0),
    "Hyper Beam": Move("Hyper Beam", "Normal", "Special", 150, 0.9),
    "Leaf Storm": Move("Leaf Storm", "Grass", "Special", 130, 0.9),
}

# recoil ratios (simplified)
RECOIL_RATIO: Dict[str, float] = {
    "Flare Blitz": 1 / 3,
    "Brave Bird": 1 / 3,
    "Wild Charge": 1 / 4,
}

# =========================
#         ITEMS
# =========================
ITEMS = [
    "Focus Sash",
    "Assault Vest",
    "Choice Band",
    "Choice Specs",
    "Choice Scarf",
    "Life Orb",
    "Leftovers",
    "Booster Energy",
    "Covert Cloak",
    "Black Glasses",
    "Sitrus Berry",
    "Weakness Policy",
    "Punching Glove",
    "Rocky Helmet",
]


# =========================
#       SPECIES DATA
# =========================
@dataclass(frozen=True)
class Species:
    name: str
    types: Tuple[str, Optional[str]]  # second may be None
    base: Dict[str, int]  # HP,Atk,Def,SpA,SpD,Spe
    ability_hint: Optional[str] = None


SPECIES_DATA: Dict[str, Species] = {
    # Our trio
    "Swampert": (
        "Swampert",
        ("Water", "Ground"),
        {"HP": 100, "Atk": 110, "Def": 90, "SpA": 85, "SpD": 90, "Spe": 60},
        "Torrent",
    ),
    "Blaziken": (
        "Blaziken",
        ("Fire", "Fighting"),
        {"HP": 80, "Atk": 120, "Def": 70, "SpA": 110, "SpD": 70, "Spe": 80},
        "Speed Boost",
    ),
    "Quaquaval": (
        "Quaquaval",
        ("Water", "Fighting"),
        {"HP": 85, "Atk": 120, "Def": 80, "SpA": 85, "SpD": 75, "Spe": 85},
        "Torrent",
    ),
    # Core threats (expandable)
    "Calyrex-Shadow": (
        "Calyrex-Shadow",
        ("Psychic", "Ghost"),
        {"HP": 100, "Atk": 85, "Def": 80, "SpA": 165, "SpD": 100, "Spe": 150},
        None,
    ),
    "Koraidon": (
        "Koraidon",
        ("Fighting", "Dragon"),
        {"HP": 100, "Atk": 135, "Def": 115, "SpA": 85, "SpD": 100, "Spe": 135},
        "Orichalcum Pulse",
    ),
    "Miraidon": (
        "Miraidon",
        ("Electric", "Dragon"),
        {"HP": 100, "Atk": 85, "Def": 100, "SpA": 135, "SpD": 115, "Spe": 135},
        "Hadron Engine",
    ),
    "Dragonite": (
        "Dragonite",
        ("Dragon", "Flying"),
        {"HP": 91, "Atk": 134, "Def": 95, "SpA": 100, "SpD": 100, "Spe": 80},
        "Multiscale",
    ),
    "Flutter Mane": (
        "Flutter Mane",
        ("Ghost", "Fairy"),
        {"HP": 55, "Atk": 55, "Def": 55, "SpA": 135, "SpD": 135, "Spe": 135},
        "Protosynthesis",
    ),
    "Kingambit": (
        "Kingambit",
        ("Dark", "Steel"),
        {"HP": 100, "Atk": 135, "Def": 120, "SpA": 60, "SpD": 85, "Spe": 50},
        None,
    ),
    "Urshifu-Rapid-Strike": (
        "Urshifu-Rapid-Strike",
        ("Fighting", "Water"),
        {"HP": 100, "Atk": 130, "Def": 100, "SpA": 63, "SpD": 60, "Spe": 97},
        None,
    ),
    "Urshifu": (
        "Urshifu",
        ("Fighting", "Dark"),
        {"HP": 100, "Atk": 130, "Def": 100, "SpA": 63, "SpD": 60, "Spe": 97},
        None,
    ),
    "Volcarona": (
        "Volcarona",
        ("Bug", "Fire"),
        {"HP": 85, "Atk": 60, "Def": 65, "SpA": 135, "SpD": 105, "Spe": 100},
        None,
    ),
    "Iron Bundle": (
        "Iron Bundle",
        ("Ice", "Water"),
        {"HP": 56, "Atk": 80, "Def": 114, "SpA": 124, "SpD": 60, "Spe": 136},
        None,
    ),
    "Roaring Moon": (
        "Roaring Moon",
        ("Dragon", "Dark"),
        {"HP": 105, "Atk": 139, "Def": 71, "SpA": 55, "SpD": 101, "Spe": 119},
        "Protosynthesis",
    ),
    "Raging Bolt": (
        "Raging Bolt",
        ("Electric", "Dragon"),
        {"HP": 125, "Atk": 73, "Def": 91, "SpA": 137, "SpD": 89, "Spe": 75},
        "Protosynthesis",
    ),
    "Walking Wake": (
        "Walking Wake",
        ("Water", "Dragon"),
        {"HP": 99, "Atk": 83, "Def": 91, "SpA": 125, "SpD": 83, "Spe": 109},
        "Protosynthesis",
    ),
    "Garchomp": (
        "Garchomp",
        ("Dragon", "Ground"),
        {"HP": 108, "Atk": 130, "Def": 95, "SpA": 80, "SpD": 85, "Spe": 102},
        None,
    ),
    "Haxorus": (
        "Haxorus",
        ("Dragon", None),
        {"HP": 76, "Atk": 147, "Def": 90, "SpA": 60, "SpD": 70, "Spe": 97},
        None,
    ),
    "Great Tusk": (
        "Great Tusk",
        ("Ground", "Fighting"),
        {"HP": 115, "Atk": 131, "Def": 131, "SpA": 53, "SpD": 53, "Spe": 87},
        None,
    ),
    "Iron Hands": (
        "Iron Hands",
        ("Fighting", "Electric"),
        {"HP": 154, "Atk": 140, "Def": 108, "SpA": 50, "SpD": 68, "Spe": 50},
        None,
    ),
    "Zapdos": (
        "Zapdos",
        ("Electric", "Flying"),
        {"HP": 90, "Atk": 90, "Def": 85, "SpA": 125, "SpD": 90, "Spe": 100},
        None,
    ),
    "Primarina": (
        "Primarina",
        ("Water", "Fairy"),
        {"HP": 80, "Atk": 74, "Def": 74, "SpA": 126, "SpD": 116, "Spe": 60},
        None,
    ),
    "Pecharunt": (
        "Pecharunt",
        ("Poison", "Ghost"),
        {"HP": 88, "Atk": 88, "Def": 160, "SpA": 88, "SpD": 88, "Spe": 88},
        None,
    ),
    "Spectrier": (
        "Spectrier",
        ("Ghost", None),
        {"HP": 100, "Atk": 65, "Def": 60, "SpA": 145, "SpD": 80, "Spe": 130},
        None,
    ),
    "Ursaluna": (
        "Ursaluna",
        ("Normal", "Ground"),
        {"HP": 130, "Atk": 140, "Def": 105, "SpA": 45, "SpD": 80, "Spe": 50},
        None,
    ),
    "Ursaluna-Bloodmoon": (
        "Ursaluna-Bloodmoon",
        ("Normal", "Ground"),
        {"HP": 113, "Atk": 70, "Def": 120, "SpA": 135, "SpD": 80, "Spe": 52},
        None,
    ),
    "Corviknight": (
        "Corviknight",
        ("Flying", "Steel"),
        {"HP": 98, "Atk": 87, "Def": 105, "SpA": 53, "SpD": 85, "Spe": 67},
        None,
    ),
    "Dragapult": (
        "Dragapult",
        ("Dragon", "Ghost"),
        {"HP": 88, "Atk": 120, "Def": 75, "SpA": 100, "SpD": 75, "Spe": 142},
        None,
    ),
    "Goodra-Hisui": (
        "Goodra-Hisui",
        ("Steel", "Dragon"),
        {"HP": 80, "Atk": 100, "Def": 100, "SpA": 110, "SpD": 150, "Spe": 60},
        None,
    ),
    "Landorus-Therian": (
        "Landorus-Therian",
        ("Ground", "Flying"),
        {"HP": 89, "Atk": 145, "Def": 90, "SpA": 105, "SpD": 80, "Spe": 91},
        "Intimidate",
    ),
    "Ninetales-Alola": (
        "Ninetales-Alola",
        ("Ice", "Fairy"),
        {"HP": 73, "Atk": 67, "Def": 75, "SpA": 81, "SpD": 100, "Spe": 109},
        None,
    ),
    "Ogerpon-Wellspring": (
        "Ogerpon-Wellspring",
        ("Water", "Grass"),
        {"HP": 80, "Atk": 120, "Def": 84, "SpA": 60, "SpD": 96, "Spe": 110},
        None,
    ),
    "Sylveon": (
        "Sylveon",
        ("Fairy", None),
        {"HP": 95, "Atk": 65, "Def": 65, "SpA": 110, "SpD": 130, "Spe": 60},
        None,
    ),
    "Volcanion": (
        "Volcanion",
        ("Fire", "Water"),
        {"HP": 80, "Atk": 110, "Def": 120, "SpA": 130, "SpD": 90, "Spe": 70},
        None,
    ),
    "Manaphy": (
        "Manaphy",
        ("Water", None),
        {"HP": 100, "Atk": 100, "Def": 100, "SpA": 100, "SpD": 100, "Spe": 100},
        None,
    ),
    "Moltres-Galar": (
        "Moltres-Galar",
        ("Dark", "Flying"),
        {"HP": 90, "Atk": 85, "Def": 90, "SpA": 100, "SpD": 125, "Spe": 90},
        None,
    ),
    "Scizor": (
        "Scizor",
        ("Bug", "Steel"),
        {"HP": 70, "Atk": 130, "Def": 100, "SpA": 55, "SpD": 80, "Spe": 65},
        None,
    ),
    "Skeledirge": (
        "Skeledirge",
        ("Fire", "Ghost"),
        {"HP": 104, "Atk": 75, "Def": 100, "SpA": 110, "SpD": 75, "Spe": 66},
        "Unaware",
    ),
    "Sneasler": (
        "Sneasler",
        ("Fighting", "Poison"),
        {"HP": 80, "Atk": 130, "Def": 60, "SpA": 40, "SpD": 80, "Spe": 120},
        None,
    ),
    "Dondozo": (
        "Dondozo",
        ("Water", None),
        {"HP": 150, "Atk": 100, "Def": 115, "SpA": 65, "SpD": 65, "Spe": 35},
        "Unaware",
    ),
    "Porygon-Z": (
        "Porygon-Z",
        ("Normal", None),
        {"HP": 85, "Atk": 80, "Def": 70, "SpA": 135, "SpD": 75, "Spe": 90},
        None,
    ),
    "Kyurem": (
        "Kyurem",
        ("Dragon", "Ice"),
        {"HP": 125, "Atk": 130, "Def": 90, "SpA": 130, "SpD": 90, "Spe": 95},
        None,
    ),
    "Azumarill": (
        "Azumarill",
        ("Water", "Fairy"),
        {"HP": 100, "Atk": 50, "Def": 80, "SpA": 60, "SpD": 80, "Spe": 50},
        None,
    ),
    "Garganacl": (
        "Garganacl",
        ("Rock", None),
        {"HP": 100, "Atk": 100, "Def": 130, "SpA": 45, "SpD": 90, "Spe": 35},
        None,
    ),
    "Gholdengo": (
        "Gholdengo",
        ("Steel", "Ghost"),
        {"HP": 87, "Atk": 60, "Def": 95, "SpA": 133, "SpD": 91, "Spe": 84},
        None,
    ),
    "Iron Crown": (
        "Iron Crown",
        ("Steel", "Psychic"),
        {"HP": 90, "Atk": 72, "Def": 100, "SpA": 122, "SpD": 108, "Spe": 98},
        "Quark Drive",
    ),
    "Iron Valiant": (
        "Iron Valiant",
        ("Fairy", "Fighting"),
        {"HP": 74, "Atk": 130, "Def": 90, "SpA": 120, "SpD": 60, "Spe": 116},
        "Quark Drive",
    ),
    "Annihilape": (
        "Annihilape",
        ("Fighting", "Ghost"),
        {"HP": 110, "Atk": 115, "Def": 80, "SpA": 50, "SpD": 90, "Spe": 90},
        None,
    ),
    "Chien-Pao": (
        "Chien-Pao",
        ("Dark", "Ice"),
        {"HP": 80, "Atk": 120, "Def": 80, "SpA": 90, "SpD": 65, "Spe": 135},
        None,
    ),
    "Cresselia": (
        "Cresselia",
        ("Psychic", None),
        {"HP": 120, "Atk": 70, "Def": 120, "SpA": 75, "SpD": 130, "Spe": 85},
        None,
    ),
    "Meowscarada": (
        "Meowscarada",
        ("Grass", "Dark"),
        {"HP": 76, "Atk": 110, "Def": 70, "SpA": 81, "SpD": 70, "Spe": 123},
        None,
    ),
}
SPECIES_DATA = {k: Species(*v) for k, v in SPECIES_DATA.items()}

# Optional aliases
ALIASES: Dict[str, str] = {
    "Hisuian Goodra": "Goodra-Hisui",
    "Galarian Moltres": "Moltres-Galar",
    "Bloodmoon Ursaluna": "Ursaluna-Bloodmoon",
    "Walking-Wake": "Walking Wake",
    "Great-Tusk": "Great Tusk",
    "Landorus-T": "Landorus-Therian",
    "Ninetales-A": "Ninetales-Alola",
    "Ogerpon (Wellspring)": "Ogerpon-Wellspring",
    "PorygonZ": "Porygon-Z",
}

THREAT_LIST: List[str] = [
    "Roaring Moon",
    "Sylveon",
    "Volcanion",
    "Walking Wake",
    "Zapdos",
    "Annihilape",
    "Chien-Pao",
    "Cresselia",
    "Great Tusk",
    "Manaphy",
    "Moltres-Galar",
    "Scizor",
    "Skeledirge",
    "Sneasler",
    "Dondozo",
    "Porygon-Z",
    "Garchomp",
    "Haxorus",
    "Iron Hands",
    "Meowscarada",
    "Raging Bolt",
    "Urshifu",
    "Urshifu-Rapid-Strike",
    "Volcarona",
    "Dragonite",
    "Kingambit",
    "Flutter Mane",
    "Miraidon",
    "Koraidon",
    "Calyrex-Shadow",
    "Gholdengo",
    "Garganacl",
    "Iron Bundle",
    "Kyurem",
    "Ursaluna-Bloodmoon",
    "Azumarill",
    "Goodra-Hisui",
    "Landorus-Therian",
    "Ninetales-Alola",
    "Ogerpon-Wellspring",
    "Primarina",
    "Spectrier",
    "Ursaluna",
    "Iron Crown",
    "Iron Valiant",
    "Corviknight",
    "Dragapult",
    "Raging Bolt",  # (dup present here; dedup at runtime)
]

# Default per-threat variant weights (equal if unknown usage)
DEFAULT_VARIANT_WEIGHTS = []  # empty => equal weights


# =========================
#     BUILD / SET MODEL
# =========================
@dataclass
class SetBuild:
    species: str
    item: str
    ability: Optional[str]
    tera_type: Optional[str]
    nature: str
    evs: Dict[str, int]  # HP,Atk,Def,SpA,SpD,Spe
    ivs: Dict[str, int]  # default all 31
    moves: List[str]


@dataclass
class BattleState:
    hp: int
    max_hp: int
    stages: Dict[str, int]
    sash_intact: bool = True
    sturdy_intact: bool = True
    consumed_item: Dict[str, bool] = field(default_factory=dict)
    tera_used: bool = False
    tera_type: Optional[str] = None
    ability_active: Dict[str, Union[bool, dict]] = field(default_factory=dict)
    multiscale_on: bool = False
    locked_move: Optional[str] = None  # Choice lock
    turns_elapsed: int = 0  # full turns completed


def _print_version_banner_v5_wrap():
    print("== SV 1v1 Optimizer — CPU only ==")
    print("Version:", "5.0 (threat presets on)")
    print(
        "Note: Using curated 1v1-style threat sets where available; falling back otherwise."
    )




# =========================
#  MINI 1V1 SIMULATOR CORE
# =========================
def initial_state(build: SetBuild) -> BattleState:
    spec = SPECIES_DATA[build.species]
    st = calc_stats(spec, build.nature, build.evs, build.ivs)
    bs = BattleState(
        hp=st["HP"],
        max_hp=st["HP"],
        stages={"Atk": 0, "Def": 0, "SpA": 0, "SpD": 0, "Spe": 0},
    )
    bs.multiscale_on = spec.ability_hint == "Multiscale"
    bs.sturdy_intact = spec.ability_hint == "Sturdy"
    return bs


def apply_speed_boost_if_any(build: SetBuild, state: BattleState):
    if SPECIES_DATA[build.species].ability_hint == "Speed Boost":
        state.stages["Spe"] = min(6, state.stages["Spe"] + 1)


def pq_activation(
    build: SetBuild,
    weather: Dict[str, Optional[str]],
    terrain: Dict[str, Optional[str]],
    state: BattleState,
    stats: Dict[str, int],
    dry_run: bool = False,
) -> Dict[str, float]:
    """
    Activate Protosynthesis / Quark Drive if Sun/Electric Terrain or Booster Energy (one-time).
    Returns multipliers dict {"Atk":1.0|1.5, "SpA":..., "Spe":1.0|1.3}
    dry_run=True => do NOT consume Booster Energy; used for speed checks/orders.
    """
    ability = SPECIES_DATA[build.species].ability_hint
    if ability not in ["Protosynthesis", "Quark Drive"]:
        return {"Atk": 1.0, "SpA": 1.0, "Spe": 1.0}

    sun_ok = weather.get("state") == "Harsh Sunlight"
    et_ok = terrain.get("state") == "Electric Terrain"
    trigger = (ability == "Protosynthesis" and sun_ok) or (
        ability == "Quark Drive" and et_ok
    )

    # Booster Energy can trigger if not already used
    if (
        not trigger
        and build.item == "Booster Energy"
        and not state.consumed_item.get("Booster Energy", False)
    ):
        trigger = True
        if not dry_run:
            state.consumed_item["Booster Energy"] = True

    if not trigger:
        return {"Atk": 1.0, "SpA": 1.0, "Spe": 1.0}

    cand = {"Atk": stats["Atk"], "SpA": stats["SpA"], "Spe": stats["Spe"]}
    best = max(cand, key=cand.get)
    if best == "Spe":
        return {"Atk": 1.0, "SpA": 1.0, "Spe": 1.3}
    else:
        return {
            "Atk": 1.5 if best == "Atk" else 1.0,
            "SpA": 1.5 if best == "SpA" else 1.0,
            "Spe": 1.0,
        }


def compute_spe_for_order(
    build: SetBuild, state: BattleState, stats: Dict[str, int], weather, terrain
) -> float:
    a_mult = 1.0
    s_mult = 1.0
    spe_mult = 1.0
    a_mult, s_mult, spe_mult, _, _, _ = apply_choice(
        build.item, a_mult, s_mult, spe_mult
    )
    pq = pq_activation(build, weather, terrain, state, stats, dry_run=True)
    return stats["Spe"] * stage_mult(state.stages["Spe"], True) * spe_mult * pq["Spe"]


def try_sitrus(state: BattleState, build: SetBuild):
    if (
        build.item == "Sitrus Berry"
        and not state.consumed_item.get("Sitrus Berry", False)
        and state.hp > 0
        and state.hp * 2 <= state.max_hp
    ):
        heal = int(math.ceil(0.25 * state.max_hp))
        state.hp = min(state.max_hp, state.hp + heal)
        state.consumed_item["Sitrus Berry"] = True


def try_leftovers(state: BattleState, build: SetBuild):
    if build.item == "Leftovers" and state.hp > 0:
        heal = max(1, state.max_hp // 16)
        state.hp = min(state.max_hp, state.hp + heal)


def apply_recoil_move(attacker_state: BattleState, move: Move, damage_dealt: int):
    r = RECOIL_RATIO.get(move.name)
    if not r or damage_dealt <= 0:
        return
    recoil = max(1, int(math.floor(damage_dealt * r)))
    attacker_state.hp = max(0, attacker_state.hp - recoil)


def apply_recoil_life_orb(
    attacker_state: BattleState, build: SetBuild, damage_dealt: int
):
    if damage_dealt <= 0:
        return
    if build.item == "Life Orb" and attacker_state.hp > 0:
        recoil = max(1, attacker_state.max_hp // 10)
        attacker_state.hp = max(0, attacker_state.hp - recoil)


# ---- Core: apply a damaging move that HITS (no accuracy randomness here) ----
def perform_damage_hit_distribution(
    self_build: "SetBuild",
    opp_build: "SetBuild",
    self_state: "BattleState",
    opp_state: "BattleState",
    mv: "Move",
    tera: bool,
    ttype: str | None,
    weather,
    terrain,
    stats_self: dict[str, int],
    stats_opp: dict[str, int],
    opp_selected_move: "Move | None" = None,
) -> list[tuple[float, "BattleState", "BattleState"]]:
    """Returns a list of (prob, new_self_state, new_opp_state) conditioned on the move CONNECTING.
    Expands over the exact damage-roll distribution (and multi-hit if applicable).
    """

    # Sucker Punch failure against Status/Counter/MirrorCoat
    if mv.name == "Sucker Punch" and opp_selected_move is not None:
        if (
            opp_selected_move.category == "Status"
            or opp_selected_move.is_counter
            or opp_selected_move.is_mirror_coat
        ):
            sA = copy.deepcopy(self_state)
            sD = copy.deepcopy(opp_state)
            sD.ability_active["last_received"] = {"category": mv.category, "damage": 0}
            return [(1.0, sA, sD)]

    # Choice lock after first used damaging move
    if (
        self_build.item in ("Choice Band", "Choice Specs", "Choice Scarf")
        and self_state.locked_move is None
    ):
        self_state.locked_move = mv.name

    # Apply Tera BEFORE damage for both offense and defense this turn
    sA0 = copy.deepcopy(self_state)
    sD0 = copy.deepcopy(opp_state)
    if tera and ttype:
        sA0.tera_used = True
        sA0.tera_type = ttype

    # Determine used type and live category (Tera Blast handling)
    orig_types = effective_types_offense(self_build)
    used_type = mv.mtype
    if mv.is_tera_blast and (sA0.tera_used) and ttype:
        used_type = ttype
        used_cat = "Physical" if stats_self["Atk"] >= stats_self["SpA"] else "Special"
    else:
        used_cat = mv.category

    atk_stat, def_stat = category_stat_names(used_cat)
    if mv.name == "Psyshock":
        def_stat = "Def"

    # Choice multipliers
    a_mult, s_mult, spe_mult, _, _, _ = apply_choice(self_build.item, 1.0, 1.0, 1.0)

    # Engine passives
    if SPECIES_DATA[self_build.species].ability_hint == "Hadron Engine":
        s_mult *= 1.3
    if SPECIES_DATA[self_build.species].ability_hint == "Orichalcum Pulse":
        a_mult *= 1.3
    pq = pq_activation(self_build, weather, terrain, sA0, stats_self, dry_run=False)

    # Crit stage behavior (your existing rule: only always-crit moves are crits)
    crit = is_crit(mv)
    a_stage = sA0.stages[atk_stat]
    d_stage = sD0.stages[def_stat]
    if crit:
        a_stage = max(0, a_stage)
        d_stage = min(0, d_stage)

    # Unaware handling
    if SPECIES_DATA[opp_build.species].ability_hint == "Unaware" and a_stage > 0:
        a_stage = 0
    if SPECIES_DATA[self_build.species].ability_hint == "Unaware" and d_stage > 0:
        d_stage = 0

    # Attacking and defending stats
    if atk_stat == "Atk":
        atk_val = int(stats_self["Atk"] * stage_mult(a_stage) * a_mult * pq["Atk"])
    else:
        atk_val = int(stats_self["SpA"] * stage_mult(a_stage) * s_mult * pq["SpA"])

    def_base = stats_opp[def_stat] * stage_mult(d_stage)
    if def_stat == "SpD" and opp_build.item == "Assault Vest":
        def_base *= 1.5
    def_val = int(def_base)

    # STAB and field
    offensive_stab = tera_stab_mult(
        used_type, orig_types, sA0.tera_type if sA0.tera_used else None
    )
    item_m = move_item_mult(self_build.item, mv, atk_stat)
    field_m = field_power_mult(used_type, self_build, sA0, weather, terrain)
    atk_ability_mult, stab_adj = ability_offense_mult(self_build, sA0, mv, stats_self, offensive_stab)
    offensive_stab *= stab_adj
    def_ability_mult = ability_defense_mult(opp_build, mv)
    opp_types_now = effective_types_defense(opp_build, sD0)

    # Multi-hit handling via independent roll branching
    total_branches: list[tuple[float, "BattleState", "BattleState"]] = [(1.0, sA0, sD0)]

    hits = mv.multi_hits if mv.multi_hits > 1 else 1
    for _h in range(hits):
        step_out: list[tuple[float, "BattleState", "BattleState"]] = []
        for prob_so_far, SA_in, SD_in in total_branches:
            if SD_in.hp <= 0 or SA_in.hp <= 0:
                step_out.append((prob_so_far, SA_in, SD_in))
                continue

            # Multiscale applies on the *first* hit that connects in a turn for Dragonite
            ms_flag = SD_in.multiscale_on

            # Per-roll expansion
            tmult = type_mult(used_type, opp_types_now) * def_ability_mult
            for roll_mult in ROLL_TABLE:
                d = damage(
                    100,
                    base_power(mv),
                    max(1, int(atk_val * atk_ability_mult)),
                    def_val,
                    offensive_stab,
                    tmult,
                    item_m,
                    False,
                    ms_flag,
                    field_m,
                    crit,
                    roll_mult,
                )

                SA = copy.deepcopy(SA_in)
                SD = copy.deepcopy(SD_in)

                # Focus Sash / Sturdy timing *per hit*
                if (
                    opp_build.item == "Focus Sash"
                    and SD.sash_intact
                    and SD.hp == SD.max_hp
                    and d >= SD.hp
                ):
                    SD.hp = 1
                    SD.sash_intact = False
                    dealt = 1
                elif (
                    SPECIES_DATA[opp_build.species].ability_hint == "Sturdy"
                    and SD.sturdy_intact
                    and SD.hp == SD.max_hp
                    and d >= SD.hp
                ):
                    SD.hp = 1
                    SD.sturdy_intact = False
                    dealt = 1
                else:
                    SD.hp = max(0, SD.hp - d)
                    dealt = d

                # After first successful connection, Multiscale turns off
                ms_flag = False
                SD.multiscale_on = False

                # Sitrus timing for defender
                try_sitrus(SD, opp_build)

                # Early stop if defender fainted
                if SD.hp <= 0:
                    # Recoil (Wave Crash/Flare Blitz/etc.) & LO after final damage
                    apply_recoil_move(SA, mv, dealt)
                    if (
                        dealt > 0
                        and is_contact_effective(mv, self_build.item)
                        and opp_build.item == "Rocky Helmet"
                        and SA.hp > 0
                    ):
                        rh = max(1, SA.max_hp // 6)
                        SA.hp = max(0, SA.hp - rh)
                    apply_recoil_life_orb(SA, self_build, dealt)
                    try_sitrus(SA, self_build)

                    SA.ability_active["last_received"] = SA.ability_active.get("last_received", None)
                    SD.ability_active["last_received"] = {"category": used_cat, "damage": dealt}
                    step_out.append((prob_so_far * ROLL_PROB, SA, SD))
                    continue

                # Weakness Policy (triggered if first SE hit dealt damage this turn)
                tm_first = type_mult(used_type, effective_types_defense(opp_build, SD))
                if (
                    dealt > 0
                    and tm_first > 1.0
                    and opp_build.item == "Weakness Policy"
                    and not SD.consumed_item.get("Weakness Policy", False)
                ):
                    SD.consumed_item["Weakness Policy"] = True
                    SD.stages["Atk"] = min(6, SD.stages["Atk"] + 2)
                    SD.stages["SpA"] = min(6, SD.stages["SpA"] + 2)

                # Record last received for Counter/Mirror Coat
                SD.ability_active["last_received"] = {"category": used_cat, "damage": dealt}

                # Recoil & chip on attacker
                apply_recoil_move(SA, mv, dealt)
                if (
                    dealt > 0
                    and is_contact_effective(mv, self_build.item)
                    and opp_build.item == "Rocky Helmet"
                    and SA.hp > 0
                ):
                    rh = max(1, SA.max_hp // 6)
                    SA.hp = max(0, SA.hp - rh)
                apply_recoil_life_orb(SA, self_build, dealt)
                try_sitrus(SA, self_build)

                # User-side stage drops after connection
                if dealt > 0:
                    apply_stat_side_effects_after(SA, mv)

                step_out.append((prob_so_far * ROLL_PROB, SA, SD))
        # Merge equivalent states after this hit
        total_branches = _merge_branch_states(step_out)

        # If all branches already KO'd the defender, no need to continue remaining hits
        if all(SD.hp <= 0 for _, _, SD in total_branches):
            break

    return total_branches


def do_status_action(mv: Move, self_state: BattleState):
    if mv.is_protect:
        self_state.ability_active["Protect"] = True
        return
    if mv.is_swords_dance:
        self_state.stages["Atk"] = min(6, self_state.stages["Atk"] + 2)
        return


def apply_counter_like(
    mv: Move, self_state: BattleState, opp_state: BattleState, opp_build: SetBuild
):
    # Blocked by Protect
    if opp_state.ability_active.get("Protect", False):
        return
    last = self_state.ability_active.get("last_received", None)
    if last and isinstance(last, dict):
        if mv.is_counter and last.get("category") == "Physical":
            dmg = int(last.get("damage", 0)) * 2
        elif mv.is_mirror_coat and last.get("category") == "Special":
            dmg = int(last.get("damage", 0)) * 2
        else:
            return
        # Sash timing
        if (
            opp_build.item == "Focus Sash"
            and opp_state.sash_intact
            and opp_state.hp == opp_state.max_hp
            and dmg >= opp_state.hp
        ):
            opp_state.hp = 1
            opp_state.sash_intact = False
        else:
            opp_state.hp = max(0, opp_state.hp - dmg)
        opp_state.multiscale_on = False
        try_sitrus(opp_state, opp_build)


def action_list_for(build: SetBuild, state: BattleState) -> List[Tuple[str, bool]]:
    # Respect Choice lock: only that move remains
    moves = build.moves if state.locked_move is None else [state.locked_move]
    acts = []
    can_tera = (not state.tera_used) and bool(build.tera_type)
    for name in moves:
        # Disallow status/counter/coat after Choice lock (locked move must be the damaging move)
        if state.locked_move is not None:
            mv = MOVE_DB[state.locked_move]
            if mv.category == "Status" or mv.is_counter or mv.is_mirror_coat:
                continue
        # First-turn-only check is handled later (we still list; enforce at selection)
        acts.append((name, False))
        if can_tera:
            acts.append((name, True))
    return acts


def speed_order(tupleA, tupleB, weather, terrain):
    buildA, stateA, statsA = tupleA
    buildB, stateB, statsB = tupleB
    speA = compute_spe_for_order(buildA, stateA, statsA, weather, terrain)
    speB = compute_spe_for_order(buildB, stateB, statsB, weather, terrain)
    if speA > speB:
        return ("A", "B")
    if speB > speA:
        return ("B", "A")
    return ("TIE", "TIE")  # resolve by branching both orders


def apply_start_of_battle_hooks(
    buildA: SetBuild, A: BattleState, buildB: SetBuild, B: BattleState
):
    # Intimidate
    if SPECIES_DATA[buildA.species].ability_hint == "Intimidate":
        B.stages["Atk"] = max(-6, B.stages["Atk"] - 1)
    if SPECIES_DATA[buildB.species].ability_hint == "Intimidate":
        A.stages["Atk"] = max(-6, A.stages["Atk"] - 1)


# ------- CHANCE BRANCH HELPERS -------
# Return list of (prob, outcome_val_or_None, newA, newB)
ChanceBranch = Tuple[float, Optional[float], BattleState, BattleState]


def branch_on_move(
    build_att: "SetBuild",
    state_att: "BattleState",
    stats_att: dict[str, int],
    build_def: "SetBuild",
    state_def: "BattleState",
    stats_def: dict[str, int],
    weather,
    terrain,
    mv: "Move",
    tera: bool,
    ttype: str | None,
    opp_selected_move: "Move | None",
) -> list[tuple[float, "BattleState", "BattleState"]]:
    """
    Return list of (probability, new_att_state, new_def_state) after ATTACKER acts.
    Now expands: hit/miss accuracy and per-roll damage distributions.
    """
    out: list[tuple[float, "BattleState", "BattleState"]] = []

    # First-turn-only moves (e.g., First Impression)
    if mv.first_turn_only and (state_att.turns_elapsed > 0):
        sA = copy.deepcopy(state_att)
        sD = copy.deepcopy(state_def)
        if tera and ttype:
            sA.tera_used = True
            sA.tera_type = ttype
        sD.ability_active["last_received"] = {"category": mv.category, "damage": 0}
        out.append((1.0, sA, sD))
        return out

    # Status moves (no damage RNG)
    if mv.category == "Status":
        sA = copy.deepcopy(state_att)
        sD = copy.deepcopy(state_def)
        if tera and ttype:
            sA.tera_used = True
            sA.tera_type = ttype
        do_status_action(mv, sA)
        out.append((1.0, sA, sD))
        return out

    # Counter / Mirror Coat (no damage RNG; uses stored damage)
    if mv.is_counter or mv.is_mirror_coat:
        sA = copy.deepcopy(state_att)
        sD = copy.deepcopy(state_def)
        if tera and ttype:
            sA.tera_used = True
            sA.tera_type = ttype
        apply_counter_like(mv, sA, sD, build_def)
        out.append((1.0, sA, sD))
        return out

    # Protect blocks damage entirely
    if state_def.ability_active.get("Protect", False):
        sA = copy.deepcopy(state_att)
        sD = copy.deepcopy(state_def)
        if tera and ttype:
            sA.tera_used = True
            sA.tera_type = ttype
        sD.ability_active["last_received"] = {"category": mv.category, "damage": 0}
        out.append((1.0, sA, sD))
        return out

    # Accuracy RNG split
    acc = max(0.0, min(1.0, mv.accuracy))
    miss_p = 1.0 - acc
    if miss_p > 0:
        sA_m = copy.deepcopy(state_att)
        sD_m = copy.deepcopy(state_def)
        if tera and ttype:
            sA_m.tera_used = True
            sA_m.tera_type = ttype
        sD_m.ability_active["last_received"] = {"category": mv.category, "damage": 0}
        if mv.name == "High Jump Kick":
            crash = max(1, sA_m.max_hp // 2)
            sA_m.hp = max(0, sA_m.hp - crash)
            try_sitrus(sA_m, build_att)
        out.append((miss_p, sA_m, sD_m))

    if acc > 0:
        hit_branches = perform_damage_hit_distribution(
            build_att,
            build_def,
            state_att,
            state_def,
            mv,
            tera,
            ttype,
            weather,
            terrain,
            stats_att,
            stats_def,
            opp_selected_move,
        )
        for p2, SA2, SD2 in hit_branches:
            out.append((acc * p2, SA2, SD2))

    return _merge_branch_states(out)


def step_resolution(
    buildA: SetBuild,
    stateA: BattleState,
    statsA: Dict[str, int],
    buildB: SetBuild,
    stateB: BattleState,
    statsB: Dict[str, int],
    weather,
    terrain,
    actA: Tuple[str, bool],
    actB: Tuple[str, bool],
) -> List[ChanceBranch]:
    """
    Execute both chosen actions for one turn (order by priority then speed).
    Return list of stochastic branches: (prob, terminal_value_or_None, newA, newB).
    """
    mvA = MOVE_DB[actA[0]]
    teraA = actA[1]
    ttA = buildA.tera_type if teraA else None
    mvB = MOVE_DB[actB[0]]
    teraB = actB[1]
    ttB = buildB.tera_type if teraB else None

    def clear_turn_flags(S: BattleState):
        S.ability_active.pop("Protect", None)
        S.ability_active["last_received"] = None

    def ordered(first: str) -> List[ChanceBranch]:
        A = copy.deepcopy(stateA)
        B = copy.deepcopy(stateB)
        clear_turn_flags(A)
        clear_turn_flags(B)

        # FIRST acts
        if first == "A":
            branches_first = branch_on_move(
                buildA,
                A,
                statsA,
                buildB,
                B,
                statsB,
                weather,
                terrain,
                mvA,
                teraA,
                ttA,
                mvB,
            )
        else:
            branches_first = branch_on_move(
                buildB,
                B,
                statsB,
                buildA,
                A,
                statsA,
                weather,
                terrain,
                mvB,
                teraB,
                ttB,
                mvA,
            )

        out_branches: List[ChanceBranch] = []
        for p1, SA1, SB1 in branches_first:
            # Terminal after first action?
            if SA1.hp <= 0 and SB1.hp <= 0:
                out_branches.append((p1, 0.5, SA1, SB1))
                continue
            if SB1.hp <= 0:
                out_branches.append((p1, 1.0 if first == "A" else 0.0, SA1, SB1))
                continue
            if SA1.hp <= 0:
                out_branches.append((p1, 0.0 if first == "A" else 1.0, SA1, SB1))
                continue

            # SECOND acts if alive
            if first == "A":
                branches_second = branch_on_move(
                    buildB,
                    SB1,
                    statsB,
                    buildA,
                    SA1,
                    statsA,
                    weather,
                    terrain,
                    mvB,
                    teraB,
                    ttB,
                    mvA,
                )
                for p2, SB2, SA2 in branches_second:
                    apply_speed_boost_if_any(buildA, SA2)
                    apply_speed_boost_if_any(buildB, SB2)
                    try_sitrus(SA2, buildA)
                    try_sitrus(SB2, buildB)
                    try_leftovers(SA2, buildA)
                    try_leftovers(SB2, buildB)
                    out_branches.append((p1 * p2, None, SA2, SB2))
            else:
                branches_second = branch_on_move(
                    buildA,
                    SA1,
                    statsA,
                    buildB,
                    SB1,
                    statsB,
                    weather,
                    terrain,
                    mvA,
                    teraA,
                    ttA,
                    mvB,
                )
                for p2, SA2, SB2 in branches_second:
                    apply_speed_boost_if_any(buildA, SA2)
                    apply_speed_boost_if_any(buildB, SB2)
                    try_sitrus(SA2, buildA)
                    try_sitrus(SB2, buildB)
                    try_leftovers(SA2, buildA)
                    try_leftovers(SB2, buildB)
                    out_branches.append((p1 * p2, None, SA2, SB2))
        return out_branches

    if mvA.priority > mvB.priority:
        return ordered("A")
    elif mvB.priority > mvA.priority:
        return ordered("B")
    else:
        o = speed_order(
            (buildA, stateA, statsA), (buildB, stateB, statsB), weather, terrain
        )
        if o[0] == "TIE":
            a = ordered("A")
            b = ordered("B")
            return [(0.5 * p, val, sA, sB) for (p, val, sA, sB) in a] + [
                (0.5 * p, val, sA, sB) for (p, val, sA, sB) in b
            ]
        else:
            return ordered(o[0])


# ---------- Minimax (simultaneous choices + chance nodes) ----------
def state_key(
    buildA: SetBuild, A: BattleState, buildB: SetBuild, B: BattleState, depth: int
) -> Tuple:
    def cflags(st: BattleState) -> Tuple:
        return (
            st.hp,
            st.max_hp,
            st.stages["Atk"],
            st.stages["Def"],
            st.stages["SpA"],
            st.stages["SpD"],
            st.stages["Spe"],
            st.sash_intact,
            st.sturdy_intact,
            st.multiscale_on,
            st.tera_used,
            st.tera_type or "",
            st.locked_move or "",
            st.consumed_item.get("Booster Energy", False),
            st.consumed_item.get("Sitrus Berry", False),
            st.consumed_item.get("Weakness Policy", False),
            st.turns_elapsed,
        )

    def ev_tuple(ev: Dict[str, int]) -> Tuple[int, int, int, int, int, int]:
        return (ev["HP"], ev["Atk"], ev["Def"], ev["SpA"], ev["SpD"], ev["Spe"])

    def iv_tuple(iv: Dict[str, int]) -> Tuple[int, int, int, int, int, int]:
        return (iv["HP"], iv["Atk"], iv["Def"], iv["SpA"], iv["SpD"], iv["Spe"])

    return (
        buildA.species,
        buildA.item,
        buildA.tera_type or "",
        buildA.nature,
        ev_tuple(buildA.evs),
        iv_tuple(buildA.ivs),
        cflags(A),
        buildB.species,
        buildB.item,
        buildB.tera_type or "",
        buildB.nature,
        ev_tuple(buildB.evs),
        iv_tuple(buildB.ivs),
        cflags(B),
        depth,
    )


_minimax_cache: Dict[Tuple, float] = {}


def sudden_death_value(A: BattleState, B: BattleState) -> float:
    a = 0.0 if A.max_hp <= 0 else A.hp / A.max_hp
    b = 0.0 if B.max_hp <= 0 else B.hp / B.max_hp
    if abs(a - b) < 1e-9:
        return 0.5
    return 1.0 if a > b else 0.0


def minimax(
    buildA: SetBuild,
    A: BattleState,
    statsA: Dict[str, int],
    buildB: SetBuild,
    B: BattleState,
    statsB: Dict[str, int],
    weather,
    terrain,
    depth: int,
    alpha: float,
    beta: float,
) -> float:
    # Terminal KOs
    if A.hp <= 0 and B.hp <= 0:
        return 0.5
    if B.hp <= 0:
        return 1.0
    if A.hp <= 0:
        return 0.0

    # Depth==0 => sudden death by %HP
    if depth == 0:
        return sudden_death_value(A, B)

    key = state_key(buildA, A, buildB, B, depth)
    if key in _minimax_cache:
        return _minimax_cache[key]

    actsA = action_list_for(buildA, A)
    actsB = action_list_for(buildB, B)

    best_val = -1e9
    for actA in actsA:
        worst_val = 1e9
        local_beta = beta
        for actB in actsB:
            branches = step_resolution(
                buildA, A, statsA, buildB, B, statsB, weather, terrain, actA, actB
            )
            ev = 0.0
            for p, val, nA, nB in branches:
                nA2 = copy.deepcopy(nA)
                nB2 = copy.deepcopy(nB)
                nA2.turns_elapsed = A.turns_elapsed + 1
                nB2.turns_elapsed = B.turns_elapsed + 1

                if val is None:
                    ev += p * minimax(
                        buildA,
                        nA2,
                        statsA,
                        buildB,
                        nB2,
                        statsB,
                        weather,
                        terrain,
                        depth - 1,
                        alpha,
                        local_beta,
                    )
                else:
                    ev += p * val
            if ev < worst_val:
                worst_val = ev
            if worst_val <= alpha:
                break  # prune B
            if worst_val < local_beta:
                local_beta = worst_val
        if worst_val > best_val:
            best_val = worst_val
        if best_val >= beta:
            break  # prune A
        if best_val > alpha:
            alpha = best_val

    _minimax_cache[key] = best_val
    return best_val


def simulate(buildA: SetBuild, buildB: SetBuild, verbose: bool = False) -> float:
    """
    Optimal-play simulator (minimax + chance nodes), SEARCH_TURNS horizon (3).
    Returns P(win) in [0,1].
    """
    # Precompute stats
    specA = SPECIES_DATA[buildA.species]
    specB = SPECIES_DATA[buildB.species]
    statsA = calc_stats(specA, buildA.nature, buildA.evs, buildA.ivs)
    statsB = calc_stats(specB, buildB.nature, buildB.evs, buildB.ivs)

    # Initial states
    A0 = initial_state(buildA)
    B0 = initial_state(buildB)

    # Environment and ability context
    weather = {"state": None}
    terrain = {"state": None}
    atk_mult = {"A": 1.0, "B": 1.0}
    spa_mult = {"A": 1.0, "B": 1.0}
    ability_context(specA.ability_hint or "", "A", weather, terrain, atk_mult, spa_mult)
    ability_context(specB.ability_hint or "", "B", weather, terrain, atk_mult, spa_mult)

    # Start-of-battle hooks (e.g., Intimidate)
    apply_start_of_battle_hooks(buildA, A0, buildB, B0)

    # Reset cache per match
    _minimax_cache.clear()

    pwin = minimax(
        buildA,
        A0,
        statsA,
        buildB,
        B0,
        statsB,
        weather,
        terrain,
        SEARCH_TURNS,
        ALPHA_INIT,
        BETA_INIT,
    )
    return max(0.0, min(1.0, pwin))


# =========================
#     OBJECTIVE / SEARCH
# =========================
def valid_evs(ev: Dict[str, int]) -> bool:
    if any(v % 4 != 0 for v in ev.values()):
        return False
    if any(v > 252 for v in ev.values()):
        return False
    return sum(ev.values()) <= EV_TOTAL_MAX


def _stab_types_for(species: str) -> set[str]:
    t1, t2 = SPECIES_DATA[species].types
    return {t for t in (t1, t2) if t}


def _move_is_status(name: str) -> bool:
    mv = MOVE_DB[name]
    return mv.category == "Status" or mv.is_counter or mv.is_mirror_coat


def _coverage_proxy(species: str, moves: list[str]) -> tuple:
    """Cheap, order-invariant signature for Pareto pruning."""

    stab_types = _stab_types_for(species)
    type_best_bp: defaultdict[str, int] = defaultdict(int)
    has_stab = False
    has_priority = False

    for mname in moves:
        mv = MOVE_DB[mname]
        if mv.category == "Status":
            continue
        bp = base_power(mv)
        type_best_bp[mv.mtype] = max(type_best_bp[mv.mtype], bp)
        if mv.mtype in stab_types:
            has_stab = True
        if mv.priority > 0:
            has_priority = True

    vect = []
    for dtyp in TYPES:
        best = 0.0
        for atyp, bp in type_best_bp.items():
            best = max(
                best,
                bp * effectiveness[type_index[atyp]][type_index[dtyp]],
            )
        vect.append(int(best))
    return (tuple(vect), int(has_stab), int(has_priority))


def _dominates(sig_a: tuple, sig_b: tuple) -> bool:
    ge_all = (
        all(a >= b for a, b in zip(sig_a[0], sig_b[0]))
        and sig_a[1] >= sig_b[1]
        and sig_a[2] >= sig_b[2]
    )
    gt_any = (
        any(a > b for a, b in zip(sig_a[0], sig_b[0]))
        or sig_a[1] > sig_b[1]
        or sig_a[2] > sig_b[2]
    )
    return ge_all and gt_any


def movesets_from_pool(
    pool: List[str], four_physical_only: bool, species: str
) -> List[List[str]]:
    usable: list[str] = []
    for name in pool:
        mv = MOVE_DB[name]
        if four_physical_only and mv.category == "Special":
            continue
        usable.append(name)

    protect_like = {"Protect", "Detect"}
    setup_like = {"Swords Dance", "Bulk Up"}
    status_like = {
        "Protect",
        "Detect",
        "Swords Dance",
        "Bulk Up",
        "Encore",
        "Taunt",
        "Counter",
    }

    stab_types = _stab_types_for(species)
    candidates: list[list[str]] = []
    sigs: list[tuple] = []
    frontier_idx: list[int] = []

    def _sort_key(mname: str) -> tuple[int, int, int]:
        mv = MOVE_DB[mname]
        stab = 1 if (mv.category != "Status" and mv.mtype in stab_types) else 0
        return (stab, base_power(mv), 1 if mv.priority > 0 else 0)

    usable_sorted = sorted(usable, key=_sort_key, reverse=True)

    from itertools import combinations

    for a, b, c, d in combinations(usable_sorted, 4):
        subset = [a, b, c, d]
        if sum(1 for x in subset if x in protect_like) > 1:
            continue
        if sum(1 for x in subset if x in setup_like) > 1:
            continue
        if sum(1 for x in subset if x in status_like) > 1:
            continue
        if not any(
            MOVE_DB[x].category != "Status" and MOVE_DB[x].mtype in stab_types
            for x in subset
        ):
            continue

        sig = _coverage_proxy(species, subset)

        dominated = False
        remove: list[int] = []
        for idx in frontier_idx:
            if _dominates(sigs[idx], sig):
                dominated = True
                break
            if _dominates(sig, sigs[idx]):
                remove.append(idx)
        if dominated:
            continue
        if remove:
            frontier_idx = [idx for idx in frontier_idx if idx not in remove]
        sigs.append(sig)
        frontier_idx.append(len(sigs) - 1)
        candidates.append(subset)

    return candidates


def filter_moveset_by_item(item: str, moves: List[str]) -> bool:
    has_status = any(MOVE_DB[m].category == "Status" for m in moves)
    if item == "Assault Vest" and has_status:
        return False
    if item in ("Choice Band", "Choice Specs", "Choice Scarf") and has_status:
        return False
    if item in ("Choice Band", "Choice Specs", "Choice Scarf") and (
        "Counter" in moves or "Mirror Coat" in moves
    ):
        return False
    return True


# ---------- Local EV hill-climb refine ----------
EV_KEYS_ORDER = ("HP", "Atk", "Def", "SpA", "SpD", "Spe")


def clamp_evs(ev: Dict[str, int]) -> Dict[str, int]:
    ev = {k: max(0, min(252, (ev.get(k, 0) // 4) * 4)) for k in EV_KEYS_ORDER}
    total = sum(ev.values())
    if total > EV_TOTAL_MAX:
        overflow = total - EV_TOTAL_MAX
        for k in ("HP", "Atk", "Def", "SpA", "SpD", "Spe"):
            take = min(overflow, ev[k])
            take = (take // 4) * 4
            ev[k] -= take
            overflow -= take
            if overflow <= 0:
                break
    return ev


# Prebuild threat variants once (with weights)
def prebuild_threat_variants(
    threat_names: List[str],
) -> Dict[str, Tuple[List[SetBuild], List[float]]]:
    out = {}
    missing = []
    for t in threat_names:
        vw = adversary_variants(t)
        if not vw:
            missing.append(t)
        else:
            variants, weights = vw
            resolved = resolve_species_name(t)
            out[SPECIES_DATA[resolved].name] = (variants, weights)
    if missing:
        print("[warn] Missing threats (not in SPECIES_DATA):", sorted(set(missing)))
    return out


def weighted_mean(vals: List[float], weights: List[float]) -> float:
    if not vals:
        return 0.0
    if not weights or len(weights) != len(vals):
        return sum(vals) / len(vals)
    s = sum(weights)
    if s <= 0:
        return sum(vals) / len(vals)
    return sum(v * w for v, w in zip(vals, weights)) / s


def eval_candidate_single(
    candidate: SetBuild,
    threats_order: List[str],
    threats_variants: Dict[str, Tuple[List[SetBuild], List[float]]],
) -> Tuple[float, List[float], SetBuild]:
    wrs = []
    for name in threats_order:
        variants, weights = threats_variants[name]
        results = [simulate(candidate, opp) for opp in variants]
        wrs.append(weighted_mean(results, weights))
    score = sum(wrs) / len(wrs) if wrs else 0.0
    return score, wrs, candidate


def eval_candidate_trio(
    candidate: SetBuild,
    fixed_builds: Dict[str, SetBuild],
    threats_order: List[str],
    threats_variants: Dict[str, Tuple[List[SetBuild], List[float]]],
) -> Tuple[float, List[float], SetBuild]:
    trio = dict(fixed_builds)
    trio[candidate.species] = candidate
    wrs = []
    for name in threats_order:
        variants, weights = threats_variants[name]
        per_variant = []
        for opp in variants:
            ours = max(simulate(b, opp) for _, b in trio.items())
            per_variant.append(ours)
        wrs.append(weighted_mean(per_variant, weights))
    score = sum(wrs) / len(wrs) if wrs else 0.0
    return score, wrs, candidate


def build_search_for_species(
    species: str,
    threats: List[str],
    conditioned_on: Optional[Dict[str, SetBuild]] = None,
):
    threats_variants = prebuild_threat_variants(threats)
    if not threats_variants:
        return None, {}
    candidates = enumerate_candidates_for_species(species)
    if not candidates:
        return None, {}

    best = None
    per_wr = {}
    max_workers = max(1, (os.cpu_count() or 1))

    if conditioned_on is None:
        # Solo objective — shortlist in parallel
        with ProcessPoolExecutor(max_workers=max_workers) as ex:
            futures = [
                ex.submit(eval_candidate_single, c, threats, threats_variants)
                for c in candidates
            ]
            for fut in as_completed(futures):
                score, wrs, cand = fut.result()
                if (best is None) or (score > best[0]):
                    best = (score, wrs, cand)

        # Local refine — solo
        def solo_eval_fn(sb: SetBuild) -> float:
            wrs = []
            for name in threats:
                variants, weights = threats_variants[name]
                results = [simulate(sb, opp) for opp in variants]
                wrs.append(weighted_mean(results, weights))
            return sum(wrs) / len(wrs) if wrs else 0.0

        axes = (
            ("HP", "Atk", "Def", "Spe")
            if pick_offense_category(SPECIES_DATA[species]) == "Physical"
            else ("HP", "SpA", "SpD", "Spe")
        )
        refined = refine_evs_local(
            best[2], solo_eval_fn, axes, passes=LOCAL_REFINE_PASSES
        )
        if refined.evs != best[2].evs:
            wrs = []
            for name in threats:
                variants, weights = threats_variants[name]
                results = [simulate(refined, opp) for opp in variants]
                wrs.append(weighted_mean(results, weights))
            best = (sum(wrs) / len(wrs) if wrs else 0.0, wrs, refined)

    else:
        # Trio-conditioned objective (sequential)
        def trio_eval_fn(sb: SetBuild) -> float:
            trio = dict(conditioned_on)
            trio[species] = sb
            wrs = []
            for name in threats:
                variants, weights = threats_variants[name]
                per_variant = []
                for opp in variants:
                    ours = max(simulate(b, opp) for _, b in trio.items())
                    per_variant.append(ours)
                wrs.append(weighted_mean(per_variant, weights))
            return sum(wrs) / len(wrs) if wrs else 0.0

        for c in candidates:
            score, wrs, cand = eval_candidate_trio(
                c, conditioned_on, threats, threats_variants
            )
            if (best is None) or (score > best[0]):
                best = (score, wrs, cand)

        # Local refine — trio-conditioned
        axes = (
            ("HP", "Atk", "Def", "Spe")
            if pick_offense_category(SPECIES_DATA[species]) == "Physical"
            else ("HP", "SpA", "SpD", "Spe")
        )
        refined = refine_evs_local(
            best[2], trio_eval_fn, axes, passes=LOCAL_REFINE_PASSES
        )
        if refined.evs != best[2].evs:
            wrs = []
            trio_fixed = dict(conditioned_on)
            trio_fixed[species] = refined
            for name in threats:
                variants, weights = threats_variants[name]
                per_variant = []
                for opp in variants:
                    ours = max(simulate(b, opp) for _, b in trio_fixed.items())
                    per_variant.append(ours)
                wrs.append(weighted_mean(per_variant, weights))
            best = (sum(wrs) / len(wrs) if wrs else 0.0, wrs, refined)

    if best is None:
        return None, {}
    per_wr = {threats[i]: best[1][i] for i in range(len(threats))}
    return best[2], per_wr


def coordinate_descent_trio(order: List[str], threats: List[str], rounds: int = 2):
    # Initial independent bests
    bests = {}
    per_wr_all = {}
    resolvable = [t for t in threats if resolve_species_name(t)]
    for sp in order:
        print(f"\nSearching best build for {sp} (solo)...")
        b, wrs = build_search_for_species(sp, resolvable, conditioned_on=None)
        if b is None:
            raise RuntimeError(f"No candidate found for {sp}")
        bests[sp] = b
        per_wr_all[sp] = wrs
        print(
            f"[Best SOLO] {sp}: item={b.item}, tera={b.tera_type}, nature={b.nature}, EVs={b.evs}, moves={b.moves}"
        )

    # Coordinate updates
    for r in range(1, rounds + 1):
        print(f"\n== Coordinate descent round {r} ==")
        for sp in order:
            fixed = {k: v for k, v in bests.items() if k != sp}
            b, wrs = build_search_for_species(sp, resolvable, conditioned_on=fixed)
            if b is not None:
                bests[sp] = b
                per_wr_all[sp] = wrs
                print(
                    f"[Best TEAM] {sp}: item={b.item}, tera={b.tera_type}, nature={b.nature}, EVs={b.evs}, moves={b.moves}"
                )
    return bests, per_wr_all


def trio_objective(builds: Dict[str, SetBuild], threats: List[str]):
    agg = {}
    used = 0
    threats_variants = prebuild_threat_variants(threats)
    for name in threats:
        if name not in threats_variants:
            continue
        used += 1
        variants, weights = threats_variants[name]
        per_variant = []
        for opp in variants:
            ours = max(simulate(b, opp) for _, b in builds.items())
            per_variant.append(ours)
        agg[name] = weighted_mean(per_variant, weights)
    avg = (sum(agg.values()) / used) if used else 0.0
    return avg, agg, used


# =========================
#            MAIN
# =========================
def canonical_name(name: str) -> Optional[str]:
    key = resolve_species_name(name)
    return SPECIES_DATA[key].name if key else None


def main():
    start = time.time()
    if not globals().get("_svi_banner_override", False):
        print("== SV 1v1 Optimizer — CPU only ==")
        print("Version:", "3.0.1")
    print("Threats listed:", len(THREAT_LIST))

    # Dedup threats (avoid overweighting duplicates) and canonicalize names
    unique_threats = sorted(set(THREAT_LIST), key=lambda x: THREAT_LIST.index(x))
    canonical_threats = [cn for cn in (canonical_name(t) for t in unique_threats) if cn]
    missing = [t for t in unique_threats if not resolve_species_name(t)]
    print(f"Threats resolvable: {len(canonical_threats)}; missing: {len(missing)}")
    if missing:
        print("Missing threats will be skipped:", sorted(set(missing)))

    order = ["Swampert", "Blaziken", "Quaquaval"]
    print("\nSearch knobs:")
    print("  EV search: matchup-aware 4-EV lattice with Pareto pruning + local redistribution.")
    _mv_counts = {
        sp: len(movesets_from_pool(LEGAL_MOVES[sp], FOUR_PHYSICAL_ONLY[sp], sp))
        for sp in order
    }
    print(f"  Movesets per species: {_mv_counts}")
    print(f"  SEARCH_TURNS: {SEARCH_TURNS}, LOCAL_REFINE_PASSES: {LOCAL_REFINE_PASSES}")

    # Coordinate descent for trio
    bests, per_wr_all = coordinate_descent_trio(order, canonical_threats, rounds=2)

    avg, agg, used = trio_objective(bests, canonical_threats)

    print("\n================== RESULT (CANDIDATE) ==================")
    for sp in order:
        b = bests[sp]
        print(f"\n!requestSV {sp} @ {b.item}")
        print(f"Ability: {b.ability or SPECIES_DATA[sp].ability_hint or '—'}")
        print(f"Tera Type: {b.tera_type}")
        print("Level: 100")
        print(
            f"EVs: {b.evs['HP']} HP / {b.evs['Atk']} Atk / {b.evs['Def']} Def / {b.evs['SpA']} SpA / {b.evs['SpD']} SpD / {b.evs['Spe']} Spe"
        )
        print(f"{b.nature} Nature")
        for m in b.moves:
            print(f"- {m}")

    print("\n================== TRIO OBJECTIVE ==================")
    print(
        f"Avg best-of-trio P(win) across {used} usable threats (vs variant mixtures): {avg:.3f}"
    )
    losses = [t for t, v in agg.items() if (v < 0.5)]
    print(f"Outright losses (best-of-trio): {len(losses)} -> {sorted(losses)}")

    dur = time.time() - start
    print(f"\nDone in {dur:.1f}s on CPU.")
    print("Tips:")
    print("- For speed: reduce EV_STEPS or THREAT_LIST; sample fewer movesets.")
    print("- For quality: widen movesets or EV grid; increase LOCAL_REFINE_PASSES.")
    print(
        "- SEARCH_TURNS is set to 3 to match official 1v1 sudden-death; keep it at 3 for fidelity."
    )


# === SV 1v1 OPTIMIZER — PATCH 3.1.0 ===
# Purpose: remove physical-only bias, use legality-correct movepools, add missing meta moves,
#          and (CRITICAL) choose EV axes dynamically per *moveset* (not species base stats).
# Sources for movepools (Gen 9 / SV):
#   - Swampert moves (SV): https://pokemondb.net/pokedex/swampert/moves/9
#   - Blaziken moves (SV): https://pokemondb.net/pokedex/blaziken/moves/9
#   - Quaquaval moves (SV): https://pokemondb.net/pokedex/quaquaval/moves/9
# Notes:
#   - We only include moves that actually matter in 1v1 (damaging STAB, key coverages, Protect, SD, Counter where legal).
#   - We keep your no-RNG damage roll approximation and 3-turn sudden-death fidelity.
#   - This patch appends/overrides — paste near the *end* of the file (after all definitions). Later defs win in Python.

# ------------------------------
# 1) Add/ensure missing moves in MOVE_DB (+ recoil table)
# ------------------------------
if "High Jump Kick" not in MOVE_DB:
    MOVE_DB["High Jump Kick"] = Move("High Jump Kick", "Fighting", "Physical", 130, 0.9, contact=True)
if "Aqua Jet" not in MOVE_DB:
    MOVE_DB["Aqua Jet"] = Move("Aqua Jet", "Water", "Physical", 40, 1.0, contact=True, priority=1)
if "Wave Crash" not in MOVE_DB:
    MOVE_DB["Wave Crash"] = Move("Wave Crash", "Water", "Physical", 120, 1.0, contact=True)
if "Hammer Arm" not in MOVE_DB:
    MOVE_DB["Hammer Arm"] = Move("Hammer Arm", "Fighting", "Physical", 100, 0.9, contact=True)
if "Superpower" not in MOVE_DB:
    MOVE_DB["Superpower"] = Move("Superpower", "Fighting", "Physical", 120, 1.0, contact=True)
if "Body Press" not in MOVE_DB:
    MOVE_DB["Body Press"] = Move("Body Press", "Fighting", "Physical", 80, 1.0, contact=True)
if "Earth Power" not in MOVE_DB:
    MOVE_DB["Earth Power"] = Move("Earth Power", "Ground", "Special", 90, 1.0)
if "Surf" not in MOVE_DB:
    MOVE_DB["Surf"] = Move("Surf", "Water", "Special", 90, 1.0)
if "Waterfall" not in MOVE_DB:
    MOVE_DB["Waterfall"] = Move("Waterfall", "Water", "Physical", 80, 1.0, contact=True)
if "Aqua Cutter" not in MOVE_DB:
    MOVE_DB["Aqua Cutter"] = Move("Aqua Cutter", "Water", "Physical", 70, 1.0, contact=True)

# Recoil table updates
RECOIL_RATIO["Wave Crash"] = 1 / 3  # same recoil model as Brave Bird/Flare Blitz class

# ------------------------------
# 2) Critical mechanics patch — High Jump Kick crash on MISS
# ------------------------------
# Override branch_on_move to inject crash damage only for the MISS branch of High Jump Kick

# ------------------------------
# 3) Legality-correct movepools (SV) for the trio
# ------------------------------
LEGAL_MOVES = {
    "Swampert": LEGAL_MOVES_SWAMPERT,
    "Blaziken": LEGAL_MOVES_BLAZIKEN,
    "Quaquaval": LEGAL_MOVES_QUAQUAVAL,
}

MOVE_POOLS = {k: list(LEGAL_MOVES[k]) for k in LEGAL_MOVES}

FOUR_PHYSICAL_ONLY = {k: False for k in LEGAL_MOVES}


def assert_legal_moves(species: str, moves: List[str]) -> None:
    legal = set(LEGAL_MOVES.get(species, []))
    bad = [m for m in moves if m not in legal]
    if bad:
        raise ValueError(f"Illegal moves for {species}: {bad}")


# ------------------------------
# 4) EV axes must depend on the MOVES used (CRITICAL FIX)
# ------------------------------
def _is_damaging(mname: str) -> bool:
    return MOVE_DB[mname].category in ("Physical", "Special")


# ------------------------------
# 6) Bump version label for clarity at runtime
# ------------------------------
def _print_version_banner():
    print("== SV 1v1 Optimizer — CPU only ==")
    print("Version:", "3.1.0")
    print("Note: 3.1.0 enables legality-correct movepools and dynamic EV axes per moveset (phys/spec/mixed).")


_old_main = main


def main():
    start = time.time()
    _print_version_banner()
    globals()["_svi_banner_override"] = True
    try:
        return _old_main()
    finally:
        globals().pop("_svi_banner_override", None)






# === SV 1v1 OPTIMIZER — ACCURACY PATCH 4.0 (Legality + full 4-move enumeration) ===
# Main fix: replace ad-hoc moveset sampling with legality-aware, dominance-pruned full enumeration.
# This block supersedes earlier patches; keep it near the bottom so definitions override prior ones.

def _ensure_move(name: str, mtype: str, cat: str, power: int, acc: float = 1.0, *, contact: bool = False, **kw) -> None:
    if name not in MOVE_DB:
        MOVE_DB[name] = Move(name, mtype, cat, power, acc, contact=contact, **kw)

# Water / Ground / Ice / Rock / Fighting / Fire / Electric / Ghost / Dark / Flying / Bug helpers
_ensure_move("Waterfall", "Water", "Physical", 80, 1.0, contact=True)
_ensure_move("Liquidation", "Water", "Physical", 85, 1.0, contact=True)
_ensure_move("Surf", "Water", "Special", 90, 1.0)
_ensure_move("Hydro Pump", "Water", "Special", 110, 0.8)
_ensure_move("Flip Turn", "Water", "Physical", 60, 1.0, contact=True)
_ensure_move("Aqua Jet", "Water", "Physical", 40, 1.0, contact=True, priority=1)
_ensure_move("Wave Crash", "Water", "Physical", 120, 1.0, contact=True)
RECOIL_RATIO["Wave Crash"] = 1 / 3

_ensure_move("Earth Power", "Ground", "Special", 90, 1.0)
_ensure_move("Stomping Tantrum", "Ground", "Physical", 75, 1.0, contact=True)
_ensure_move("Bulldoze", "Ground", "Physical", 60, 1.0)

_ensure_move("Ice Beam", "Ice", "Special", 90, 1.0)
_ensure_move("Ice Fang", "Ice", "Physical", 65, 0.95, contact=True)
_ensure_move("Avalanche", "Ice", "Physical", 60, 1.0, contact=True)
_ensure_move("Ice Spinner", "Ice", "Physical", 80, 1.0, contact=True)

_ensure_move("Stone Edge", "Rock", "Physical", 100, 0.8)
_ensure_move("Rock Slide", "Rock", "Physical", 75, 0.9)
_ensure_move("Rock Tomb", "Rock", "Physical", 60, 0.95)

_ensure_move("Hammer Arm", "Fighting", "Physical", 100, 0.9, contact=True)
_ensure_move("Superpower", "Fighting", "Physical", 120, 1.0, contact=True)
_ensure_move("Body Press", "Fighting", "Physical", 80, 1.0, contact=True)
_ensure_move("Brick Break", "Fighting", "Physical", 75, 1.0, contact=True)

_ensure_move("Flamethrower", "Fire", "Special", 90, 1.0)
_ensure_move("Overheat", "Fire", "Special", 130, 0.9)
_ensure_move("Blaze Kick", "Fire", "Physical", 85, 0.9, contact=True)
_ensure_move("Fire Punch", "Fire", "Physical", 75, 1.0, contact=True, is_punch=True)

_ensure_move("Thunder Punch", "Electric", "Physical", 75, 1.0, contact=True, is_punch=True)

_ensure_move("Shadow Claw", "Ghost", "Physical", 70, 1.0, contact=True)
_ensure_move("Knock Off", "Dark", "Physical", 65, 1.0, contact=True)

_ensure_move("Brave Bird", "Flying", "Physical", 120, 1.0, contact=True)
RECOIL_RATIO["Brave Bird"] = 1 / 3
_ensure_move("Acrobatics", "Flying", "Physical", 55, 1.0, contact=True)
_ensure_move("Aerial Ace", "Flying", "Physical", 60, 1.0, contact=True)

_ensure_move("U-turn", "Bug", "Physical", 70, 1.0, contact=True)

# Complete, SV-legal movepools for the trio (damaging moves + core tech the engine models)
LEGAL_MOVES = {
    "Swampert": LEGAL_MOVES_SWAMPERT,
    "Blaziken": LEGAL_MOVES_BLAZIKEN,
    "Quaquaval": LEGAL_MOVES_QUAQUAVAL,
}

MOVE_POOLS = {k: list(LEGAL_MOVES[k]) for k in LEGAL_MOVES}
FOUR_PHYSICAL_ONLY = {k: False for k in LEGAL_MOVES}


if "Quaquaval" in LEGAL_MOVES:
    LEGAL_MOVES["Quaquaval"] = [m for m in LEGAL_MOVES["Quaquaval"] if m != "Sacred Sword"]
    MOVE_POOLS["Quaquaval"] = list(LEGAL_MOVES["Quaquaval"])


def _stab_like_for_move(species: str, move_name: str, tera_pool: list[str]) -> float:
    """Return the best achievable STAB multiplier for this move given base typing and Tera."""

    mv = MOVE_DB[move_name]
    base_types = tuple(t for t in SPECIES_DATA[species].types if t)
    base_stab = 1.5 if mv.mtype in base_types else 1.0
    tera_stab = 1.5 if mv.mtype in tera_pool else 1.0
    if base_stab > 1.0 and mv.mtype in tera_pool:
        return 2.0
    return max(base_stab, tera_stab)


def _synergy_mult_for_move(move: Move, species: str) -> float:
    """Lightweight multipliers to reward broadly good synergies without simulating items."""

    mult = 1.0
    if move.is_punch:
        mult *= 1.05
    if move.priority > 0:
        mult *= 1.03
    if move.accuracy < 0.9:
        mult *= 0.97
    return mult


def _coverage_score_approx(species: str, move_name: str) -> float:
    """Approximate the incremental type coverage this move brings for the species."""

    mv = MOVE_DB[move_name]
    spec = SPECIES_DATA[species]
    primary = spec.types[0] or spec.types[1] or mv.mtype
    gain = type_coverage_gain(spec, primary, mv.mtype)
    return max(0.0, gain)


def _rank_moves_for_species(species: str, pool: list[str], tera_pool: list[str]) -> list[str]:
    """Rank moves from best to worst using a fast heuristic that values coverage and STAB."""

    scored: list[tuple[str, float]] = []
    for name in pool:
        mv = MOVE_DB[name]
        if mv.category == "Status":
            keep_status = mv.is_protect or mv.is_swords_dance or mv.is_counter or mv.is_mirror_coat or (
                name in {"Detect", "Encore", "Taunt"}
            )
            if not keep_status:
                continue
            scored.append((name, 0.25))
            continue

        stab_like = _stab_like_for_move(species, name, tera_pool)
        cover = _coverage_score_approx(species, name)
        powr = base_power(mv) / 100.0
        acc_stat = mv.accuracy if mv.accuracy is not None else 1.0
        acc = max(0.5, min(1.0, acc_stat))
        syn = _synergy_mult_for_move(mv, species)
        score = (1.25 * stab_like) + (1.10 * cover) + (1.00 * powr) + (0.50 * acc)
        score *= syn
        scored.append((name, float(score)))

    scored.sort(key=lambda x: x[1], reverse=True)
    return [name for name, _ in scored]


TOPK_MOVES_PER_SPECIES = {
    "Swampert": 14,
    "Blaziken": 14,
    "Quaquaval": 14,
}


def _top_moves_subset(species: str) -> list[str]:
    full = MOVE_POOLS.get(species, LEGAL_MOVES.get(species, []))
    tera_pool = TERA_POOLS.get(species, [])
    ranked = _rank_moves_for_species(species, list(full), tera_pool)
    k = TOPK_MOVES_PER_SPECIES.get(species, 14)
    pin = [m for m in ["Protect", "Swords Dance", "Counter", "Detect", "Encore", "Taunt"] if m in ranked]
    head = [m for m in ranked if m not in pin][: max(0, k - len(pin))]
    return (head + pin)[:k]

def assert_legal_moves(species: str, moves: list[str]) -> None:
    legal = set(LEGAL_MOVES.get(species, []))
    bad = [m for m in moves if m not in legal]
    if bad:
        raise ValueError(f"Illegal moves for {species}: {bad}")


def _move_dominance_key(mv: Move) -> tuple:
    return (mv.power, mv.accuracy, mv.priority)


def reduce_pool_by_dominance(pool_names: list[str]) -> list[str]:
    buckets: dict[tuple[str, str], list[Move]] = {}
    for name in pool_names:
        mv = MOVE_DB[name]
        if mv.category == "Status":
            continue
        buckets.setdefault((mv.mtype, mv.category), []).append(mv)

    kept: set[str] = set()
    for lst in buckets.values():
        lst_sorted = sorted(lst, key=_move_dominance_key, reverse=True)
        if lst_sorted:
            kept.add(lst_sorted[0].name)
        if len(lst_sorted) >= 2:
            top, second = lst_sorted[0], lst_sorted[1]
            if (top.power - second.power >= 20 and second.accuracy - top.accuracy >= 0.1) or (
                second.priority > top.priority
            ):
                kept.add(second.name)

    for name in pool_names:
        mv = MOVE_DB[name]
        if mv.category == "Status" or name in {"Counter", "Mirror Coat", "Protect", "Swords Dance"}:
            kept.add(name)
    return sorted(kept)


def _is_damaging(mname: str) -> bool:
    return MOVE_DB[mname].category in ("Physical", "Special")


def _is_stab(species: str, mname: str) -> bool:
    t1, t2 = SPECIES_DATA[species].types
    return MOVE_DB[mname].mtype in {t for t in (t1, t2) if t}


def _moveset_profile(moves: list[str]) -> str:
    cats = {MOVE_DB[m].category for m in moves if _is_damaging(m)}
    if not cats:
        return "none"
    if cats == {"Physical"}:
        return "phys"
    if cats == {"Special"}:
        return "spec"
    return "mixed"


def _ev_axes_for_moveset(moves: list[str]) -> tuple[str, ...]:
    prof = _moveset_profile(moves)
    if prof == "phys":
        return ("HP", "Atk", "Def", "Spe")
    if prof == "spec":
        return ("HP", "SpA", "SpD", "Spe")
    return ("HP", "Atk", "SpA", "Spe")


def movesets_from_pool_topk(
    pool: list[str], four_physical_only: bool = False, *, species: Optional[str] = None
) -> list[list[str]]:
    topk = _top_moves_subset(species) if species else list(pool)
    if four_physical_only:
        topk = [name for name in topk if MOVE_DB[name].category != "Special"]

    out: list[list[str]] = []
    for combo in itertools.combinations(topk, 4):
        moves = list(combo)
        if not any(_is_damaging(m) for m in moves):
            continue
        if species is not None and not any(_is_damaging(m) and _is_stab(species, m) for m in moves):
            continue
        if sum(1 for m in moves if m == "Protect") > 1:
            continue
        if sum(1 for m in moves if m == "Swords Dance") > 1:
            continue
        if sum(1 for m in moves if MOVE_DB[m].priority > 0) > 1:
            continue
        out.append(moves)
    return out


def _print_trio_movepool_summary():
    for s in ["Swampert", "Blaziken", "Quaquaval"]:
        topk = _top_moves_subset(s)
        print(
            f"[movepool:{s}] legal={len(LEGAL_MOVES[s])} | topK={len(topk)} -> exhaustive 4-move combos from top-K (no subsampling)"
        )


LOCAL_REFINE_PASSES = max(LOCAL_REFINE_PASSES, 40)



def _print_version_banner_accurate() -> None:
    if globals().get("_svi_banner_override_v5"):
        return
    print("== SV 1v1 Optimizer — CPU only ==")
    print("Version:", "4.0 (No moveset sampling; legality + dominance + full enumeration)")
    print("Note: Complete, legality-aware 4-move enumeration with pruning; dynamic EV axes per moveset.")


if "main" in globals():
    _old_main_v4 = main

    def main() -> object:
        _print_version_banner_accurate()
        globals()["_svi_banner_override"] = True
        try:
            return _old_main_v4()
        finally:
            globals().pop("_svi_banner_override", None)


if "main" in globals() and not globals().get("_svi_v5_installed"):
    _prev_main_v5 = main

    def main() -> object:
        globals()["_svi_banner_override_v5"] = True
        try:
            _print_version_banner_v5_wrap()
            return _prev_main_v5()
        finally:
            globals().pop("_svi_banner_override_v5", None)

    globals()["_svi_v5_installed"] = True


if __name__ == "__main__":
    main()
# === CRITICAL ACCURACY FIX — DYNAMIC EV AXES PER MOVESET (Gen 9 SV 1v1) ===
# Paste this WHOLE block near the *end* of your file so it overrides earlier defs.
# WHY (main issue to fix):
# Your EV search chooses the 4 EV axes from species BASE STATS (Atk vs SpA) instead of the
# actual MOVES in the candidate set. That systematically misses special/mixed best sets
# (e.g., Swampert with Surf/Ice Beam/Earth Power or Blaziken with Focus Blast/Overheat),
# so you never even *consider* optimal SpA allocations for those sets. Result: incorrect
# "best builds" and depressed win rates across the threat list.
#
# WHAT THIS PATCH DOES:
# 1) For EVERY candidate moveset, classify its offensive profile (Physical / Special / Mixed)
#    using effective base power (+ a Tera Blast rule).
# 2) Pick EV axes *per moveset*, not per species:
#       - Physical  -> ("HP","Atk", DEF_AXIS, "Spe")
#       - Special   -> ("HP","SpA", SPD_AXIS, "Spe")
#       - Mixed     -> ("HP","Atk","SpA","Spe")   (def axis handled by refine)
#    DEF_AXIS / SPD_AXIS is chosen from your representative threat pool to bias toward the
#    side most attacks come from (physical vs special).
# 3) Use those axes both in the Pareto grid enumeration *and* in local EV refinement so the
#    optimizer can actually move EVs into SpA for special/mixed sets (or back to Atk for physical).
#
# 4) Also tightens legality lists for the trio from SV Gen 9 (level/TM/egg/tutor),
#    so the move pools align with Scarlet/Violet. (Sources in comments below.)
#
# Drop-in: no external deps; preserves your search/scoring/minimax mechanics.

# -----------------------------
# 0) (Re)ensure key Gen 9 moves exist (idempotent)
# -----------------------------
def _ensure_move(name: str, mtype: str, cat: str, power: int, acc: float = 1.0, *, contact: bool = False, priority: int = 0, is_punch: bool = False, always_crit: bool = False, is_slicing: bool = False, multi_hits: int = 1, is_tera_blast: bool = False):
    if name not in MOVE_DB:
        MOVE_DB[name] = Move(name, mtype, cat, power, acc, contact=contact, priority=priority, is_punch=is_punch, always_crit=always_crit, is_tera_blast=is_tera_blast, multi_hits=multi_hits)
        if is_slicing:
            object.__setattr__(MOVE_DB[name], "is_slicing", True)

# Water / Ground / Ice / Fighting / Rock / Electric / Psychic staples (SV-legal)
_ensure_move("Surf", "Water", "Special", 90)
_ensure_move("Hydro Pump", "Water", "Special", 110, 0.8)
_ensure_move("Waterfall", "Water", "Physical", 80, contact=True)
_ensure_move("Liquidation", "Water", "Physical", 85, contact=True)
_ensure_move("Flip Turn", "Water", "Physical", 60, contact=True)
_ensure_move("Aqua Jet", "Water", "Physical", 40, contact=True, priority=1)
_ensure_move("Wave Crash", "Water", "Physical", 120, contact=True)
_ensure_move("Hydro Cannon", "Water", "Special", 150, 0.9)

_ensure_move("Earth Power", "Ground", "Special", 90)
_ensure_move("High Horsepower", "Ground", "Physical", 95, 0.95)
_ensure_move("Stomping Tantrum", "Ground", "Physical", 75)
_ensure_move("Bulldoze", "Ground", "Physical", 60)
_ensure_move("Dig", "Ground", "Physical", 80)
_ensure_move("Earthquake", "Ground", "Physical", 100)

_ensure_move("Ice Beam", "Ice", "Special", 90)
_ensure_move("Ice Punch", "Ice", "Physical", 75, contact=True)
_ensure_move("Ice Spinner", "Ice", "Physical", 80, contact=True)
_ensure_move("Avalanche", "Ice", "Physical", 60)

_ensure_move("Close Combat", "Fighting", "Physical", 120, contact=True)
_ensure_move("Drain Punch", "Fighting", "Physical", 75, contact=True)
_ensure_move("Low Kick", "Fighting", "Physical", 1, contact=True)
_ensure_move("Brick Break", "Fighting", "Physical", 75)
_ensure_move("Body Press", "Fighting", "Physical", 80, contact=True)
_ensure_move("Bulk Up", "Fighting", "Status", 0)

_ensure_move("Flare Blitz", "Fire", "Physical", 120, contact=True)
_ensure_move("Overheat", "Fire", "Special", 130, 0.9)
_ensure_move("Flamethrower", "Fire", "Special", 90)
_ensure_move("Fire Blast", "Fire", "Special", 110, 0.85)
_ensure_move("Blaze Kick", "Fire", "Physical", 85, 0.9, contact=True)

_ensure_move("Rock Slide", "Rock", "Physical", 75, 0.9)
_ensure_move("Stone Edge", "Rock", "Physical", 100, 0.8)
_ensure_move("Stealth Rock", "Rock", "Status", 0)

_ensure_move("Thunder Punch", "Electric", "Physical", 75, contact=True)
_ensure_move("Wild Charge", "Electric", "Physical", 90, contact=True)

_ensure_move("Zen Headbutt", "Psychic", "Physical", 80, 0.9, contact=True)
_ensure_move("Psyshock", "Psychic", "Special", 80)

_ensure_move("Brave Bird", "Flying", "Physical", 120, contact=True)
_ensure_move("Aerial Ace", "Flying", "Physical", 60, contact=True)
_ensure_move("Acrobatics", "Flying", "Physical", 55, 1.0, contact=True)
_ensure_move("Hurricane", "Flying", "Special", 110, 0.7)

_ensure_move("Knock Off", "Dark", "Physical", 65, contact=True)
_ensure_move("Night Slash", "Dark", "Physical", 70, contact=True)
_ensure_move("Sucker Punch", "Dark", "Physical", 70, contact=True, priority=1)

_ensure_move("Tera Blast", "Normal", "Special", 80, is_tera_blast=True)

RECOIL_RATIO["Wave Crash"] = 1/3
RECOIL_RATIO["Flare Blitz"] = 1/3
RECOIL_RATIO["Brave Bird"] = 1/3
RECOIL_RATIO["Wild Charge"] = 1/4

# -----------------------------
# 1) Tight, legality-correct SV move pools (curated for 1v1; includes level/TM/egg/tutor)
#    Sources: Pokémon DB Gen 9 learnsets (Scarlet/Violet) for Swampert, Blaziken, Quaquaval.
#    (See end of this block for links.)
# -----------------------------
SV_MOVES_SWAMPERT = sorted(set([
    # Water
    "Aqua Jet","Flip Turn","Liquidation","Surf","Hydro Pump","Waterfall","Chilling Water","Muddy Water","Hydro Cannon","Rain Dance",
    # Ground
    "Earthquake","Earth Power","High Horsepower","Stomping Tantrum","Bulldoze","Sand Tomb","Dig","Mud Shot",
    # Ice
    "Ice Beam","Ice Punch","Ice Spinner","Avalanche","Icy Wind","Blizzard",
    # Rock
    "Rock Slide","Rock Tomb","Stone Edge","Stealth Rock","Smack Down","Rock Throw",
    # Fighting / Normal / Utility
    "Low Kick","Brick Break","Body Press","Hammer Arm","Bulk Up","Counter","Protect","Detect","Substitute","Endure","Rest","Sleep Talk","Roar","Amnesia","Endeavor","Facade","Giga Impact","Hyper Beam","Double-Edge","Helping Hand",
    # Coverage
    "Poison Jab","Knock Off","Zen Headbutt","Weather Ball","Focus Blast","Outrage","Tera Blast"
]))

SV_MOVES_BLAZIKEN = sorted(set([
    # Fire
    "Flare Blitz","Blaze Kick","Flamethrower","Fire Blast","Overheat","Heat Wave","Flame Charge","Sunny Day","Fire Spin",
    # Fighting
    "Close Combat","Low Kick","Brick Break","Drain Punch","Reversal","Body Press","Bulk Up","Counter","Focus Energy",
    # Flying
    "Brave Bird","Aerial Ace","Bounce","Acrobatics",
    # Dark / Ghost
    "Knock Off","Night Slash","Sucker Punch","Thief","Shadow Claw",
    # Ground / Rock
    "Earthquake","Bulldoze","Dig","Rock Slide","Rock Tomb","Stone Edge","Stomping Tantrum",
    # Electric / Psychic / Poison
    "Thunder Punch","Zen Headbutt","Poison Jab",
    # Utility / Normal
    "Quick Attack","Agility","Taunt","Encore","Protect","Detect","Substitute","Endure","Work Up","Baton Pass","Roar","Facade","Giga Impact","Hyper Beam","Rest","Sleep Talk",
    # Water niche
    "Rain Dance",
    # Tera
    "Tera Blast"
]))

SV_MOVES_QUAQUAVAL = sorted(set([
    # Signature / Water
    "Aqua Step","Aqua Cutter","Aqua Jet","Liquidation","Waterfall","Flip Turn","Surf","Hydro Pump","Hydro Cannon","Chilling Water","Rain Dance",
    # Fighting
    "Close Combat","Drain Punch","Brick Break","Low Kick","Reversal","Bulk Up","Body Press","Counter",
    # Flying
    "Brave Bird","Acrobatics","Aerial Ace","Air Slash","Hurricane",
    # Ice
    "Ice Spinner","Avalanche","Icy Wind","Ice Beam",
    # Dark / Bug / Grass
    "Knock Off","U-turn","Pounce","Trailblaze",
    # Utility / Normal
    "Protect","Detect","Encore","Taunt","Substitute","Rest","Sleep Talk","Giga Impact","Hyper Beam","Facade","Endure","Helping Hand",
    # Ground / Rock
    "Bulldoze","Rock Slide","Rock Tomb","Stone Edge",
    # Electric / Psychic
    "Thunder Punch","Zen Headbutt",
    # Tera
    "Tera Blast"
]))

LEGAL_MOVES.update({
    "Swampert": SV_MOVES_SWAMPERT,
    "Blaziken": SV_MOVES_BLAZIKEN,
    "Quaquaval": SV_MOVES_QUAQUAVAL,
})

def assert_legal_moves(species: str, moves: list[str]) -> None:
    legal = set(LEGAL_MOVES.get(species, []))
    bad = [m for m in moves if m not in legal]
    if bad:
        raise ValueError(f"Illegal moves for {species}: {bad}")

# === ACCURACY HOTFIX — DYNAMIC EV AXES PER MOVESET (PRIMARY FIX) ================================
# WHY this fix matters (for Codex to implement cleanly, keep comments):
# Your EV search currently picks EV axes (HP/Atk/Def/Spe vs HP/SpA/SpD/Spe) *by species base stats*
# before you know which 4 moves the set actually uses. This systematically mis-allocates EVs for
# mixed or special-leaning movesets (e.g., Swampert running Surf/Ice Beam), causing the optimizer
# to miss the true best builds. The main fix is to (1) derive the EV axes *per moveset* and (2)
# enumerate EV candidates *inside* the moveset loop so each candidate’s EV grid is appropriate.
#
# What this patch does:
#   1) Adds a robust moveset profiler (Physical / Special / Mixed) that ignores Status moves and
#      handles Tera Blast category properly (physical only when Terastallized and Atk>=SpA).
#   2) Chooses EV axes per moveset:
#        - Physical  -> ("HP","Atk","Def","Spe")
#        - Special   -> ("HP","SpA","SpD","Spe")
#        - Mixed     -> ("HP","Atk","SpA","Spe")  (both offenses; rely on Pareto proxy for bulk)
#      This maximizes search pressure on the stats that matter for that exact 4-move set.
#   3) Moves the EV enumeration into the moveset loop (so axes are per-moveset), while keeping
#      your matchup-aware Speed pruning and Pareto filtering.
#   4) Ensures local EV refinement uses the SAME axes chosen for the winning moveset (both in
#      solo and trio-conditioned objectives), preventing the refiner from “sliding” on the wrong
#      axes and undoing the main improvement.
#
# Drop this block toward the BOTTOM of the file so it overrides prior defs of
#   - enumerate_candidates_for_species(...)
#   - build_search_for_species(...)
# and reuses your existing helpers (iterate_evs_axes_matchup_aware, refine_evs_local, etc.).
# ================================================================================================

# -- Helper: categorize a single move’s offensive contribution (ignores pure Status)
def _offense_kind_for_move(mname: str, attacker_stats: dict[str, int], tera_active: bool) -> str:
    mv = MOVE_DB[mname]
    if mv.category == "Status":
        return "None"
    # Tera Blast is special unless Terastallized; if tera is on, category is whichever atk stat is higher
    if mv.is_tera_blast:
        if tera_active:
            return "Physical" if attacker_stats["Atk"] >= attacker_stats["SpA"] else "Special"
        else:
            # Not Terastallized: Tera Blast is Normal/Special in your sim
            return "Special"
    return mv.category  # "Physical" or "Special"

# -- Helper: profile an ENTIRE 4-move set (Physical / Special / Mixed)
def moveset_offense_profile(species: str, moves: list[str], tera_type: str | None) -> str:
    # Use level-100 neutral spread for coarse stat comparison (we only need Atk vs SpA ordering here).
    # Nature effects are small vs 1.1/0.9 and won’t flip often; we deliberately avoid biasing to species base stats
    # by computing actual stats from calc_stats (reuses your engine) with neutral nature and 0 EVs/31 IVs.
    spec = SPECIES_DATA[species]
    neutral = "Serious"
    base_evs = {"HP":0,"Atk":0,"Def":0,"SpA":0,"SpD":0,"Spe":0}
    base_ivs = {"HP":31,"Atk":31,"Def":31,"SpA":31,"SpD":31,"Spe":31}
    stats = calc_stats(spec, neutral, base_evs, base_ivs)

    # Whether Tera is *available* for this set this turn is irrelevant to axes selection;
    # we treat Tera Blast as Special unless Terastallized, and as Physical or Special if Tera’d based on Atk vs SpA.
    # For axes decision we conservatively assume the user may Tera (tera_active=True) because it broadens the set’s
    # offensive envelope and avoids misclassifying Tera Blast sets as Special-only.
    tera_active = bool(tera_type)

    phys = 0
    specn = 0
    for m in moves:
        kind = _offense_kind_for_move(m, stats, tera_active)
        if kind == "Physical":
            phys += 1
        elif kind == "Special":
            specn += 1

    if phys > 0 and specn == 0:
        return "Physical"
    if specn > 0 and phys == 0:
        return "Special"
    if phys == 0 and specn == 0:
        # All Status (shouldn’t pass filter anyway); default to Physical axes to keep search stable
        return "Physical"
    return "Mixed"

# -- Helper: choose EV axes per moveset profile
def axes_for_moveset(profile: str) -> tuple[str, ...]:
    if profile == "Physical":
        return ("HP","Atk","Def","Spe")
    if profile == "Special":
        return ("HP","SpA","SpD","Spe")
    # Mixed: invest both offenses + Speed; let Pareto proxy shape bulk implicitly via HP*Def/HP*SpD
    return ("HP","Atk","SpA","Spe")

# -- Helper: representative opponent shortlist reused from your existing implementation
def _representative_opp_builds(threat_list: list[str]) -> list["SetBuild"]:
    rep_opp: list["SetBuild"] = []
    seen = set()
    for t in threat_list:
        r = resolve_species_name(t) or t
        if r in seen: 
            continue
        seen.add(r)
        av = adversary_variants(r)
        if av:
            builds, _w = av
            if builds:
                rep_opp.append(builds[0])
        if len(rep_opp) >= 12:
            break
    return rep_opp

# -- REPLACEMENT: enumerate_candidates_for_species (now EVs per MOVES-SET, not per SPECIES)
def enumerate_candidates_for_species(species: str) -> list["SetBuild"]:
    """
    Generate candidate builds for this species:
      items × tera × natures × (4-move subsets) × (EV Pareto per-moveset axes)
    This function now computes EV grids INSIDE the moveset loop so that EV axes depend on the actual 4 moves.
    """
    spec = SPECIES_DATA[species]
    items = ITEM_CANDIDATES[species]
    teras = TERA_POOLS[species]
    pool = LEGAL_MOVES[species]
    ms_all = movesets_from_pool(pool, FOUR_PHYSICAL_ONLY[species], species)

    # Use representative opp builds for matchup-aware Speed targets
    rep_opp = _representative_opp_builds(THREAT_LIST)

    ivs31 = {k: 31 for k in ["HP","Atk","Def","SpA","SpD","Spe"]}
    cands: list["SetBuild"] = []

    # Keep your nature pools per species to constrain search
    if species == "Swampert":
        nature_pool = ["Adamant", "Careful", "Impish", "Modest", "Calm", "Bold"]  # allow special-leaning options
    elif species == "Blaziken":
        nature_pool = ["Jolly", "Adamant", "Naive", "Hasty"]  # mixed viability with Brave Bird/Flare Blitz + Special tech
    else:
        nature_pool = ["Jolly", "Adamant", "Naive", "Hasty"]  # Quaquaval often Physical but Mixed appears (Ice Beam tech rare)

    for item in items:
        for tera in teras:
            for mv in ms_all:
                # Skip illegal/AV/Choice status violations using your existing filter
                if not filter_moveset_by_item(item, mv):
                    continue
                assert_legal_moves(species, mv)

                # Decide EV axes from the actual 4-move set (CRITICAL)
                profile = moveset_offense_profile(species, mv, tera)
                ev_axes = axes_for_moveset(profile)

                # Enumerate EV Pareto on those axes, matchup-aware for Speed
                for nature in nature_pool:
                    ev_pareto = iterate_evs_axes_matchup_aware(ev_axes, species, nature, item, rep_opp)
                    for evs in ev_pareto:
                        if not valid_evs(evs):
                            continue
                        cands.append(
                            SetBuild(
                                species=species,
                                item=item,
                                ability=spec.ability_hint,
                                tera_type=tera,
                                nature=nature,
                                evs=evs,
                                ivs=ivs31,
                                moves=mv,
                            )
                        )
    return cands

# -- Helper: pick axes AGAIN for a specific candidate (used by local refiner)
def axes_for_candidate(sb: "SetBuild") -> tuple[str, ...]:
    prof = moveset_offense_profile(sb.species, sb.moves, sb.tera_type)
    return axes_for_moveset(prof)

# -- REPLACEMENT: build_search_for_species now refines EVs using per-candidate axes
def build_search_for_species(
    species: str,
    threats: list[str],
    conditioned_on: dict[str, "SetBuild"] | None = None,
):
    threats_variants = prebuild_threat_variants(threats)
    if not threats_variants:
        return None, {}
    candidates = enumerate_candidates_for_species(species)
    if not candidates:
        return None, {}

    best = None
    per_wr = {}

    max_workers = max(1, (os.cpu_count() or 1))

    if conditioned_on is None:
        # SOLO objective — shortlist in parallel
        with ProcessPoolExecutor(max_workers=max_workers) as ex:
            futures = [
                ex.submit(eval_candidate_single, c, threats, threats_variants)
                for c in candidates
            ]
            for fut in as_completed(futures):
                score, wrs, cand = fut.result()
                if (best is None) or (score > best[0]):
                    best = (score, wrs, cand)

        # Local refine (SOLO) — use axes tied to the winning *moveset*
        def solo_eval_fn(sb: "SetBuild") -> float:
            wrs = []
            for name in threats:
                variants, weights = threats_variants[name]
                results = [simulate(sb, opp) for opp in variants]
                wrs.append(weighted_mean(results, weights))
            return sum(wrs) / len(wrs) if wrs else 0.0

        axes = axes_for_candidate(best[2])
        refined = refine_evs_local(best[2], solo_eval_fn, axes, passes=LOCAL_REFINE_PASSES)
        if refined.evs != best[2].evs:
            wrs = []
            for name in threats:
                variants, weights = threats_variants[name]
                results = [simulate(refined, opp) for opp in variants]
                wrs.append(weighted_mean(results, weights))
            best = (sum(wrs) / len(wrs) if wrs else 0.0, wrs, refined)

    else:
        # TRIO-conditioned objective — sequential with correct axes in refinement
        def trio_eval_fn(sb: "SetBuild") -> float:
            trio = dict(conditioned_on)
            trio[species] = sb
            wrs = []
            for name in threats:
                variants, weights = threats_variants[name]
                per_variant = []
                for opp in variants:
                    ours = max(simulate(b, opp) for _, b in trio.items())
                    per_variant.append(ours)
                wrs.append(weighted_mean(per_variant, weights))
            return sum(wrs) / len(wrs) if wrs else 0.0

        for c in candidates:
            score, wrs, cand = eval_candidate_trio(c, conditioned_on, threats, threats_variants)
            if (best is None) or (score > best[0]):
                best = (score, wrs, cand)

        axes = axes_for_candidate(best[2])
        refined = refine_evs_local(best[2], trio_eval_fn, axes, passes=LOCAL_REFINE_PASSES)
        if refined.evs != best[2].evs:
            wrs = []
            trio_fixed = dict(conditioned_on)
            trio_fixed[species] = refined
            for name in threats:
                variants, weights = threats_variants[name]
                per_variant = []
                for opp in variants:
                    ours = max(simulate(b, opp) for _, b in trio_fixed.items())
                    per_variant.append(ours)
                wrs.append(weighted_mean(per_variant, weights))
            best = (sum(wrs) / len(wrs) if wrs else 0.0, wrs, refined)

    if best is None:
        return None, {}
    per_wr = {threats[i]: best[1][i] for i in range(len(threats))}
    return best[2], per_wr

# -- Optional: bump version banner to reflect the primary accuracy fix
def _print_version_banner_v6():
    print("== SV 1v1 Optimizer — CPU only ==")
    print("Version:", "6.0 (per-moveset EV axes, EV search moved inside moveset loop)")
    print("Note: EV axes now match each moveset (Physical/Special/Mixed). Local EV refine uses the same axes.")

# Swap banner if a banner override hook exists
if "_svi_banner_override" not in globals() or not globals().get("_svi_banner_override", False):
    _orig_main_for_banner_swap = main if "main" in globals() else None
    def main():
        _print_version_banner_v6()
        return _orig_main_for_banner_swap() if _orig_main_for_banner_swap else None
